/** \file
 *  This C source file was generated by $ANTLR version 3.4
 *
 *     -  From the grammar source file : belle_sdp.g
 *     -                            On : 2014-10-14 21:26:55
 *     -                for the parser : belle_sdpParserParser
 *
 * Editing it, at least manually, is not wise.
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD license"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


/* =============================================================================
 * This is what the grammar programmer asked us to put at the top of every file.
 */

/*
    belle-sip - SIP (RFC3261) library.
    Copyright (C) 2010  Belledonne Communications SARL

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 2 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*/

#pragma GCC diagnostic ignored "-Wparentheses"
#pragma GCC diagnostic ignored "-Wunused"
#ifndef __clang__
#pragma GCC diagnostic ignored "-Wunused-but-set-variable"
#pragma GCC diagnostic ignored "-Wunused-variable"
#pragma GCC diagnostic ignored "-Wunused-function"
#endif

/* End of Header action.
 * =============================================================================
 */

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "belle_sdpParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */

#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pbelle_sdpParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pbelle_sdpParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pbelle_sdpParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pbelle_sdpParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */

#undef	    PARSER
#undef	    RECOGNIZER
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO
#undef		DBG

#define	    PARSER				ctx->pParser
#define	    RECOGNIZER				PARSER->rec
#define	    PSRSTATE				RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)			RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define	    MEMOIZE(ri,si)			RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT				PARSER->tstream
#define	    STRSTREAM				INPUT
#define	    ISTREAM				INPUT->istream
#define	    INDEX()				ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()			(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION				PSRSTATE->exception
#define	    MATCHT(t, fs)			RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()				RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK				PSRSTATE->following
#ifdef  SKIP_FOLLOW_SETS
#define	    FOLLOWPUSH(x)
#define	    FOLLOWPOP()
#else
#define	    FOLLOWPUSH(x)			FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()				FOLLOWSTACK->pop(FOLLOWSTACK)
#endif
#define	    PRECOVER()				RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()			RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)				INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)				INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()			RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()				ISTREAM->consume(ISTREAM)
#define	    MARK()				ISTREAM->mark(ISTREAM)
#define	    REWIND(m)				ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()			ISTREAM->rewindLast(ISTREAM)
#define	    SEEK(n)				ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY			PSRSTATE->errorRecovery
#define	    FAILEDFLAG				PSRSTATE->failed
#define	    HASFAILED()				(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING			PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger


#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */

/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_session_description scope set
 */
static pbelle_sdpParser_session_description_SCOPE   pbelle_sdpParser_session_descriptionPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL session_descriptionFree(pbelle_sdpParser_session_description_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL session_descriptionFree(pbelle_sdpParser_session_description_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser session_description scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_session_descriptionTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_session_description_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_session_description_SCOPE
pbelle_sdpParser_session_descriptionPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_session_description_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_session_descriptionStack->size(ctx->pbelle_sdpParser_session_descriptionStack) > ctx->pbelle_sdpParser_session_descriptionStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_session_description_SCOPE)ctx->pbelle_sdpParser_session_descriptionStack->get(ctx->pbelle_sdpParser_session_descriptionStack, ctx->pbelle_sdpParser_session_descriptionStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_session_description_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_session_description_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_session_descriptionStack->push(ctx->pbelle_sdpParser_session_descriptionStack, newAttributes, (void (*)(void *))session_descriptionFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_session_descriptionStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_origin scope set
 */
static pbelle_sdpParser_origin_SCOPE   pbelle_sdpParser_originPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL originFree(pbelle_sdpParser_origin_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL originFree(pbelle_sdpParser_origin_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser origin scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_originTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_origin_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_origin_SCOPE
pbelle_sdpParser_originPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_origin_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_originStack->size(ctx->pbelle_sdpParser_originStack) > ctx->pbelle_sdpParser_originStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_origin_SCOPE)ctx->pbelle_sdpParser_originStack->get(ctx->pbelle_sdpParser_originStack, ctx->pbelle_sdpParser_originStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_origin_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_origin_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_originStack->push(ctx->pbelle_sdpParser_originStack, newAttributes, (void (*)(void *))originFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_originStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_info scope set
 */
static pbelle_sdpParser_info_SCOPE   pbelle_sdpParser_infoPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL infoFree(pbelle_sdpParser_info_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL infoFree(pbelle_sdpParser_info_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser info scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_infoTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_info_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_info_SCOPE
pbelle_sdpParser_infoPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_info_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_infoStack->size(ctx->pbelle_sdpParser_infoStack) > ctx->pbelle_sdpParser_infoStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_info_SCOPE)ctx->pbelle_sdpParser_infoStack->get(ctx->pbelle_sdpParser_infoStack, ctx->pbelle_sdpParser_infoStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_info_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_info_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_infoStack->push(ctx->pbelle_sdpParser_infoStack, newAttributes, (void (*)(void *))infoFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_infoStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_email scope set
 */
static pbelle_sdpParser_email_SCOPE   pbelle_sdpParser_emailPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL emailFree(pbelle_sdpParser_email_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL emailFree(pbelle_sdpParser_email_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser email scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_emailTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_email_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_email_SCOPE
pbelle_sdpParser_emailPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_email_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_emailStack->size(ctx->pbelle_sdpParser_emailStack) > ctx->pbelle_sdpParser_emailStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_email_SCOPE)ctx->pbelle_sdpParser_emailStack->get(ctx->pbelle_sdpParser_emailStack, ctx->pbelle_sdpParser_emailStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_email_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_email_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_emailStack->push(ctx->pbelle_sdpParser_emailStack, newAttributes, (void (*)(void *))emailFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_emailStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_connection scope set
 */
static pbelle_sdpParser_connection_SCOPE   pbelle_sdpParser_connectionPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL connectionFree(pbelle_sdpParser_connection_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL connectionFree(pbelle_sdpParser_connection_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser connection scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_connectionTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_connection_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_connection_SCOPE
pbelle_sdpParser_connectionPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_connection_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_connectionStack->size(ctx->pbelle_sdpParser_connectionStack) > ctx->pbelle_sdpParser_connectionStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_connection_SCOPE)ctx->pbelle_sdpParser_connectionStack->get(ctx->pbelle_sdpParser_connectionStack, ctx->pbelle_sdpParser_connectionStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_connection_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_connection_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_connectionStack->push(ctx->pbelle_sdpParser_connectionStack, newAttributes, (void (*)(void *))connectionFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_connectionStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_bandwidth scope set
 */
static pbelle_sdpParser_bandwidth_SCOPE   pbelle_sdpParser_bandwidthPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL bandwidthFree(pbelle_sdpParser_bandwidth_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL bandwidthFree(pbelle_sdpParser_bandwidth_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser bandwidth scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_bandwidthTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_bandwidth_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_bandwidth_SCOPE
pbelle_sdpParser_bandwidthPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_bandwidth_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_bandwidthStack->size(ctx->pbelle_sdpParser_bandwidthStack) > ctx->pbelle_sdpParser_bandwidthStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_bandwidth_SCOPE)ctx->pbelle_sdpParser_bandwidthStack->get(ctx->pbelle_sdpParser_bandwidthStack, ctx->pbelle_sdpParser_bandwidthStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_bandwidth_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_bandwidth_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_bandwidthStack->push(ctx->pbelle_sdpParser_bandwidthStack, newAttributes, (void (*)(void *))bandwidthFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_bandwidthStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_attribute scope set
 */
static pbelle_sdpParser_attribute_SCOPE   pbelle_sdpParser_attributePush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL attributeFree(pbelle_sdpParser_attribute_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL attributeFree(pbelle_sdpParser_attribute_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser attribute scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_attributeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_attribute_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_attribute_SCOPE
pbelle_sdpParser_attributePush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_attribute_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_attributeStack->size(ctx->pbelle_sdpParser_attributeStack) > ctx->pbelle_sdpParser_attributeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_attribute_SCOPE)ctx->pbelle_sdpParser_attributeStack->get(ctx->pbelle_sdpParser_attributeStack, ctx->pbelle_sdpParser_attributeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_attribute_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_attribute_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_attributeStack->push(ctx->pbelle_sdpParser_attributeStack, newAttributes, (void (*)(void *))attributeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_attributeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_rtcp_xr_attribute scope set
 */
static pbelle_sdpParser_rtcp_xr_attribute_SCOPE   pbelle_sdpParser_rtcp_xr_attributePush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL rtcp_xr_attributeFree(pbelle_sdpParser_rtcp_xr_attribute_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL rtcp_xr_attributeFree(pbelle_sdpParser_rtcp_xr_attribute_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser rtcp_xr_attribute scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_rtcp_xr_attributeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_rtcp_xr_attribute_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_rtcp_xr_attribute_SCOPE
pbelle_sdpParser_rtcp_xr_attributePush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_rtcp_xr_attribute_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_rtcp_xr_attributeStack->size(ctx->pbelle_sdpParser_rtcp_xr_attributeStack) > ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_rtcp_xr_attribute_SCOPE)ctx->pbelle_sdpParser_rtcp_xr_attributeStack->get(ctx->pbelle_sdpParser_rtcp_xr_attributeStack, ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_rtcp_xr_attribute_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_rtcp_xr_attribute_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_rtcp_xr_attributeStack->push(ctx->pbelle_sdpParser_rtcp_xr_attributeStack, newAttributes, (void (*)(void *))rtcp_xr_attributeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_rtcp_fb_attribute scope set
 */
static pbelle_sdpParser_rtcp_fb_attribute_SCOPE   pbelle_sdpParser_rtcp_fb_attributePush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL rtcp_fb_attributeFree(pbelle_sdpParser_rtcp_fb_attribute_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL rtcp_fb_attributeFree(pbelle_sdpParser_rtcp_fb_attribute_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser rtcp_fb_attribute scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_rtcp_fb_attributeTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_rtcp_fb_attribute_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_rtcp_fb_attribute_SCOPE
pbelle_sdpParser_rtcp_fb_attributePush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_rtcp_fb_attribute_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_rtcp_fb_attributeStack->size(ctx->pbelle_sdpParser_rtcp_fb_attributeStack) > ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_rtcp_fb_attribute_SCOPE)ctx->pbelle_sdpParser_rtcp_fb_attributeStack->get(ctx->pbelle_sdpParser_rtcp_fb_attributeStack, ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_rtcp_fb_attribute_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_rtcp_fb_attribute_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_rtcp_fb_attributeStack->push(ctx->pbelle_sdpParser_rtcp_fb_attributeStack, newAttributes, (void (*)(void *))rtcp_fb_attributeFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_media_description scope set
 */
static pbelle_sdpParser_media_description_SCOPE   pbelle_sdpParser_media_descriptionPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL media_descriptionFree(pbelle_sdpParser_media_description_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL media_descriptionFree(pbelle_sdpParser_media_description_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser media_description scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_media_descriptionTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_media_description_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_media_description_SCOPE
pbelle_sdpParser_media_descriptionPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_media_description_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_media_descriptionStack->size(ctx->pbelle_sdpParser_media_descriptionStack) > ctx->pbelle_sdpParser_media_descriptionStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_media_description_SCOPE)ctx->pbelle_sdpParser_media_descriptionStack->get(ctx->pbelle_sdpParser_media_descriptionStack, ctx->pbelle_sdpParser_media_descriptionStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_media_description_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_media_description_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_media_descriptionStack->push(ctx->pbelle_sdpParser_media_descriptionStack, newAttributes, (void (*)(void *))media_descriptionFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_media_descriptionStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_media scope set
 */
static pbelle_sdpParser_media_SCOPE   pbelle_sdpParser_mediaPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL mediaFree(pbelle_sdpParser_media_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL mediaFree(pbelle_sdpParser_media_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser media scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_mediaTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_media_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_media_SCOPE
pbelle_sdpParser_mediaPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_media_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_mediaStack->size(ctx->pbelle_sdpParser_mediaStack) > ctx->pbelle_sdpParser_mediaStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_media_SCOPE)ctx->pbelle_sdpParser_mediaStack->get(ctx->pbelle_sdpParser_mediaStack, ctx->pbelle_sdpParser_mediaStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_media_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_media_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_mediaStack->push(ctx->pbelle_sdpParser_mediaStack, newAttributes, (void (*)(void *))mediaFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_mediaStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}




/* ruleAttributeScopeFuncDecl(scope)
 */
/* -----------------------------------------------------------------------------
 * Function declarations for creating a belle_sdpParser_fmt scope set
 */
static pbelle_sdpParser_fmt_SCOPE   pbelle_sdpParser_fmtPush(pbelle_sdpParser ctx);
static void ANTLR3_CDECL fmtFree(pbelle_sdpParser_fmt_SCOPE scope);
/* ----------------------------------------------------------------------------- */


/* ruleAttributeScopeFuncs(scope)
 */
/* attributeFuncs(scope)
 */

static void ANTLR3_CDECL fmtFree(pbelle_sdpParser_fmt_SCOPE scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Allocate initial memory for a belle_sdpParser fmt scope variable stack entry and
 *         add it to the top of the stack.
 *
 * \remark
 * By default the structure is freed with ANTLR_FREE(), but you can use the
 * the \@init action to install a pointer to a custom free() routine by
 * adding the code:
 * \code
 *   ctx->pbelle_sdpParser_fmtTop->free = myroutine;
 * \endcode
 *
 * With lots of comments of course! The routine should be declared in
 * \@members { } as:
 * \code
 *   void ANTLR3_CDECL myfunc( pbelle_sdpParser_fmt_SCOPE ptr).
 * \endcode
 *
 * It should perform any custom freeing stuff that you need (call ANTLR_FREE3, not free()
 * NB: It should not free the pointer it is given, which is the scope stack entry itself
 * and will be freed by the function that calls your custom free routine.
 *
 */
static pbelle_sdpParser_fmt_SCOPE
pbelle_sdpParser_fmtPush(pbelle_sdpParser ctx)
{
    /* Pointer used to create a new set of attributes
     */
    pbelle_sdpParser_fmt_SCOPE      newAttributes;

    /* Allocate the memory for a new structure if we need one.
     */
    if (ctx->pbelle_sdpParser_fmtStack->size(ctx->pbelle_sdpParser_fmtStack) > ctx->pbelle_sdpParser_fmtStack_limit)
    {
        // The current limit value was less than the number of scopes available on the stack so
        // we can just reuse one. Our limit tracks the stack count, so the index of the entry we want
        // is one less than that, or conveniently, the current value of limit.
        //
        newAttributes = (pbelle_sdpParser_fmt_SCOPE)ctx->pbelle_sdpParser_fmtStack->get(ctx->pbelle_sdpParser_fmtStack, ctx->pbelle_sdpParser_fmtStack_limit);
    }
    else
    {
        // Need a new allocation
        //
        newAttributes = (pbelle_sdpParser_fmt_SCOPE) ANTLR3_MALLOC(sizeof(belle_sdpParser_fmt_SCOPE));
        if  (newAttributes != NULL)
        {
            /* Standard ANTLR3 library implementation
             */
            ctx->pbelle_sdpParser_fmtStack->push(ctx->pbelle_sdpParser_fmtStack, newAttributes, (void (*)(void *))fmtFree);
        }
    }

    // Blank out any previous free pointer, the user might or might install a new one.
    //
    newAttributes->free = NULL;

    // Indicate the position in the available stack that the current level is at
    //
    ctx->pbelle_sdpParser_fmtStack_limit++;

	/* Return value is the pointer to the new entry, which may be used locally
	 * without de-referencing via the context.
     */
    return  newAttributes;
}







/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */


/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   belle_sdpParserTokenNames[25+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>",
        (pANTLR3_UINT8) "<UP>",
        (pANTLR3_UINT8) "COLON",
        (pANTLR3_UINT8) "COMMA",
        (pANTLR3_UINT8) "COMMON_CHAR",
        (pANTLR3_UINT8) "CR",
        (pANTLR3_UINT8) "DASH",
        (pANTLR3_UINT8) "DIGIT",
        (pANTLR3_UINT8) "DOT",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "HEX_CHAR",
        (pANTLR3_UINT8) "LF",
        (pANTLR3_UINT8) "LQUOTE",
        (pANTLR3_UINT8) "OCTET",
        (pANTLR3_UINT8) "POS_DIGIT",
        (pANTLR3_UINT8) "RQUOTE",
        (pANTLR3_UINT8) "SLASH",
        (pANTLR3_UINT8) "SPACE",
        (pANTLR3_UINT8) "STAR",
        (pANTLR3_UINT8) "ZERO",
        (pANTLR3_UINT8) "'!'",
        (pANTLR3_UINT8) "'#'",
        (pANTLR3_UINT8) "'$'",
        (pANTLR3_UINT8) "'%'",
        (pANTLR3_UINT8) "'&'",
        (pANTLR3_UINT8) "'+'",
        (pANTLR3_UINT8) "'\\''"
       };


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_session_descriptionStack
 */
void
pbelle_sdpParser_session_descriptionPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(session_description)->free != NULL)
	{
        SCOPE_TOP(session_description)->free(SCOPE_TOP(session_description));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_session_descriptionStack_limit--;
    SCOPE_TOP(session_description) = (pbelle_sdpParser_session_description_SCOPE)(ctx->pbelle_sdpParser_session_descriptionStack->get(ctx->pbelle_sdpParser_session_descriptionStack, ctx->pbelle_sdpParser_session_descriptionStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_originStack
 */
void
pbelle_sdpParser_originPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(origin)->free != NULL)
	{
        SCOPE_TOP(origin)->free(SCOPE_TOP(origin));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_originStack_limit--;
    SCOPE_TOP(origin) = (pbelle_sdpParser_origin_SCOPE)(ctx->pbelle_sdpParser_originStack->get(ctx->pbelle_sdpParser_originStack, ctx->pbelle_sdpParser_originStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_infoStack
 */
void
pbelle_sdpParser_infoPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(info)->free != NULL)
	{
        SCOPE_TOP(info)->free(SCOPE_TOP(info));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_infoStack_limit--;
    SCOPE_TOP(info) = (pbelle_sdpParser_info_SCOPE)(ctx->pbelle_sdpParser_infoStack->get(ctx->pbelle_sdpParser_infoStack, ctx->pbelle_sdpParser_infoStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_emailStack
 */
void
pbelle_sdpParser_emailPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(email)->free != NULL)
	{
        SCOPE_TOP(email)->free(SCOPE_TOP(email));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_emailStack_limit--;
    SCOPE_TOP(email) = (pbelle_sdpParser_email_SCOPE)(ctx->pbelle_sdpParser_emailStack->get(ctx->pbelle_sdpParser_emailStack, ctx->pbelle_sdpParser_emailStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_connectionStack
 */
void
pbelle_sdpParser_connectionPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(connection)->free != NULL)
	{
        SCOPE_TOP(connection)->free(SCOPE_TOP(connection));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_connectionStack_limit--;
    SCOPE_TOP(connection) = (pbelle_sdpParser_connection_SCOPE)(ctx->pbelle_sdpParser_connectionStack->get(ctx->pbelle_sdpParser_connectionStack, ctx->pbelle_sdpParser_connectionStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_bandwidthStack
 */
void
pbelle_sdpParser_bandwidthPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(bandwidth)->free != NULL)
	{
        SCOPE_TOP(bandwidth)->free(SCOPE_TOP(bandwidth));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_bandwidthStack_limit--;
    SCOPE_TOP(bandwidth) = (pbelle_sdpParser_bandwidth_SCOPE)(ctx->pbelle_sdpParser_bandwidthStack->get(ctx->pbelle_sdpParser_bandwidthStack, ctx->pbelle_sdpParser_bandwidthStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_attributeStack
 */
void
pbelle_sdpParser_attributePop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(attribute)->free != NULL)
	{
        SCOPE_TOP(attribute)->free(SCOPE_TOP(attribute));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_attributeStack_limit--;
    SCOPE_TOP(attribute) = (pbelle_sdpParser_attribute_SCOPE)(ctx->pbelle_sdpParser_attributeStack->get(ctx->pbelle_sdpParser_attributeStack, ctx->pbelle_sdpParser_attributeStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_rtcp_xr_attributeStack
 */
void
pbelle_sdpParser_rtcp_xr_attributePop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(rtcp_xr_attribute)->free != NULL)
	{
        SCOPE_TOP(rtcp_xr_attribute)->free(SCOPE_TOP(rtcp_xr_attribute));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit--;
    SCOPE_TOP(rtcp_xr_attribute) = (pbelle_sdpParser_rtcp_xr_attribute_SCOPE)(ctx->pbelle_sdpParser_rtcp_xr_attributeStack->get(ctx->pbelle_sdpParser_rtcp_xr_attributeStack, ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_rtcp_fb_attributeStack
 */
void
pbelle_sdpParser_rtcp_fb_attributePop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(rtcp_fb_attribute)->free != NULL)
	{
        SCOPE_TOP(rtcp_fb_attribute)->free(SCOPE_TOP(rtcp_fb_attribute));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit--;
    SCOPE_TOP(rtcp_fb_attribute) = (pbelle_sdpParser_rtcp_fb_attribute_SCOPE)(ctx->pbelle_sdpParser_rtcp_fb_attributeStack->get(ctx->pbelle_sdpParser_rtcp_fb_attributeStack, ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_media_descriptionStack
 */
void
pbelle_sdpParser_media_descriptionPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(media_description)->free != NULL)
	{
        SCOPE_TOP(media_description)->free(SCOPE_TOP(media_description));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_media_descriptionStack_limit--;
    SCOPE_TOP(media_description) = (pbelle_sdpParser_media_description_SCOPE)(ctx->pbelle_sdpParser_media_descriptionStack->get(ctx->pbelle_sdpParser_media_descriptionStack, ctx->pbelle_sdpParser_media_descriptionStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_mediaStack
 */
void
pbelle_sdpParser_mediaPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(media)->free != NULL)
	{
        SCOPE_TOP(media)->free(SCOPE_TOP(media));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_mediaStack_limit--;
    SCOPE_TOP(media) = (pbelle_sdpParser_media_SCOPE)(ctx->pbelle_sdpParser_mediaStack->get(ctx->pbelle_sdpParser_mediaStack, ctx->pbelle_sdpParser_mediaStack_limit - 1));
}


/* ruleAttributeScopeFuncMacro(scope)
 */
/** Function for popping the top value from a pbelle_sdpParser_fmtStack
 */
void
pbelle_sdpParser_fmtPop(pbelle_sdpParser ctx)
{
    // First see if the user defined a function they want to be called when a
    // scope is popped/freed.
    //
	// If the user supplied the scope entries with a free function,then call it first
	//
    if	(SCOPE_TOP(fmt)->free != NULL)
	{
        SCOPE_TOP(fmt)->free(SCOPE_TOP(fmt));
	}

    // Now we decrement the scope's upper limit bound. We do not actually pop the scope as
    // we want to reuse scope entries if we do continuous push and pops. Most scopes don't
    // next too far so we don't want to keep freeing and allocating them
    //
    ctx->pbelle_sdpParser_fmtStack_limit--;
    SCOPE_TOP(fmt) = (pbelle_sdpParser_fmt_SCOPE)(ctx->pbelle_sdpParser_fmtStack->get(ctx->pbelle_sdpParser_fmtStack, ctx->pbelle_sdpParser_fmtStack_limit - 1));
}



// Forward declare the locally static matching functions we have generated.
//
static 
 belle_sdpParser_session_description_return
	session_description    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_version_return
	version    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_origin_return
	origin    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_session_name_return
	session_name    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_info_return
	info    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_info_value_return
	info_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_uri_field_return
	uri_field    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_email_return
	email    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_phone_field_return
	phone_field    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_connection_return
	connection    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_bandwidth_return
	bandwidth    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_time_field_return
	time_field    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_repeat_time_return
	repeat_time    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_zone_adjustments_return
	zone_adjustments    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_key_field_return
	key_field    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_key_value_return
	key_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_attribute_return
	attribute    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_attribute_content_return
	attribute_content    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_attribute_return
	rtcp_xr_attribute    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_attribute_value_return
	rtcp_xr_attribute_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_pkt_loss_rle_return
	pkt_loss_rle    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_pkt_dup_rle_return
	pkt_dup_rle    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_pkt_rcpt_times_return
	pkt_rcpt_times    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rcvr_rtt_return
	rcvr_rtt    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_stat_summary_return
	stat_summary    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_voip_metrics_return
	voip_metrics    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_stat_summary_flag_return
	rtcp_xr_stat_summary_flag    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_max_size_return
	rtcp_xr_max_size    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_attribute_return
	rtcp_fb_attribute    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_pt_return
	rtcp_fb_pt    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_val_return
	rtcp_fb_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_ack_val_return
	rtcp_fb_ack_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_nack_val_return
	rtcp_fb_nack_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_trr_int_val_return
	rtcp_fb_trr_int_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_ccm_val_return
	rtcp_fb_ccm_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_id_val_return
	rtcp_fb_id_val    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_param_return
	rtcp_fb_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_ack_param_return
	rtcp_fb_ack_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_nack_param_return
	rtcp_fb_nack_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_pli_param_return
	rtcp_fb_pli_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_sli_param_return
	rtcp_fb_sli_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_rpsi_param_return
	rtcp_fb_rpsi_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_app_param_return
	rtcp_fb_app_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_ccm_param_return
	rtcp_fb_ccm_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_fir_param_return
	rtcp_fb_fir_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_token_param_return
	rtcp_fb_token_param    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_media_description_return
	media_description    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_media_return
	media    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_media_value_return
	media_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_fmt_return
	fmt    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_proto_return
	proto    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_port_return
	port    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_attribute_name_return
	attribute_name    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_attribute_value_return
	attribute_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_attribute_name_return
	rtcp_xr_attribute_name    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_rcvr_rtt_mode_return
	rtcp_xr_rcvr_rtt_mode    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_xr_stat_summary_flag_value_return
	rtcp_xr_stat_summary_flag_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_rtcp_fb_attribute_name_return
	rtcp_fb_attribute_name    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_sess_id_return
	sess_id    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_sess_version_return
	sess_version    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_connection_address_return
	connection_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_multicast_address_return
	multicast_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_ttl_return
	ttl    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_start_time_return
	start_time    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_stop_time_return
	stop_time    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_sdp_time_return
	sdp_time    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_repeat_interval_return
	repeat_interval    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_typed_time_return
	typed_time    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_fixed_len_time_unit_return
	fixed_len_time_unit    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_bwtype_return
	bwtype    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_bandwidth_value_return
	bandwidth_value    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_username_return
	username    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_email_address_return
	email_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_uri_return
	uri    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_phone_number_return
	phone_number    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_phone_return
	phone    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_nettype_return
	nettype    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_addrtype_return
	addrtype    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_addr_return
	addr    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_fqdn_return
	fqdn    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_domainlabel_return
	domainlabel    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_toplabel_return
	toplabel    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_unicast_address_return
	unicast_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_ipv4_address_return
	ipv4_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_ipv6_address_return
	ipv6_address    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_hexpart_return
	hexpart    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_hexseq_return
	hexseq    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_hex4_return
	hex4    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_text_return
	text    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_byte_string_return
	byte_string    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_decimal_uchar_return
	decimal_uchar    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_integer_return
	integer    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_email_safe_return
	email_safe    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_token_return
	token    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_alpha_num_return
	alpha_num    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_hexdigit_return
	hexdigit    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_word_return
	word    (pbelle_sdpParser ctx);
static 
 belle_sdpParser_alpha_return
	alpha    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred1_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred2_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred3_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred4_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred5_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred6_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred7_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred8_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred9_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred10_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred11_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred12_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred13_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred14_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred15_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred16_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred17_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred18_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred19_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred20_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred21_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred22_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred23_belle_sdp    (pbelle_sdpParser ctx);
static 
 ANTLR3_BOOLEAN
	synpred24_belle_sdp    (pbelle_sdpParser ctx);
static void	belle_sdpParserFree(pbelle_sdpParser ctx);
static void     belle_sdpParserReset (pbelle_sdpParser ctx);

/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed.
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "belle_sdp.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new belle_sdpParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sdpParser
belle_sdpParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return belle_sdpParserNewSSD(instream, NULL);
}

/** \brief Create a new belle_sdpParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pbelle_sdpParser
belle_sdpParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pbelle_sdpParser ctx;	    /* Context structure we will build and return   */

    ctx	= (pbelle_sdpParser) ANTLR3_CALLOC(1, sizeof(belle_sdpParser));

    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }

    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function.
     *
     * We don't use the macros defined in belle_sdpParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our belle_sdpParser interface
     */
    ctx->session_description	= session_description;
    ctx->version	= version;
    ctx->origin	= origin;
    ctx->session_name	= session_name;
    ctx->info	= info;
    ctx->info_value	= info_value;
    ctx->uri_field	= uri_field;
    ctx->email	= email;
    ctx->phone_field	= phone_field;
    ctx->connection	= connection;
    ctx->bandwidth	= bandwidth;
    ctx->time_field	= time_field;
    ctx->repeat_time	= repeat_time;
    ctx->zone_adjustments	= zone_adjustments;
    ctx->key_field	= key_field;
    ctx->key_value	= key_value;
    ctx->attribute	= attribute;
    ctx->attribute_content	= attribute_content;
    ctx->rtcp_xr_attribute	= rtcp_xr_attribute;
    ctx->rtcp_xr_attribute_value	= rtcp_xr_attribute_value;
    ctx->pkt_loss_rle	= pkt_loss_rle;
    ctx->pkt_dup_rle	= pkt_dup_rle;
    ctx->pkt_rcpt_times	= pkt_rcpt_times;
    ctx->rcvr_rtt	= rcvr_rtt;
    ctx->stat_summary	= stat_summary;
    ctx->voip_metrics	= voip_metrics;
    ctx->rtcp_xr_stat_summary_flag	= rtcp_xr_stat_summary_flag;
    ctx->rtcp_xr_max_size	= rtcp_xr_max_size;
    ctx->rtcp_fb_attribute	= rtcp_fb_attribute;
    ctx->rtcp_fb_pt	= rtcp_fb_pt;
    ctx->rtcp_fb_val	= rtcp_fb_val;
    ctx->rtcp_fb_ack_val	= rtcp_fb_ack_val;
    ctx->rtcp_fb_nack_val	= rtcp_fb_nack_val;
    ctx->rtcp_fb_trr_int_val	= rtcp_fb_trr_int_val;
    ctx->rtcp_fb_ccm_val	= rtcp_fb_ccm_val;
    ctx->rtcp_fb_id_val	= rtcp_fb_id_val;
    ctx->rtcp_fb_param	= rtcp_fb_param;
    ctx->rtcp_fb_ack_param	= rtcp_fb_ack_param;
    ctx->rtcp_fb_nack_param	= rtcp_fb_nack_param;
    ctx->rtcp_fb_pli_param	= rtcp_fb_pli_param;
    ctx->rtcp_fb_sli_param	= rtcp_fb_sli_param;
    ctx->rtcp_fb_rpsi_param	= rtcp_fb_rpsi_param;
    ctx->rtcp_fb_app_param	= rtcp_fb_app_param;
    ctx->rtcp_fb_ccm_param	= rtcp_fb_ccm_param;
    ctx->rtcp_fb_fir_param	= rtcp_fb_fir_param;
    ctx->rtcp_fb_token_param	= rtcp_fb_token_param;
    ctx->media_description	= media_description;
    ctx->media	= media;
    ctx->media_value	= media_value;
    ctx->fmt	= fmt;
    ctx->proto	= proto;
    ctx->port	= port;
    ctx->attribute_name	= attribute_name;
    ctx->attribute_value	= attribute_value;
    ctx->rtcp_xr_attribute_name	= rtcp_xr_attribute_name;
    ctx->rtcp_xr_rcvr_rtt_mode	= rtcp_xr_rcvr_rtt_mode;
    ctx->rtcp_xr_stat_summary_flag_value	= rtcp_xr_stat_summary_flag_value;
    ctx->rtcp_fb_attribute_name	= rtcp_fb_attribute_name;
    ctx->sess_id	= sess_id;
    ctx->sess_version	= sess_version;
    ctx->connection_address	= connection_address;
    ctx->multicast_address	= multicast_address;
    ctx->ttl	= ttl;
    ctx->start_time	= start_time;
    ctx->stop_time	= stop_time;
    ctx->sdp_time	= sdp_time;
    ctx->repeat_interval	= repeat_interval;
    ctx->typed_time	= typed_time;
    ctx->fixed_len_time_unit	= fixed_len_time_unit;
    ctx->bwtype	= bwtype;
    ctx->bandwidth_value	= bandwidth_value;
    ctx->username	= username;
    ctx->email_address	= email_address;
    ctx->uri	= uri;
    ctx->phone_number	= phone_number;
    ctx->phone	= phone;
    ctx->nettype	= nettype;
    ctx->addrtype	= addrtype;
    ctx->addr	= addr;
    ctx->fqdn	= fqdn;
    ctx->domainlabel	= domainlabel;
    ctx->toplabel	= toplabel;
    ctx->unicast_address	= unicast_address;
    ctx->ipv4_address	= ipv4_address;
    ctx->ipv6_address	= ipv6_address;
    ctx->hexpart	= hexpart;
    ctx->hexseq	= hexseq;
    ctx->hex4	= hex4;
    ctx->text	= text;
    ctx->byte_string	= byte_string;
    ctx->decimal_uchar	= decimal_uchar;
    ctx->integer	= integer;
    ctx->email_safe	= email_safe;
    ctx->token	= token;
    ctx->alpha_num	= alpha_num;
    ctx->hexdigit	= hexdigit;
    ctx->word	= word;
    ctx->alpha	= alpha;
    ctx->synpred1_belle_sdp	= synpred1_belle_sdp;
    ctx->synpred2_belle_sdp	= synpred2_belle_sdp;
    ctx->synpred3_belle_sdp	= synpred3_belle_sdp;
    ctx->synpred4_belle_sdp	= synpred4_belle_sdp;
    ctx->synpred5_belle_sdp	= synpred5_belle_sdp;
    ctx->synpred6_belle_sdp	= synpred6_belle_sdp;
    ctx->synpred7_belle_sdp	= synpred7_belle_sdp;
    ctx->synpred8_belle_sdp	= synpred8_belle_sdp;
    ctx->synpred9_belle_sdp	= synpred9_belle_sdp;
    ctx->synpred10_belle_sdp	= synpred10_belle_sdp;
    ctx->synpred11_belle_sdp	= synpred11_belle_sdp;
    ctx->synpred12_belle_sdp	= synpred12_belle_sdp;
    ctx->synpred13_belle_sdp	= synpred13_belle_sdp;
    ctx->synpred14_belle_sdp	= synpred14_belle_sdp;
    ctx->synpred15_belle_sdp	= synpred15_belle_sdp;
    ctx->synpred16_belle_sdp	= synpred16_belle_sdp;
    ctx->synpred17_belle_sdp	= synpred17_belle_sdp;
    ctx->synpred18_belle_sdp	= synpred18_belle_sdp;
    ctx->synpred19_belle_sdp	= synpred19_belle_sdp;
    ctx->synpred20_belle_sdp	= synpred20_belle_sdp;
    ctx->synpred21_belle_sdp	= synpred21_belle_sdp;
    ctx->synpred22_belle_sdp	= synpred22_belle_sdp;
    ctx->synpred23_belle_sdp	= synpred23_belle_sdp;
    ctx->synpred24_belle_sdp	= synpred24_belle_sdp;
    ctx->free			= belle_sdpParserFree;
    ctx->reset			= belle_sdpParserReset;
    ctx->getGrammarFileName	= getGrammarFileName;

    /* Install the scope pushing methods.
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_session_descriptionPush     = pbelle_sdpParser_session_descriptionPush;
    ctx->pbelle_sdpParser_session_descriptionStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_session_descriptionStack_limit    = 0;
    ctx->pbelle_sdpParser_session_descriptionTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_originPush     = pbelle_sdpParser_originPush;
    ctx->pbelle_sdpParser_originStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_originStack_limit    = 0;
    ctx->pbelle_sdpParser_originTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_infoPush     = pbelle_sdpParser_infoPush;
    ctx->pbelle_sdpParser_infoStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_infoStack_limit    = 0;
    ctx->pbelle_sdpParser_infoTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_emailPush     = pbelle_sdpParser_emailPush;
    ctx->pbelle_sdpParser_emailStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_emailStack_limit    = 0;
    ctx->pbelle_sdpParser_emailTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_connectionPush     = pbelle_sdpParser_connectionPush;
    ctx->pbelle_sdpParser_connectionStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_connectionStack_limit    = 0;
    ctx->pbelle_sdpParser_connectionTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_bandwidthPush     = pbelle_sdpParser_bandwidthPush;
    ctx->pbelle_sdpParser_bandwidthStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_bandwidthStack_limit    = 0;
    ctx->pbelle_sdpParser_bandwidthTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_attributePush     = pbelle_sdpParser_attributePush;
    ctx->pbelle_sdpParser_attributeStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_attributeStack_limit    = 0;
    ctx->pbelle_sdpParser_attributeTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_rtcp_xr_attributePush     = pbelle_sdpParser_rtcp_xr_attributePush;
    ctx->pbelle_sdpParser_rtcp_xr_attributeStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_rtcp_xr_attributeStack_limit    = 0;
    ctx->pbelle_sdpParser_rtcp_xr_attributeTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_rtcp_fb_attributePush     = pbelle_sdpParser_rtcp_fb_attributePush;
    ctx->pbelle_sdpParser_rtcp_fb_attributeStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_rtcp_fb_attributeStack_limit    = 0;
    ctx->pbelle_sdpParser_rtcp_fb_attributeTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_media_descriptionPush     = pbelle_sdpParser_media_descriptionPush;
    ctx->pbelle_sdpParser_media_descriptionStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_media_descriptionStack_limit    = 0;
    ctx->pbelle_sdpParser_media_descriptionTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_mediaPush     = pbelle_sdpParser_mediaPush;
    ctx->pbelle_sdpParser_mediaStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_mediaStack_limit    = 0;
    ctx->pbelle_sdpParser_mediaTop      = NULL;


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_fmtPush     = pbelle_sdpParser_fmtPush;
    ctx->pbelle_sdpParser_fmtStack    = antlr3StackNew(0);
    ctx->pbelle_sdpParser_fmtStack_limit    = 0;
    ctx->pbelle_sdpParser_fmtTop      = NULL;



ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);

ctx->vectors	= antlr3VectorFactoryNew(0);
    /* Install the token table
     */
    PSRSTATE->tokenNames   = belle_sdpParserTokenNames;


    /* Return the newly built parser to the caller
     */
    return  ctx;
}

static void
belle_sdpParserReset (pbelle_sdpParser ctx)
{
    RECOGNIZER->reset(RECOGNIZER);
}

/** Free the parser resources
 */
 static void
 belle_sdpParserFree(pbelle_sdpParser ctx)
 {
    /* Free any scope memory
     */
    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_session_descriptionStack->free(ctx->pbelle_sdpParser_session_descriptionStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_originStack->free(ctx->pbelle_sdpParser_originStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_infoStack->free(ctx->pbelle_sdpParser_infoStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_emailStack->free(ctx->pbelle_sdpParser_emailStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_connectionStack->free(ctx->pbelle_sdpParser_connectionStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_bandwidthStack->free(ctx->pbelle_sdpParser_bandwidthStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_attributeStack->free(ctx->pbelle_sdpParser_attributeStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_rtcp_xr_attributeStack->free(ctx->pbelle_sdpParser_rtcp_xr_attributeStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_rtcp_fb_attributeStack->free(ctx->pbelle_sdpParser_rtcp_fb_attributeStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_media_descriptionStack->free(ctx->pbelle_sdpParser_media_descriptionStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_mediaStack->free(ctx->pbelle_sdpParser_mediaStack);


    /* ruleAttributeScope(scope)
     */
    ctx->pbelle_sdpParser_fmtStack->free(ctx->pbelle_sdpParser_fmtStack);



ctx->vectors->close(ctx->vectors);
/* We created the adaptor so we must free it
 */
ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);


    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }

/** Return token names used by this 
parser

 *
 * The returned pointer is used as an index into the token names table (using the token
 * number as the index).
 *
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames()
{
        return belle_sdpParserTokenNames;
}


/* Declare the bitsets
 */
/** Bitset defining follow set for error recovery in rule state: FOLLOW_version_in_session_description109  */
static	ANTLR3_BITWORD FOLLOW_version_in_session_description109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_version_in_session_description109	= { FOLLOW_version_in_session_description109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description111  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description111_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description111	= { FOLLOW_CR_in_session_description111_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description113  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description113_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description113	= { FOLLOW_LF_in_session_description113_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_origin_in_session_description140  */
static	ANTLR3_BITWORD FOLLOW_origin_in_session_description140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_origin_in_session_description140	= { FOLLOW_origin_in_session_description140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description143  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description143_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description143	= { FOLLOW_CR_in_session_description143_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description145  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description145	= { FOLLOW_LF_in_session_description145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_session_name_in_session_description172  */
static	ANTLR3_BITWORD FOLLOW_session_name_in_session_description172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_session_name_in_session_description172	= { FOLLOW_session_name_in_session_description172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description174  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description174_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description174	= { FOLLOW_CR_in_session_description174_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description176  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description176	= { FOLLOW_LF_in_session_description176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_info_in_session_description204  */
static	ANTLR3_BITWORD FOLLOW_info_in_session_description204_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_info_in_session_description204	= { FOLLOW_info_in_session_description204_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description206  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description206_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description206	= { FOLLOW_CR_in_session_description206_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description208  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description208	= { FOLLOW_LF_in_session_description208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_field_in_session_description238  */
static	ANTLR3_BITWORD FOLLOW_uri_field_in_session_description238_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_field_in_session_description238	= { FOLLOW_uri_field_in_session_description238_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description240  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description240_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description240	= { FOLLOW_CR_in_session_description240_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description242  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description242_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description242	= { FOLLOW_LF_in_session_description242_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_email_in_session_description272  */
static	ANTLR3_BITWORD FOLLOW_email_in_session_description272_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_email_in_session_description272	= { FOLLOW_email_in_session_description272_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description274  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description274	= { FOLLOW_CR_in_session_description274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description276  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description276	= { FOLLOW_LF_in_session_description276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_phone_field_in_session_description305  */
static	ANTLR3_BITWORD FOLLOW_phone_field_in_session_description305_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_phone_field_in_session_description305	= { FOLLOW_phone_field_in_session_description305_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_session_description334  */
static	ANTLR3_BITWORD FOLLOW_connection_in_session_description334_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_session_description334	= { FOLLOW_connection_in_session_description334_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description338  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description338	= { FOLLOW_CR_in_session_description338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description340  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description340	= { FOLLOW_LF_in_session_description340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bandwidth_in_session_description370  */
static	ANTLR3_BITWORD FOLLOW_bandwidth_in_session_description370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_bandwidth_in_session_description370	= { FOLLOW_bandwidth_in_session_description370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description374  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description374_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description374	= { FOLLOW_CR_in_session_description374_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description376  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description376	= { FOLLOW_LF_in_session_description376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_time_field_in_session_description405  */
static	ANTLR3_BITWORD FOLLOW_time_field_in_session_description405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_time_field_in_session_description405	= { FOLLOW_time_field_in_session_description405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description407  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description407_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description407	= { FOLLOW_CR_in_session_description407_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description409  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description409_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description409	= { FOLLOW_LF_in_session_description409_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repeat_time_in_session_description437  */
static	ANTLR3_BITWORD FOLLOW_repeat_time_in_session_description437_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_repeat_time_in_session_description437	= { FOLLOW_repeat_time_in_session_description437_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description439  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description439_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description439	= { FOLLOW_CR_in_session_description439_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description441  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description441_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description441	= { FOLLOW_LF_in_session_description441_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_zone_adjustments_in_session_description471  */
static	ANTLR3_BITWORD FOLLOW_zone_adjustments_in_session_description471_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_zone_adjustments_in_session_description471	= { FOLLOW_zone_adjustments_in_session_description471_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description473  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description473_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description473	= { FOLLOW_CR_in_session_description473_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description475  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description475_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description475	= { FOLLOW_LF_in_session_description475_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_key_field_in_session_description505  */
static	ANTLR3_BITWORD FOLLOW_key_field_in_session_description505_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_key_field_in_session_description505	= { FOLLOW_key_field_in_session_description505_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description507  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description507_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description507	= { FOLLOW_CR_in_session_description507_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description509  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description509_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description509	= { FOLLOW_LF_in_session_description509_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_session_description539  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_session_description539_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_session_description539	= { FOLLOW_attribute_in_session_description539_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_session_description543  */
static	ANTLR3_BITWORD FOLLOW_CR_in_session_description543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_session_description543	= { FOLLOW_CR_in_session_description543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_session_description545  */
static	ANTLR3_BITWORD FOLLOW_LF_in_session_description545_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_session_description545	= { FOLLOW_LF_in_session_description545_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_description_in_session_description575  */
static	ANTLR3_BITWORD FOLLOW_media_description_in_session_description575_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_media_description_in_session_description575	= { FOLLOW_media_description_in_session_description575_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_version602  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_version602_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_version602	= { FOLLOW_alpha_num_in_version602_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_version604  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_version604_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_version604	= { FOLLOW_EQUAL_in_version604_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_version608  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_version608_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_version608	= { FOLLOW_DIGIT_in_version608_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_origin695  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_origin695_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_origin695	= { FOLLOW_alpha_num_in_origin695_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_origin697  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_origin697_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FF7FFF0) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_origin697	= { FOLLOW_EQUAL_in_origin697_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_username_in_origin699  */
static	ANTLR3_BITWORD FOLLOW_username_in_origin699_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_username_in_origin699	= { FOLLOW_username_in_origin699_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_origin729  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_origin729_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_origin729	= { FOLLOW_SPACE_in_origin729_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sess_id_in_origin731  */
static	ANTLR3_BITWORD FOLLOW_sess_id_in_origin731_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sess_id_in_origin731	= { FOLLOW_sess_id_in_origin731_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_origin760  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_origin760_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_origin760	= { FOLLOW_SPACE_in_origin760_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sess_version_in_origin762  */
static	ANTLR3_BITWORD FOLLOW_sess_version_in_origin762_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sess_version_in_origin762	= { FOLLOW_sess_version_in_origin762_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_origin791  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_origin791_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_origin791	= { FOLLOW_SPACE_in_origin791_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nettype_in_origin793  */
static	ANTLR3_BITWORD FOLLOW_nettype_in_origin793_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_nettype_in_origin793	= { FOLLOW_nettype_in_origin793_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_origin823  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_origin823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_origin823	= { FOLLOW_SPACE_in_origin823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addrtype_in_origin825  */
static	ANTLR3_BITWORD FOLLOW_addrtype_in_origin825_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_addrtype_in_origin825	= { FOLLOW_addrtype_in_origin825_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_origin856  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_origin856_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001750) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_origin856	= { FOLLOW_SPACE_in_origin856_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_in_origin858  */
static	ANTLR3_BITWORD FOLLOW_addr_in_origin858_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_in_origin858	= { FOLLOW_addr_in_origin858_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_session_name903  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_session_name903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_session_name903	= { FOLLOW_alpha_num_in_session_name903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_session_name905  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_session_name905_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_session_name905	= { FOLLOW_EQUAL_in_session_name905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_session_name907  */
static	ANTLR3_BITWORD FOLLOW_text_in_session_name907_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_session_name907	= { FOLLOW_text_in_session_name907_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_info939  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_info939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_info939	= { FOLLOW_alpha_num_in_info939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_info941  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_info941_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_info941	= { FOLLOW_EQUAL_in_info941_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_info_value_in_info943  */
static	ANTLR3_BITWORD FOLLOW_info_value_in_info943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_info_value_in_info943	= { FOLLOW_info_value_in_info943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_uri_field1006  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_uri_field1006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_uri_field1006	= { FOLLOW_alpha_num_in_uri_field1006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_uri_field1008  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_uri_field1008_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_uri_field1008	= { FOLLOW_EQUAL_in_uri_field1008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_uri_in_uri_field1010  */
static	ANTLR3_BITWORD FOLLOW_uri_in_uri_field1010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_uri_in_uri_field1010	= { FOLLOW_uri_in_uri_field1010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_email1047  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_email1047_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_email1047	= { FOLLOW_alpha_num_in_email1047_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_email1049  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_email1049_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_email1049	= { FOLLOW_EQUAL_in_email1049_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_email_address_in_email1051  */
static	ANTLR3_BITWORD FOLLOW_email_address_in_email1051_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_email_address_in_email1051	= { FOLLOW_email_address_in_email1051_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_phone_field1068  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_phone_field1068_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_phone_field1068	= { FOLLOW_alpha_num_in_phone_field1068_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_phone_field1070  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_phone_field1070_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_phone_field1070	= { FOLLOW_EQUAL_in_phone_field1070_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_phone_number_in_phone_field1072  */
static	ANTLR3_BITWORD FOLLOW_phone_number_in_phone_field1072_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_phone_number_in_phone_field1072	= { FOLLOW_phone_number_in_phone_field1072_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_phone_field1074  */
static	ANTLR3_BITWORD FOLLOW_CR_in_phone_field1074_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_phone_field1074	= { FOLLOW_CR_in_phone_field1074_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_phone_field1076  */
static	ANTLR3_BITWORD FOLLOW_LF_in_phone_field1076_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_phone_field1076	= { FOLLOW_LF_in_phone_field1076_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_connection1106  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_connection1106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_connection1106	= { FOLLOW_alpha_num_in_connection1106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_connection1108  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_connection1108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_connection1108	= { FOLLOW_EQUAL_in_connection1108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nettype_in_connection1110  */
static	ANTLR3_BITWORD FOLLOW_nettype_in_connection1110_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_nettype_in_connection1110	= { FOLLOW_nettype_in_connection1110_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_connection1133  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_connection1133_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_connection1133	= { FOLLOW_SPACE_in_connection1133_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addrtype_in_connection1135  */
static	ANTLR3_BITWORD FOLLOW_addrtype_in_connection1135_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_addrtype_in_connection1135	= { FOLLOW_addrtype_in_connection1135_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_connection1157  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_connection1157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001750) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_connection1157	= { FOLLOW_SPACE_in_connection1157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_address_in_connection1159  */
static	ANTLR3_BITWORD FOLLOW_connection_address_in_connection1159_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_address_in_connection1159	= { FOLLOW_connection_address_in_connection1159_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_bandwidth1322  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_bandwidth1322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_bandwidth1322	= { FOLLOW_alpha_num_in_bandwidth1322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_bandwidth1324  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_bandwidth1324_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_bandwidth1324	= { FOLLOW_EQUAL_in_bandwidth1324_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bwtype_in_bandwidth1326  */
static	ANTLR3_BITWORD FOLLOW_bwtype_in_bandwidth1326_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_bwtype_in_bandwidth1326	= { FOLLOW_bwtype_in_bandwidth1326_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_bandwidth1337  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_bandwidth1337_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_bandwidth1337	= { FOLLOW_COLON_in_bandwidth1337_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bandwidth_value_in_bandwidth1339  */
static	ANTLR3_BITWORD FOLLOW_bandwidth_value_in_bandwidth1339_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_bandwidth_value_in_bandwidth1339	= { FOLLOW_bandwidth_value_in_bandwidth1339_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_time_field1357  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_time_field1357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_time_field1357	= { FOLLOW_alpha_num_in_time_field1357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_time_field1359  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_time_field1359_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_time_field1359	= { FOLLOW_EQUAL_in_time_field1359_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_start_time_in_time_field1376  */
static	ANTLR3_BITWORD FOLLOW_start_time_in_time_field1376_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_start_time_in_time_field1376	= { FOLLOW_start_time_in_time_field1376_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_time_field1393  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_time_field1393_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_time_field1393	= { FOLLOW_SPACE_in_time_field1393_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stop_time_in_time_field1410  */
static	ANTLR3_BITWORD FOLLOW_stop_time_in_time_field1410_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stop_time_in_time_field1410	= { FOLLOW_stop_time_in_time_field1410_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_repeat_time1426  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_repeat_time1426_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_repeat_time1426	= { FOLLOW_alpha_num_in_repeat_time1426_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_repeat_time1428  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_repeat_time1428_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_repeat_time1428	= { FOLLOW_EQUAL_in_repeat_time1428_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_repeat_interval_in_repeat_time1430  */
static	ANTLR3_BITWORD FOLLOW_repeat_interval_in_repeat_time1430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_repeat_interval_in_repeat_time1430	= { FOLLOW_repeat_interval_in_repeat_time1430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_repeat_time1433  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_repeat_time1433_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000081240) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_repeat_time1433	= { FOLLOW_SPACE_in_repeat_time1433_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typed_time_in_repeat_time1435  */
static	ANTLR3_BITWORD FOLLOW_typed_time_in_repeat_time1435_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_typed_time_in_repeat_time1435	= { FOLLOW_typed_time_in_repeat_time1435_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_zone_adjustments1449  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_zone_adjustments1449_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_zone_adjustments1449	= { FOLLOW_alpha_num_in_zone_adjustments1449_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_zone_adjustments1451  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_zone_adjustments1451_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_zone_adjustments1451	= { FOLLOW_EQUAL_in_zone_adjustments1451_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sdp_time_in_zone_adjustments1453  */
static	ANTLR3_BITWORD FOLLOW_sdp_time_in_zone_adjustments1453_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sdp_time_in_zone_adjustments1453	= { FOLLOW_sdp_time_in_zone_adjustments1453_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_zone_adjustments1455  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_zone_adjustments1455_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000081340) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_zone_adjustments1455	= { FOLLOW_SPACE_in_zone_adjustments1455_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_zone_adjustments1457  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_zone_adjustments1457_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000081240) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_zone_adjustments1457	= { FOLLOW_DASH_in_zone_adjustments1457_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typed_time_in_zone_adjustments1460  */
static	ANTLR3_BITWORD FOLLOW_typed_time_in_zone_adjustments1460_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_typed_time_in_zone_adjustments1460	= { FOLLOW_typed_time_in_zone_adjustments1460_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_zone_adjustments1488  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_zone_adjustments1488_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_zone_adjustments1488	= { FOLLOW_SPACE_in_zone_adjustments1488_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_sdp_time_in_zone_adjustments1490  */
static	ANTLR3_BITWORD FOLLOW_sdp_time_in_zone_adjustments1490_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_sdp_time_in_zone_adjustments1490	= { FOLLOW_sdp_time_in_zone_adjustments1490_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_zone_adjustments1492  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_zone_adjustments1492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000081340) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_zone_adjustments1492	= { FOLLOW_SPACE_in_zone_adjustments1492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_zone_adjustments1494  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_zone_adjustments1494_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000081240) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_zone_adjustments1494	= { FOLLOW_DASH_in_zone_adjustments1494_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typed_time_in_zone_adjustments1497  */
static	ANTLR3_BITWORD FOLLOW_typed_time_in_zone_adjustments1497_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_typed_time_in_zone_adjustments1497	= { FOLLOW_typed_time_in_zone_adjustments1497_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_key_field1517  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_key_field1517_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_key_field1517	= { FOLLOW_alpha_num_in_key_field1517_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_key_field1519  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_key_field1519_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_key_field1519	= { FOLLOW_EQUAL_in_key_field1519_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_key_value_in_key_field1521  */
static	ANTLR3_BITWORD FOLLOW_key_value_in_key_field1521_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_key_value_in_key_field1521	= { FOLLOW_key_value_in_key_field1521_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_attribute1583  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_attribute1583_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_attribute1583	= { FOLLOW_alpha_num_in_attribute1583_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_attribute1585  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_attribute1585_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01740) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_attribute1585	= { FOLLOW_EQUAL_in_attribute1585_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_content_in_attribute1587  */
static	ANTLR3_BITWORD FOLLOW_attribute_content_in_attribute1587_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_content_in_attribute1587	= { FOLLOW_attribute_content_in_attribute1587_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_name_in_attribute_content1611  */
static	ANTLR3_BITWORD FOLLOW_attribute_name_in_attribute_content1611_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_name_in_attribute_content1611	= { FOLLOW_attribute_name_in_attribute_content1611_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_attribute_content1614  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_attribute_content1614_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_attribute_content1614	= { FOLLOW_COLON_in_attribute_content1614_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_value_in_attribute_content1618  */
static	ANTLR3_BITWORD FOLLOW_attribute_value_in_attribute_content1618_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_value_in_attribute_content1618	= { FOLLOW_attribute_value_in_attribute_content1618_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_rtcp_xr_attribute1648  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_rtcp_xr_attribute1648_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_rtcp_xr_attribute1648	= { FOLLOW_alpha_num_in_rtcp_xr_attribute1648_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_rtcp_xr_attribute1650  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_rtcp_xr_attribute1650_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01740) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_rtcp_xr_attribute1650	= { FOLLOW_EQUAL_in_rtcp_xr_attribute1650_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_name_in_rtcp_xr_attribute1654  */
static	ANTLR3_BITWORD FOLLOW_attribute_name_in_rtcp_xr_attribute1654_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_name_in_rtcp_xr_attribute1654	= { FOLLOW_attribute_name_in_rtcp_xr_attribute1654_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_rtcp_xr_attribute1659  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_rtcp_xr_attribute1659_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_rtcp_xr_attribute1659	= { FOLLOW_COLON_in_rtcp_xr_attribute1659_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1661  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1661_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1661	= { FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1661_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_xr_attribute1664  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_xr_attribute1664_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_xr_attribute1664	= { FOLLOW_SPACE_in_rtcp_xr_attribute1664_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1666  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1666_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1666	= { FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1666_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_loss_rle_in_rtcp_xr_attribute_value1689  */
static	ANTLR3_BITWORD FOLLOW_pkt_loss_rle_in_rtcp_xr_attribute_value1689_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_loss_rle_in_rtcp_xr_attribute_value1689	= { FOLLOW_pkt_loss_rle_in_rtcp_xr_attribute_value1689_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_dup_rle_in_rtcp_xr_attribute_value1698  */
static	ANTLR3_BITWORD FOLLOW_pkt_dup_rle_in_rtcp_xr_attribute_value1698_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_dup_rle_in_rtcp_xr_attribute_value1698	= { FOLLOW_pkt_dup_rle_in_rtcp_xr_attribute_value1698_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_rcpt_times_in_rtcp_xr_attribute_value1707  */
static	ANTLR3_BITWORD FOLLOW_pkt_rcpt_times_in_rtcp_xr_attribute_value1707_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_rcpt_times_in_rtcp_xr_attribute_value1707	= { FOLLOW_pkt_rcpt_times_in_rtcp_xr_attribute_value1707_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rcvr_rtt_in_rtcp_xr_attribute_value1716  */
static	ANTLR3_BITWORD FOLLOW_rcvr_rtt_in_rtcp_xr_attribute_value1716_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rcvr_rtt_in_rtcp_xr_attribute_value1716	= { FOLLOW_rcvr_rtt_in_rtcp_xr_attribute_value1716_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stat_summary_in_rtcp_xr_attribute_value1725  */
static	ANTLR3_BITWORD FOLLOW_stat_summary_in_rtcp_xr_attribute_value1725_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stat_summary_in_rtcp_xr_attribute_value1725	= { FOLLOW_stat_summary_in_rtcp_xr_attribute_value1725_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_voip_metrics_in_rtcp_xr_attribute_value1734  */
static	ANTLR3_BITWORD FOLLOW_voip_metrics_in_rtcp_xr_attribute_value1734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_voip_metrics_in_rtcp_xr_attribute_value1734	= { FOLLOW_voip_metrics_in_rtcp_xr_attribute_value1734_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_pkt_loss_rle1745  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_pkt_loss_rle1745_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_pkt_loss_rle1745	= { FOLLOW_rtcp_xr_attribute_name_in_pkt_loss_rle1745_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_pkt_loss_rle1750  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_pkt_loss_rle1750_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_pkt_loss_rle1750	= { FOLLOW_EQUAL_in_pkt_loss_rle1750_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_max_size_in_pkt_loss_rle1752  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_max_size_in_pkt_loss_rle1752_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_max_size_in_pkt_loss_rle1752	= { FOLLOW_rtcp_xr_max_size_in_pkt_loss_rle1752_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_pkt_dup_rle1766  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_pkt_dup_rle1766_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_pkt_dup_rle1766	= { FOLLOW_rtcp_xr_attribute_name_in_pkt_dup_rle1766_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_pkt_dup_rle1771  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_pkt_dup_rle1771_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_pkt_dup_rle1771	= { FOLLOW_EQUAL_in_pkt_dup_rle1771_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_max_size_in_pkt_dup_rle1773  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_max_size_in_pkt_dup_rle1773_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_max_size_in_pkt_dup_rle1773	= { FOLLOW_rtcp_xr_max_size_in_pkt_dup_rle1773_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_pkt_rcpt_times1787  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_pkt_rcpt_times1787_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_pkt_rcpt_times1787	= { FOLLOW_rtcp_xr_attribute_name_in_pkt_rcpt_times1787_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_pkt_rcpt_times1792  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_pkt_rcpt_times1792_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_pkt_rcpt_times1792	= { FOLLOW_EQUAL_in_pkt_rcpt_times1792_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_max_size_in_pkt_rcpt_times1794  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_max_size_in_pkt_rcpt_times1794_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_max_size_in_pkt_rcpt_times1794	= { FOLLOW_rtcp_xr_max_size_in_pkt_rcpt_times1794_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_rcvr_rtt1808  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_rcvr_rtt1808_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_rcvr_rtt1808	= { FOLLOW_rtcp_xr_attribute_name_in_rcvr_rtt1808_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_rcvr_rtt1812  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_rcvr_rtt1812_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_rcvr_rtt1812	= { FOLLOW_EQUAL_in_rcvr_rtt1812_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_rcvr_rtt_mode_in_rcvr_rtt1816  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_rcvr_rtt_mode_in_rcvr_rtt1816_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_rcvr_rtt_mode_in_rcvr_rtt1816	= { FOLLOW_rtcp_xr_rcvr_rtt_mode_in_rcvr_rtt1816_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_rcvr_rtt1819  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_rcvr_rtt1819_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_rcvr_rtt1819	= { FOLLOW_COLON_in_rcvr_rtt1819_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_max_size_in_rcvr_rtt1823  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_max_size_in_rcvr_rtt1823_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_max_size_in_rcvr_rtt1823	= { FOLLOW_rtcp_xr_max_size_in_rcvr_rtt1823_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_stat_summary1838  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_stat_summary1838_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000802) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_stat_summary1838	= { FOLLOW_rtcp_xr_attribute_name_in_stat_summary1838_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_stat_summary1845  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_stat_summary1845_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_stat_summary1845	= { FOLLOW_EQUAL_in_stat_summary1845_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1847  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1847_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1847	= { FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1847_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COMMA_in_stat_summary1850  */
static	ANTLR3_BITWORD FOLLOW_COMMA_in_stat_summary1850_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_COMMA_in_stat_summary1850	= { FOLLOW_COMMA_in_stat_summary1850_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1852  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1852_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000022) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1852	= { FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1852_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_attribute_name_in_voip_metrics1867  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_attribute_name_in_voip_metrics1867_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_attribute_name_in_voip_metrics1867	= { FOLLOW_rtcp_xr_attribute_name_in_voip_metrics1867_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_xr_stat_summary_flag_value_in_rtcp_xr_stat_summary_flag1881  */
static	ANTLR3_BITWORD FOLLOW_rtcp_xr_stat_summary_flag_value_in_rtcp_xr_stat_summary_flag1881_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_xr_stat_summary_flag_value_in_rtcp_xr_stat_summary_flag1881	= { FOLLOW_rtcp_xr_stat_summary_flag_value_in_rtcp_xr_stat_summary_flag1881_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_rtcp_xr_max_size1891  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_rtcp_xr_max_size1891_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_rtcp_xr_max_size1891	= { FOLLOW_DIGIT_in_rtcp_xr_max_size1891_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_rtcp_fb_attribute1914  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_rtcp_fb_attribute1914_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_rtcp_fb_attribute1914	= { FOLLOW_alpha_num_in_rtcp_fb_attribute1914_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_rtcp_fb_attribute1916  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_rtcp_fb_attribute1916_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01740) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_rtcp_fb_attribute1916	= { FOLLOW_EQUAL_in_rtcp_fb_attribute1916_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_name_in_rtcp_fb_attribute1920  */
static	ANTLR3_BITWORD FOLLOW_attribute_name_in_rtcp_fb_attribute1920_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_name_in_rtcp_fb_attribute1920	= { FOLLOW_attribute_name_in_rtcp_fb_attribute1920_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_rtcp_fb_attribute1924  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_rtcp_fb_attribute1924_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_rtcp_fb_attribute1924	= { FOLLOW_COLON_in_rtcp_fb_attribute1924_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_pt_in_rtcp_fb_attribute1926  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_pt_in_rtcp_fb_attribute1926_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_pt_in_rtcp_fb_attribute1926	= { FOLLOW_rtcp_fb_pt_in_rtcp_fb_attribute1926_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_attribute1928  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_attribute1928_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_attribute1928	= { FOLLOW_SPACE_in_rtcp_fb_attribute1928_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_val_in_rtcp_fb_attribute1930  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_val_in_rtcp_fb_attribute1930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_val_in_rtcp_fb_attribute1930	= { FOLLOW_rtcp_fb_val_in_rtcp_fb_attribute1930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_in_rtcp_fb_pt1943  */
static	ANTLR3_BITWORD FOLLOW_STAR_in_rtcp_fb_pt1943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_in_rtcp_fb_pt1943	= { FOLLOW_STAR_in_rtcp_fb_pt1943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rtcp_fb_pt1949  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rtcp_fb_pt1949_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rtcp_fb_pt1949	= { FOLLOW_integer_in_rtcp_fb_pt1949_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ack_val_in_rtcp_fb_val1964  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ack_val_in_rtcp_fb_val1964_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ack_val_in_rtcp_fb_val1964	= { FOLLOW_rtcp_fb_ack_val_in_rtcp_fb_val1964_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_nack_val_in_rtcp_fb_val1972  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_nack_val_in_rtcp_fb_val1972_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_nack_val_in_rtcp_fb_val1972	= { FOLLOW_rtcp_fb_nack_val_in_rtcp_fb_val1972_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_trr_int_val_in_rtcp_fb_val1980  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_trr_int_val_in_rtcp_fb_val1980_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_trr_int_val_in_rtcp_fb_val1980	= { FOLLOW_rtcp_fb_trr_int_val_in_rtcp_fb_val1980_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ccm_val_in_rtcp_fb_val1988  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ccm_val_in_rtcp_fb_val1988_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ccm_val_in_rtcp_fb_val1988	= { FOLLOW_rtcp_fb_ccm_val_in_rtcp_fb_val1988_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_id_val_in_rtcp_fb_val1996  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_id_val_in_rtcp_fb_val1996_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_id_val_in_rtcp_fb_val1996	= { FOLLOW_rtcp_fb_id_val_in_rtcp_fb_val1996_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ack_val2006  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ack_val2006_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ack_val2006	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ack_val2006_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_ack_val2011  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_ack_val2011_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_ack_val2011	= { FOLLOW_SPACE_in_rtcp_fb_ack_val2011_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ack_param_in_rtcp_fb_ack_val2013  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ack_param_in_rtcp_fb_ack_val2013_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ack_param_in_rtcp_fb_ack_val2013	= { FOLLOW_rtcp_fb_ack_param_in_rtcp_fb_ack_val2013_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_nack_val2027  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_nack_val2027_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_nack_val2027	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_nack_val2027_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_nack_val2032  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_nack_val2032_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_nack_val2032	= { FOLLOW_SPACE_in_rtcp_fb_nack_val2032_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_nack_param_in_rtcp_fb_nack_val2034  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_nack_param_in_rtcp_fb_nack_val2034_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_nack_param_in_rtcp_fb_nack_val2034	= { FOLLOW_rtcp_fb_nack_param_in_rtcp_fb_nack_val2034_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_trr_int_val2048  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_trr_int_val2048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_trr_int_val2048	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_trr_int_val2048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_trr_int_val2052  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_trr_int_val2052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_trr_int_val2052	= { FOLLOW_SPACE_in_rtcp_fb_trr_int_val2052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_rtcp_fb_trr_int_val2054  */
static	ANTLR3_BITWORD FOLLOW_integer_in_rtcp_fb_trr_int_val2054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_rtcp_fb_trr_int_val2054	= { FOLLOW_integer_in_rtcp_fb_trr_int_val2054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ccm_val2066  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ccm_val2066_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ccm_val2066	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ccm_val2066_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_ccm_val2071  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_ccm_val2071_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_ccm_val2071	= { FOLLOW_SPACE_in_rtcp_fb_ccm_val2071_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ccm_param_in_rtcp_fb_ccm_val2073  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ccm_param_in_rtcp_fb_ccm_val2073_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ccm_param_in_rtcp_fb_ccm_val2073	= { FOLLOW_rtcp_fb_ccm_param_in_rtcp_fb_ccm_val2073_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_id_val2085  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_id_val2085_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_id_val2085	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_id_val2085_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_id_val2088  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_id_val2088_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001140) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_id_val2088	= { FOLLOW_SPACE_in_rtcp_fb_id_val2088_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_param_in_rtcp_fb_id_val2090  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_param_in_rtcp_fb_id_val2090_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_param_in_rtcp_fb_id_val2090	= { FOLLOW_rtcp_fb_param_in_rtcp_fb_id_val2090_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_rtcp_fb_param2104  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_rtcp_fb_param2104_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_rtcp_fb_param2104	= { FOLLOW_rtcp_fb_app_param_in_rtcp_fb_param2104_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_rtcp_fb_param2112  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_rtcp_fb_param2112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_rtcp_fb_param2112	= { FOLLOW_rtcp_fb_token_param_in_rtcp_fb_param2112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_ack_param2124  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_ack_param2124_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_ack_param2124	= { FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_ack_param2124_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_rtcp_fb_ack_param2132  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_rtcp_fb_ack_param2132_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_rtcp_fb_ack_param2132	= { FOLLOW_rtcp_fb_app_param_in_rtcp_fb_ack_param2132_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ack_param2140  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ack_param2140_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ack_param2140	= { FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ack_param2140_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_pli_param_in_rtcp_fb_nack_param2152  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_pli_param_in_rtcp_fb_nack_param2152_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_pli_param_in_rtcp_fb_nack_param2152	= { FOLLOW_rtcp_fb_pli_param_in_rtcp_fb_nack_param2152_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_sli_param_in_rtcp_fb_nack_param2160  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_sli_param_in_rtcp_fb_nack_param2160_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_sli_param_in_rtcp_fb_nack_param2160	= { FOLLOW_rtcp_fb_sli_param_in_rtcp_fb_nack_param2160_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_nack_param2168  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_nack_param2168_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_nack_param2168	= { FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_nack_param2168_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_rtcp_fb_nack_param2176  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_rtcp_fb_nack_param2176_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_rtcp_fb_nack_param2176	= { FOLLOW_rtcp_fb_app_param_in_rtcp_fb_nack_param2176_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_rtcp_fb_nack_param2184  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_rtcp_fb_nack_param2184_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_rtcp_fb_nack_param2184	= { FOLLOW_rtcp_fb_token_param_in_rtcp_fb_nack_param2184_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_pli_param2194  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_pli_param2194_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_pli_param2194	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_pli_param2194_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_sli_param2208  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_sli_param2208_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_sli_param2208	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_sli_param2208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_rpsi_param2222  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_rpsi_param2222_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_rpsi_param2222	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_rpsi_param2222_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_app_param2236  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_app_param2236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_app_param2236	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_app_param2236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_app_param2241  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_app_param2241_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_app_param2241	= { FOLLOW_SPACE_in_rtcp_fb_app_param2241_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_byte_string_in_rtcp_fb_app_param2243  */
static	ANTLR3_BITWORD FOLLOW_byte_string_in_rtcp_fb_app_param2243_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_byte_string_in_rtcp_fb_app_param2243	= { FOLLOW_byte_string_in_rtcp_fb_app_param2243_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_fir_param_in_rtcp_fb_ccm_param2258  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_fir_param_in_rtcp_fb_ccm_param2258_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_fir_param_in_rtcp_fb_ccm_param2258	= { FOLLOW_rtcp_fb_fir_param_in_rtcp_fb_ccm_param2258_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ccm_param2266  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ccm_param2266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ccm_param2266	= { FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ccm_param2266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_fir_param2276  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_fir_param2276_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_fir_param2276	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_fir_param2276_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_token_param2288  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_token_param2288_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_token_param2288	= { FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_token_param2288_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_rtcp_fb_token_param2291  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_rtcp_fb_token_param2291_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_rtcp_fb_token_param2291	= { FOLLOW_SPACE_in_rtcp_fb_token_param2291_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_byte_string_in_rtcp_fb_token_param2293  */
static	ANTLR3_BITWORD FOLLOW_byte_string_in_rtcp_fb_token_param2293_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_byte_string_in_rtcp_fb_token_param2293	= { FOLLOW_byte_string_in_rtcp_fb_token_param2293_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_in_media_description2336  */
static	ANTLR3_BITWORD FOLLOW_media_in_media_description2336_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_media_in_media_description2336	= { FOLLOW_media_in_media_description2336_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2338  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2338_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2338	= { FOLLOW_CR_in_media_description2338_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2340  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2340_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2340	= { FOLLOW_LF_in_media_description2340_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_info_in_media_description2366  */
static	ANTLR3_BITWORD FOLLOW_info_in_media_description2366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_info_in_media_description2366	= { FOLLOW_info_in_media_description2366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2370  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2370_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2370	= { FOLLOW_CR_in_media_description2370_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2372  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2372_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2372	= { FOLLOW_LF_in_media_description2372_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_connection_in_media_description2398  */
static	ANTLR3_BITWORD FOLLOW_connection_in_media_description2398_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_connection_in_media_description2398	= { FOLLOW_connection_in_media_description2398_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2402  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2402_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2402	= { FOLLOW_CR_in_media_description2402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2404  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2404_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2404	= { FOLLOW_LF_in_media_description2404_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_bandwidth_in_media_description2430  */
static	ANTLR3_BITWORD FOLLOW_bandwidth_in_media_description2430_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_bandwidth_in_media_description2430	= { FOLLOW_bandwidth_in_media_description2430_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2434  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2434_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2434	= { FOLLOW_CR_in_media_description2434_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2436  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2436	= { FOLLOW_LF_in_media_description2436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_key_field_in_media_description2462  */
static	ANTLR3_BITWORD FOLLOW_key_field_in_media_description2462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_key_field_in_media_description2462	= { FOLLOW_key_field_in_media_description2462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2464  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2464_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2464	= { FOLLOW_CR_in_media_description2464_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2466  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2466	= { FOLLOW_LF_in_media_description2466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_attribute_in_media_description2492  */
static	ANTLR3_BITWORD FOLLOW_attribute_in_media_description2492_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000080) };
static  ANTLR3_BITSET_LIST FOLLOW_attribute_in_media_description2492	= { FOLLOW_attribute_in_media_description2492_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_CR_in_media_description2496  */
static	ANTLR3_BITWORD FOLLOW_CR_in_media_description2496_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000002000) };
static  ANTLR3_BITSET_LIST FOLLOW_CR_in_media_description2496	= { FOLLOW_CR_in_media_description2496_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LF_in_media_description2498  */
static	ANTLR3_BITWORD FOLLOW_LF_in_media_description2498_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_LF_in_media_description2498	= { FOLLOW_LF_in_media_description2498_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_media2541  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_media2541_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000800) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_media2541	= { FOLLOW_alpha_num_in_media2541_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EQUAL_in_media2543  */
static	ANTLR3_BITWORD FOLLOW_EQUAL_in_media2543_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_EQUAL_in_media2543	= { FOLLOW_EQUAL_in_media2543_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_media_value_in_media2556  */
static	ANTLR3_BITWORD FOLLOW_media_value_in_media2556_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_media_value_in_media2556	= { FOLLOW_media_value_in_media2556_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_media2571  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_media2571_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_media2571	= { FOLLOW_SPACE_in_media2571_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_port_in_media2573  */
static	ANTLR3_BITWORD FOLLOW_port_in_media2573_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000C0000) };
static  ANTLR3_BITSET_LIST FOLLOW_port_in_media2573	= { FOLLOW_port_in_media2573_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_media2589  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_media2589_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_media2589	= { FOLLOW_SLASH_in_media2589_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_media2591  */
static	ANTLR3_BITWORD FOLLOW_integer_in_media2591_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_media2591	= { FOLLOW_integer_in_media2591_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_media2607  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_media2607_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FFFDF70) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_media2607	= { FOLLOW_SPACE_in_media2607_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_proto_in_media2609  */
static	ANTLR3_BITWORD FOLLOW_proto_in_media2609_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080000) };
static  ANTLR3_BITSET_LIST FOLLOW_proto_in_media2609	= { FOLLOW_proto_in_media2609_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SPACE_in_media2624  */
static	ANTLR3_BITWORD FOLLOW_SPACE_in_media2624_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01740) };
static  ANTLR3_BITSET_LIST FOLLOW_SPACE_in_media2624	= { FOLLOW_SPACE_in_media2624_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fmt_in_media2626  */
static	ANTLR3_BITWORD FOLLOW_fmt_in_media2626_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000080002) };
static  ANTLR3_BITSET_LIST FOLLOW_fmt_in_media2626	= { FOLLOW_fmt_in_media2626_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_media_value2655  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_media_value2655_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_media_value2655	= { FOLLOW_alpha_num_in_media_value2655_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_fmt2739  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_fmt2739_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_fmt2739	= { FOLLOW_DIGIT_in_fmt2739_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_fmt2746  */
static	ANTLR3_BITWORD FOLLOW_token_in_fmt2746_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_fmt2746	= { FOLLOW_token_in_fmt2746_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_port2958  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_port2958_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_port2958	= { FOLLOW_DIGIT_in_port2958_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_token_in_attribute_name3010  */
static	ANTLR3_BITWORD FOLLOW_token_in_attribute_name3010_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_token_in_attribute_name3010	= { FOLLOW_token_in_attribute_name3010_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_rtcp_xr_attribute_name3041  */
static	ANTLR3_BITWORD FOLLOW_word_in_rtcp_xr_attribute_name3041_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_rtcp_xr_attribute_name3041	= { FOLLOW_word_in_rtcp_xr_attribute_name3041_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_rtcp_xr_rcvr_rtt_mode3048  */
static	ANTLR3_BITWORD FOLLOW_word_in_rtcp_xr_rcvr_rtt_mode3048_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_rtcp_xr_rcvr_rtt_mode3048	= { FOLLOW_word_in_rtcp_xr_rcvr_rtt_mode3048_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_rtcp_xr_stat_summary_flag_value3055  */
static	ANTLR3_BITWORD FOLLOW_word_in_rtcp_xr_stat_summary_flag_value3055_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_rtcp_xr_stat_summary_flag_value3055	= { FOLLOW_word_in_rtcp_xr_stat_summary_flag_value3055_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_word_in_rtcp_fb_attribute_name3062  */
static	ANTLR3_BITWORD FOLLOW_word_in_rtcp_fb_attribute_name3062_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_word_in_rtcp_fb_attribute_name3062	= { FOLLOW_word_in_rtcp_fb_attribute_name3062_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sess_id3081  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sess_id3081_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sess_id3081	= { FOLLOW_DIGIT_in_sess_id3081_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sess_version3121  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sess_version3121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sess_version3121	= { FOLLOW_DIGIT_in_sess_version3121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_addr_in_connection_address3177  */
static	ANTLR3_BITWORD FOLLOW_addr_in_connection_address3177_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_addr_in_connection_address3177	= { FOLLOW_addr_in_connection_address3177_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unicast_address_in_multicast_address3186  */
static	ANTLR3_BITWORD FOLLOW_unicast_address_in_multicast_address3186_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000040000) };
static  ANTLR3_BITSET_LIST FOLLOW_unicast_address_in_multicast_address3186	= { FOLLOW_unicast_address_in_multicast_address3186_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SLASH_in_multicast_address3188  */
static	ANTLR3_BITWORD FOLLOW_SLASH_in_multicast_address3188_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_SLASH_in_multicast_address3188	= { FOLLOW_SLASH_in_multicast_address3188_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ttl_in_multicast_address3190  */
static	ANTLR3_BITWORD FOLLOW_ttl_in_multicast_address3190_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ttl_in_multicast_address3190	= { FOLLOW_ttl_in_multicast_address3190_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_decimal_uchar_in_ttl3292  */
static	ANTLR3_BITWORD FOLLOW_decimal_uchar_in_ttl3292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_decimal_uchar_in_ttl3292	= { FOLLOW_decimal_uchar_in_ttl3292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_start_time3309  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_start_time3309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_start_time3309	= { FOLLOW_DIGIT_in_start_time3309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_stop_time3329  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_stop_time3329_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_stop_time3329	= { FOLLOW_DIGIT_in_stop_time3329_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_sdp_time3355  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_sdp_time3355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_sdp_time3355	= { FOLLOW_DIGIT_in_sdp_time3355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_typed_time_in_repeat_interval3389  */
static	ANTLR3_BITWORD FOLLOW_typed_time_in_repeat_interval3389_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_typed_time_in_repeat_interval3389	= { FOLLOW_typed_time_in_repeat_interval3389_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_typed_time3405  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_typed_time3405_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_typed_time3405	= { FOLLOW_DIGIT_in_typed_time3405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_fixed_len_time_unit_in_typed_time3408  */
static	ANTLR3_BITWORD FOLLOW_fixed_len_time_unit_in_typed_time3408_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_fixed_len_time_unit_in_typed_time3408	= { FOLLOW_fixed_len_time_unit_in_typed_time3408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_fixed_len_time_unit3418  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_fixed_len_time_unit3418_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_fixed_len_time_unit3418	= { FOLLOW_alpha_num_in_fixed_len_time_unit3418_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_fixed_len_time_unit3446  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_fixed_len_time_unit3446_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_fixed_len_time_unit3446	= { FOLLOW_alpha_num_in_fixed_len_time_unit3446_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_fixed_len_time_unit3474  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_fixed_len_time_unit3474_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_fixed_len_time_unit3474	= { FOLLOW_alpha_num_in_fixed_len_time_unit3474_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_fixed_len_time_unit3502  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_fixed_len_time_unit3502_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_fixed_len_time_unit3502	= { FOLLOW_alpha_num_in_fixed_len_time_unit3502_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_bwtype3522  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_bwtype3522_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_bwtype3522	= { FOLLOW_alpha_num_in_bwtype3522_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_bandwidth_value3540  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_bandwidth_value3540_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_bandwidth_value3540	= { FOLLOW_DIGIT_in_bandwidth_value3540_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_email_safe_in_username3559  */
static	ANTLR3_BITWORD FOLLOW_email_safe_in_username3559_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_email_safe_in_username3559	= { FOLLOW_email_safe_in_username3559_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_uri3668  */
static	ANTLR3_BITWORD FOLLOW_text_in_uri3668_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_uri3668	= { FOLLOW_text_in_uri3668_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_phone_in_phone_number3691  */
static	ANTLR3_BITWORD FOLLOW_phone_in_phone_number3691_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_phone_in_phone_number3691	= { FOLLOW_phone_in_phone_number3691_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_text_in_phone3713  */
static	ANTLR3_BITWORD FOLLOW_text_in_phone3713_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_text_in_phone3713	= { FOLLOW_text_in_phone3713_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_nettype3784  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_nettype3784_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_nettype3784	= { FOLLOW_alpha_num_in_nettype3784_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_addrtype3828  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_addrtype3828_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001242) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_addrtype3828	= { FOLLOW_alpha_num_in_addrtype3828_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_unicast_address_in_addr3880  */
static	ANTLR3_BITWORD FOLLOW_unicast_address_in_addr3880_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_unicast_address_in_addr3880	= { FOLLOW_unicast_address_in_addr3880_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_domainlabel_in_fqdn3903  */
static	ANTLR3_BITWORD FOLLOW_domainlabel_in_fqdn3903_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_domainlabel_in_fqdn3903	= { FOLLOW_domainlabel_in_fqdn3903_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_fqdn3905  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_fqdn3905_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001240) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_fqdn3905	= { FOLLOW_DOT_in_fqdn3905_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_toplabel_in_fqdn3910  */
static	ANTLR3_BITWORD FOLLOW_toplabel_in_fqdn3910_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000402) };
static  ANTLR3_BITSET_LIST FOLLOW_toplabel_in_fqdn3910	= { FOLLOW_toplabel_in_fqdn3910_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_fqdn3912  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_fqdn3912_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_fqdn3912	= { FOLLOW_DOT_in_fqdn3912_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_domainlabel3930  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_domainlabel3930_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_domainlabel3930	= { FOLLOW_alpha_num_in_domainlabel3930_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_domainlabel3935  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_domainlabel3935_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_domainlabel3935	= { FOLLOW_alpha_num_in_domainlabel3935_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_domainlabel3939  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_domainlabel3939_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_domainlabel3939	= { FOLLOW_alpha_num_in_domainlabel3939_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_domainlabel3943  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_domainlabel3943_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_domainlabel3943	= { FOLLOW_DASH_in_domainlabel3943_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_domainlabel3948  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_domainlabel3948_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_domainlabel3948	= { FOLLOW_alpha_num_in_domainlabel3948_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel3966  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel3966_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel3966	= { FOLLOW_alpha_in_toplabel3966_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_toplabel3971  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_toplabel3971_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_toplabel3971	= { FOLLOW_alpha_in_toplabel3971_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_toplabel3975  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_toplabel3975_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_toplabel3975	= { FOLLOW_alpha_num_in_toplabel3975_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_toplabel3979  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_toplabel3979_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001340) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_toplabel3979	= { FOLLOW_DASH_in_toplabel3979_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_toplabel3984  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_toplabel3984_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_toplabel3984	= { FOLLOW_alpha_num_in_toplabel3984_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_unicast_address3997  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_unicast_address3997_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001752) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_unicast_address3997	= { FOLLOW_alpha_num_in_unicast_address3997_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_unicast_address4001  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_unicast_address4001_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001752) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_unicast_address4001	= { FOLLOW_DOT_in_unicast_address4001_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_unicast_address4005  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_unicast_address4005_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001752) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_unicast_address4005	= { FOLLOW_COLON_in_unicast_address4005_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_unicast_address4008  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_unicast_address4008_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001752) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_unicast_address4008	= { FOLLOW_DASH_in_unicast_address4008_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_decimal_uchar_in_ipv4_address4052  */
static	ANTLR3_BITWORD FOLLOW_decimal_uchar_in_ipv4_address4052_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_decimal_uchar_in_ipv4_address4052	= { FOLLOW_decimal_uchar_in_ipv4_address4052_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4_address4054  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4_address4054_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4_address4054	= { FOLLOW_DOT_in_ipv4_address4054_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_decimal_uchar_in_ipv4_address4056  */
static	ANTLR3_BITWORD FOLLOW_decimal_uchar_in_ipv4_address4056_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_decimal_uchar_in_ipv4_address4056	= { FOLLOW_decimal_uchar_in_ipv4_address4056_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4_address4058  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4_address4058_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4_address4058	= { FOLLOW_DOT_in_ipv4_address4058_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_decimal_uchar_in_ipv4_address4060  */
static	ANTLR3_BITWORD FOLLOW_decimal_uchar_in_ipv4_address4060_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000400) };
static  ANTLR3_BITSET_LIST FOLLOW_decimal_uchar_in_ipv4_address4060	= { FOLLOW_decimal_uchar_in_ipv4_address4060_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_ipv4_address4062  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_ipv4_address4062_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_ipv4_address4062	= { FOLLOW_DOT_in_ipv4_address4062_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_decimal_uchar_in_ipv4_address4064  */
static	ANTLR3_BITWORD FOLLOW_decimal_uchar_in_ipv4_address4064_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_decimal_uchar_in_ipv4_address4064	= { FOLLOW_decimal_uchar_in_ipv4_address4064_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexpart_in_ipv6_address4083  */
static	ANTLR3_BITWORD FOLLOW_hexpart_in_ipv6_address4083_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_hexpart_in_ipv6_address4083	= { FOLLOW_hexpart_in_ipv6_address4083_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_ipv6_address4087  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_ipv6_address4087_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_ipv6_address4087	= { FOLLOW_COLON_in_ipv6_address4087_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ipv4_address_in_ipv6_address4089  */
static	ANTLR3_BITWORD FOLLOW_ipv4_address_in_ipv6_address4089_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ipv4_address_in_ipv6_address4089	= { FOLLOW_ipv4_address_in_ipv6_address4089_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart4108  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart4108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart4108	= { FOLLOW_hexseq_in_hexpart4108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart4112  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart4112_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart4112	= { FOLLOW_hexseq_in_hexpart4112_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart4114  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart4114_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart4114	= { FOLLOW_COLON_in_hexpart4114_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart4116  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart4116_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001202) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart4116	= { FOLLOW_COLON_in_hexpart4116_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart4118  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart4118_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart4118	= { FOLLOW_hexseq_in_hexpart4118_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart4123  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart4123_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart4123	= { FOLLOW_COLON_in_hexpart4123_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexpart4125  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexpart4125_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001202) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexpart4125	= { FOLLOW_COLON_in_hexpart4125_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexseq_in_hexpart4127  */
static	ANTLR3_BITWORD FOLLOW_hexseq_in_hexpart4127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_hexseq_in_hexpart4127	= { FOLLOW_hexseq_in_hexpart4127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq4145  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq4145_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq4145	= { FOLLOW_hex4_in_hexseq4145_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_COLON_in_hexseq4149  */
static	ANTLR3_BITWORD FOLLOW_COLON_in_hexseq4149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001200) };
static  ANTLR3_BITSET_LIST FOLLOW_COLON_in_hexseq4149	= { FOLLOW_COLON_in_hexseq4149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hex4_in_hexseq4151  */
static	ANTLR3_BITWORD FOLLOW_hex4_in_hexseq4151_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000012) };
static  ANTLR3_BITSET_LIST FOLLOW_hex4_in_hexseq4151	= { FOLLOW_hex4_in_hexseq4151_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_hexdigit_in_hex44172  */
static	ANTLR3_BITWORD FOLLOW_hexdigit_in_hex44172_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001202) };
static  ANTLR3_BITSET_LIST FOLLOW_hexdigit_in_hex44172	= { FOLLOW_hexdigit_in_hex44172_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OCTET_in_byte_string4300  */
static	ANTLR3_BITWORD FOLLOW_OCTET_in_byte_string4300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008002) };
static  ANTLR3_BITSET_LIST FOLLOW_OCTET_in_byte_string4300	= { FOLLOW_OCTET_in_byte_string4300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_integer_in_decimal_uchar4343  */
static	ANTLR3_BITWORD FOLLOW_integer_in_decimal_uchar4343_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_integer_in_decimal_uchar4343	= { FOLLOW_integer_in_decimal_uchar4343_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_integer4362  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_integer4362_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_integer4362	= { FOLLOW_DIGIT_in_integer4362_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_num_in_token4387  */
static	ANTLR3_BITWORD FOLLOW_alpha_num_in_token4387_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_num_in_token4387	= { FOLLOW_alpha_num_in_token4387_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_22_in_token4391  */
static	ANTLR3_BITWORD FOLLOW_22_in_token4391_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_22_in_token4391	= { FOLLOW_22_in_token4391_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_23_in_token4395  */
static	ANTLR3_BITWORD FOLLOW_23_in_token4395_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_23_in_token4395	= { FOLLOW_23_in_token4395_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_24_in_token4399  */
static	ANTLR3_BITWORD FOLLOW_24_in_token4399_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_24_in_token4399	= { FOLLOW_24_in_token4399_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_26_in_token4402  */
static	ANTLR3_BITWORD FOLLOW_26_in_token4402_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_26_in_token4402	= { FOLLOW_26_in_token4402_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_25_in_token4405  */
static	ANTLR3_BITWORD FOLLOW_25_in_token4405_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_25_in_token4405	= { FOLLOW_25_in_token4405_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_28_in_token4408  */
static	ANTLR3_BITWORD FOLLOW_28_in_token4408_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_28_in_token4408	= { FOLLOW_28_in_token4408_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STAR_in_token4412  */
static	ANTLR3_BITWORD FOLLOW_STAR_in_token4412_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_STAR_in_token4412	= { FOLLOW_STAR_in_token4412_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_27_in_token4415  */
static	ANTLR3_BITWORD FOLLOW_27_in_token4415_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_27_in_token4415	= { FOLLOW_27_in_token4415_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_token4419  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_token4419_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_token4419	= { FOLLOW_DASH_in_token4419_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DOT_in_token4423  */
static	ANTLR3_BITWORD FOLLOW_DOT_in_token4423_bits[]	= { ANTLR3_UINT64_LIT(0x000000001FD01742) };
static  ANTLR3_BITSET_LIST FOLLOW_DOT_in_token4423	= { FOLLOW_DOT_in_token4423_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_alpha_num4436  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_alpha_num4436_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_alpha_num4436	= { FOLLOW_alpha_in_alpha_num4436_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_alpha_num4440  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_alpha_num4440_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_alpha_num4440	= { FOLLOW_DIGIT_in_alpha_num4440_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_alpha_in_word4462  */
static	ANTLR3_BITWORD FOLLOW_alpha_in_word4462_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001142) };
static  ANTLR3_BITSET_LIST FOLLOW_alpha_in_word4462	= { FOLLOW_alpha_in_word4462_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DASH_in_word4466  */
static	ANTLR3_BITWORD FOLLOW_DASH_in_word4466_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000001142) };
static  ANTLR3_BITSET_LIST FOLLOW_DASH_in_word4466	= { FOLLOW_DASH_in_word4466_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_loss_rle_in_synpred1_belle_sdp1685  */
static	ANTLR3_BITWORD FOLLOW_pkt_loss_rle_in_synpred1_belle_sdp1685_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_loss_rle_in_synpred1_belle_sdp1685	= { FOLLOW_pkt_loss_rle_in_synpred1_belle_sdp1685_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_dup_rle_in_synpred2_belle_sdp1694  */
static	ANTLR3_BITWORD FOLLOW_pkt_dup_rle_in_synpred2_belle_sdp1694_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_dup_rle_in_synpred2_belle_sdp1694	= { FOLLOW_pkt_dup_rle_in_synpred2_belle_sdp1694_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_pkt_rcpt_times_in_synpred3_belle_sdp1703  */
static	ANTLR3_BITWORD FOLLOW_pkt_rcpt_times_in_synpred3_belle_sdp1703_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_pkt_rcpt_times_in_synpred3_belle_sdp1703	= { FOLLOW_pkt_rcpt_times_in_synpred3_belle_sdp1703_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rcvr_rtt_in_synpred4_belle_sdp1712  */
static	ANTLR3_BITWORD FOLLOW_rcvr_rtt_in_synpred4_belle_sdp1712_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rcvr_rtt_in_synpred4_belle_sdp1712	= { FOLLOW_rcvr_rtt_in_synpred4_belle_sdp1712_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_stat_summary_in_synpred5_belle_sdp1721  */
static	ANTLR3_BITWORD FOLLOW_stat_summary_in_synpred5_belle_sdp1721_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_stat_summary_in_synpred5_belle_sdp1721	= { FOLLOW_stat_summary_in_synpred5_belle_sdp1721_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_voip_metrics_in_synpred6_belle_sdp1730  */
static	ANTLR3_BITWORD FOLLOW_voip_metrics_in_synpred6_belle_sdp1730_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_voip_metrics_in_synpred6_belle_sdp1730	= { FOLLOW_voip_metrics_in_synpred6_belle_sdp1730_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ack_val_in_synpred7_belle_sdp1961  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ack_val_in_synpred7_belle_sdp1961_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ack_val_in_synpred7_belle_sdp1961	= { FOLLOW_rtcp_fb_ack_val_in_synpred7_belle_sdp1961_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_nack_val_in_synpred8_belle_sdp1969  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_nack_val_in_synpred8_belle_sdp1969_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_nack_val_in_synpred8_belle_sdp1969	= { FOLLOW_rtcp_fb_nack_val_in_synpred8_belle_sdp1969_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_trr_int_val_in_synpred9_belle_sdp1977  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_trr_int_val_in_synpred9_belle_sdp1977_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_trr_int_val_in_synpred9_belle_sdp1977	= { FOLLOW_rtcp_fb_trr_int_val_in_synpred9_belle_sdp1977_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_ccm_val_in_synpred10_belle_sdp1985  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_ccm_val_in_synpred10_belle_sdp1985_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_ccm_val_in_synpred10_belle_sdp1985	= { FOLLOW_rtcp_fb_ccm_val_in_synpred10_belle_sdp1985_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_id_val_in_synpred11_belle_sdp1993  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_id_val_in_synpred11_belle_sdp1993_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_id_val_in_synpred11_belle_sdp1993	= { FOLLOW_rtcp_fb_id_val_in_synpred11_belle_sdp1993_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_synpred12_belle_sdp2101  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_synpred12_belle_sdp2101_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_synpred12_belle_sdp2101	= { FOLLOW_rtcp_fb_app_param_in_synpred12_belle_sdp2101_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_synpred13_belle_sdp2109  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_synpred13_belle_sdp2109_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_synpred13_belle_sdp2109	= { FOLLOW_rtcp_fb_token_param_in_synpred13_belle_sdp2109_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_rpsi_param_in_synpred14_belle_sdp2121  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_rpsi_param_in_synpred14_belle_sdp2121_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_rpsi_param_in_synpred14_belle_sdp2121	= { FOLLOW_rtcp_fb_rpsi_param_in_synpred14_belle_sdp2121_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_synpred15_belle_sdp2129  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_synpred15_belle_sdp2129_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_synpred15_belle_sdp2129	= { FOLLOW_rtcp_fb_app_param_in_synpred15_belle_sdp2129_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_synpred16_belle_sdp2137  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_synpred16_belle_sdp2137_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_synpred16_belle_sdp2137	= { FOLLOW_rtcp_fb_token_param_in_synpred16_belle_sdp2137_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_pli_param_in_synpred17_belle_sdp2149  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_pli_param_in_synpred17_belle_sdp2149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_pli_param_in_synpred17_belle_sdp2149	= { FOLLOW_rtcp_fb_pli_param_in_synpred17_belle_sdp2149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_sli_param_in_synpred18_belle_sdp2157  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_sli_param_in_synpred18_belle_sdp2157_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_sli_param_in_synpred18_belle_sdp2157	= { FOLLOW_rtcp_fb_sli_param_in_synpred18_belle_sdp2157_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_rpsi_param_in_synpred19_belle_sdp2165  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_rpsi_param_in_synpred19_belle_sdp2165_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_rpsi_param_in_synpred19_belle_sdp2165	= { FOLLOW_rtcp_fb_rpsi_param_in_synpred19_belle_sdp2165_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_app_param_in_synpred20_belle_sdp2173  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_app_param_in_synpred20_belle_sdp2173_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_app_param_in_synpred20_belle_sdp2173	= { FOLLOW_rtcp_fb_app_param_in_synpred20_belle_sdp2173_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_synpred21_belle_sdp2181  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_synpred21_belle_sdp2181_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_synpred21_belle_sdp2181	= { FOLLOW_rtcp_fb_token_param_in_synpred21_belle_sdp2181_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_fir_param_in_synpred22_belle_sdp2255  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_fir_param_in_synpred22_belle_sdp2255_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_fir_param_in_synpred22_belle_sdp2255	= { FOLLOW_rtcp_fb_fir_param_in_synpred22_belle_sdp2255_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_rtcp_fb_token_param_in_synpred23_belle_sdp2263  */
static	ANTLR3_BITWORD FOLLOW_rtcp_fb_token_param_in_synpred23_belle_sdp2263_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_rtcp_fb_token_param_in_synpred23_belle_sdp2263	= { FOLLOW_rtcp_fb_token_param_in_synpred23_belle_sdp2263_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DIGIT_in_synpred24_belle_sdp2734  */
static	ANTLR3_BITWORD FOLLOW_DIGIT_in_synpred24_belle_sdp2734_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000202) };
static  ANTLR3_BITSET_LIST FOLLOW_DIGIT_in_synpred24_belle_sdp2734	= { FOLLOW_DIGIT_in_synpred24_belle_sdp2734_bits, 1	};



/* =========================================================================
 * DFA tables for the parser
 */
/** Static dfa state tables for Cyclic dfa:
 *    108:26: ( info CR LF )?
 */
static const ANTLR3_INT32 dfa1_eot[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_eof[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_min[31] =
    {
	6, 11, 11, 4, 4, 13, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, -1, -1, 4, 4, 13, 13, 
	13, 4, 4, 4, 4, 4, 0, 0, 0
    };
static const ANTLR3_INT32 dfa1_max[31] =
    {
	12, 11, 11, 28, 28, 13, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, -1, -1, 
	28, 28, 13, 13, 13, 28, 28, 28, 28, 28, 0, 0, 0
    };
static const ANTLR3_INT32 dfa1_accept[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa1_special[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 0, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa1_T_empty	    NULL

static const ANTLR3_INT32 dfa1_T0[] =
    {
	26, 7, 23, 22, 27, 24, 25, 7, 23, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7, 7, 7
    };

static const ANTLR3_INT32 dfa1_T1[] =
    {
	29
    };

static const ANTLR3_INT32 dfa1_T2[] =
    {
	7, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };

static const ANTLR3_INT32 dfa1_T3[] =
    {
	10, 7, 4, 5, 7, 9, 7, 7, 4, -1, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T4[] =
    {
	28
    };

static const ANTLR3_INT32 dfa1_T5[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa1_T6[] =
    {
	7, 7, 7, 5, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T7[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa1_T8[] =
    {
	7, 7, 7, 20, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T9[] =
    {
	3
    };

static const ANTLR3_INT32 dfa1_T10[] =
    {
	30
    };

static const ANTLR3_INT32 dfa1_T11[] =
    {
	7, 7, 13, 21, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa1_T12[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T13[] =
    {
	7, 7, 7, 5, 7, 7, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };

static const ANTLR3_INT32 dfa1_T14[] =
    {
	7, 7, 13, 5, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T15[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa1_T16[] =
    {
	10, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 12, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa1_T17[] =
    {
	11
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa1_transitions[] =
{
    dfa1_T15, dfa1_T9, dfa1_T9, dfa1_T2, dfa1_T3, dfa1_T17, dfa1_T16, dfa1_T13, 
    dfa1_T12, dfa1_T3, dfa1_T6, dfa1_T7, dfa1_T14, dfa1_T5, dfa1_T5, dfa1_T8, 
    NULL, NULL, dfa1_T11, dfa1_T0, dfa1_T4, dfa1_T1, dfa1_T10, dfa1_T0, 
    dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T0, dfa1_T7, dfa1_T7, dfa1_T7
};

static ANTLR3_INT32 dfa1_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA1_29;

    	    ANTLR3_MARKER index1_29;


    		LA1_29 = LA(1);

    	     
    	        index1_29 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(u)))||((IS_TOKEN(t)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index1_29);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA1_30;

    	    ANTLR3_MARKER index1_30;


    		LA1_30 = LA(1);

    	     
    	        index1_30 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(u)))||((IS_TOKEN(c)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index1_30);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA1_28;

    	    ANTLR3_MARKER index1_28;


    		LA1_28 = LA(1);

    	     
    	        index1_28 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(u)))||((IS_TOKEN(b)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index1_28);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA1_11;

    	    ANTLR3_MARKER index1_11;


    		LA1_11 = LA(1);

    	     
    	        index1_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(u)))||((IS_TOKEN(e)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index1_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"108:26: ( info CR LF )?";
    EXCEPTION->decisionNum  = 1;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 1
 */
static
ANTLR3_CYCLIC_DFA cdfa1
    =	{
	    1,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"108:26: ( info CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa1_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa1_eot,	    /* EOT table			    */
	    dfa1_eof,	    /* EOF table			    */
	    dfa1_min,	    /* Minimum tokens for each state    */
	    dfa1_max,	    /* Maximum tokens for each state    */
	    dfa1_accept,	/* Accept table			    */
	    dfa1_special,	/* Special transition states	    */
	    dfa1_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 1
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    109:26: ( uri_field CR LF )?
 */
static const ANTLR3_INT32 dfa2_eot[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_eof[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_min[31] =
    {
	6, 11, 11, 4, 4, 13, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, -1, -1, 4, 4, 13, 13, 
	13, 4, 4, 4, 4, 4, 0, 0, 0
    };
static const ANTLR3_INT32 dfa2_max[31] =
    {
	12, 11, 11, 28, 28, 13, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, -1, -1, 
	28, 28, 13, 13, 13, 28, 28, 28, 28, 28, 0, 0, 0
    };
static const ANTLR3_INT32 dfa2_accept[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa2_special[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 0, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa2_T_empty	    NULL

static const ANTLR3_INT32 dfa2_T0[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa2_T1[] =
    {
	7, 7, 7, 5, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T2[] =
    {
	11
    };

static const ANTLR3_INT32 dfa2_T3[] =
    {
	26, 7, 23, 22, 27, 24, 25, 7, 23, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7, 7, 7
    };

static const ANTLR3_INT32 dfa2_T4[] =
    {
	7, 7, 7, 20, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T5[] =
    {
	29
    };

static const ANTLR3_INT32 dfa2_T6[] =
    {
	7, 7, 13, 21, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa2_T7[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T8[] =
    {
	28
    };

static const ANTLR3_INT32 dfa2_T9[] =
    {
	7, 7, 7, 5, 7, 7, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };

static const ANTLR3_INT32 dfa2_T10[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa2_T11[] =
    {
	30
    };

static const ANTLR3_INT32 dfa2_T12[] =
    {
	7, 7, 13, 5, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T13[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa2_T14[] =
    {
	10, 7, 4, 5, 7, 9, 7, 7, 4, -1, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T15[] =
    {
	10, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 12, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa2_T16[] =
    {
	3
    };

static const ANTLR3_INT32 dfa2_T17[] =
    {
	7, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa2_transitions[] =
{
    dfa2_T13, dfa2_T16, dfa2_T16, dfa2_T17, dfa2_T14, dfa2_T2, dfa2_T15, 
    dfa2_T9, dfa2_T7, dfa2_T14, dfa2_T1, dfa2_T10, dfa2_T12, dfa2_T0, dfa2_T0, 
    dfa2_T4, NULL, NULL, dfa2_T6, dfa2_T3, dfa2_T8, dfa2_T5, dfa2_T11, dfa2_T3, 
    dfa2_T3, dfa2_T3, dfa2_T3, dfa2_T3, dfa2_T10, dfa2_T10, dfa2_T10
};

static ANTLR3_INT32 dfa2_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA2_29;

    	    ANTLR3_MARKER index2_29;


    		LA2_29 = LA(1);

    	     
    	        index2_29 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(u))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(t)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index2_29);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA2_30;

    	    ANTLR3_MARKER index2_30;


    		LA2_30 = LA(1);

    	     
    	        index2_30 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(u))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(c)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index2_30);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA2_28;

    	    ANTLR3_MARKER index2_28;


    		LA2_28 = LA(1);

    	     
    	        index2_28 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(u))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(b)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index2_28);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA2_11;

    	    ANTLR3_MARKER index2_11;


    		LA2_11 = LA(1);

    	     
    	        index2_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(u))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(e)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index2_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"109:26: ( uri_field CR LF )?";
    EXCEPTION->decisionNum  = 2;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 2
 */
static
ANTLR3_CYCLIC_DFA cdfa2
    =	{
	    2,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"109:26: ( uri_field CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa2_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa2_eot,	    /* EOT table			    */
	    dfa2_eof,	    /* EOF table			    */
	    dfa2_min,	    /* Minimum tokens for each state    */
	    dfa2_max,	    /* Maximum tokens for each state    */
	    dfa2_accept,	/* Accept table			    */
	    dfa2_special,	/* Special transition states	    */
	    dfa2_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 2
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 110:26: ( email CR LF )*
 */
static const ANTLR3_INT32 dfa3_eot[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_eof[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_min[31] =
    {
	6, 11, 11, 4, 4, 13, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, -1, -1, 4, 4, 13, 13, 
	13, 4, 4, 4, 4, 4, 0, 0, 0
    };
static const ANTLR3_INT32 dfa3_max[31] =
    {
	12, 11, 11, 28, 28, 13, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, -1, -1, 
	28, 28, 13, 13, 13, 28, 28, 28, 28, 28, 0, 0, 0
    };
static const ANTLR3_INT32 dfa3_accept[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 2, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa3_special[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 0, 1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa3_T_empty	    NULL

static const ANTLR3_INT32 dfa3_T0[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa3_T1[] =
    {
	7, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };

static const ANTLR3_INT32 dfa3_T2[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa3_T3[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa3_T4[] =
    {
	26, 7, 23, 22, 27, 24, 25, 7, 23, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7, 7, 7
    };

static const ANTLR3_INT32 dfa3_T5[] =
    {
	11
    };

static const ANTLR3_INT32 dfa3_T6[] =
    {
	29
    };

static const ANTLR3_INT32 dfa3_T7[] =
    {
	3
    };

static const ANTLR3_INT32 dfa3_T8[] =
    {
	10, 7, 4, 5, 7, 9, 7, 7, 4, -1, 7, 7, 7, 7, 7, 8, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa3_T9[] =
    {
	7, 7, 7, 5, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa3_T10[] =
    {
	28
    };

static const ANTLR3_INT32 dfa3_T11[] =
    {
	7, 7, 7, 20, 7, 15, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa3_T12[] =
    {
	30
    };

static const ANTLR3_INT32 dfa3_T13[] =
    {
	7, 7, 13, 21, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 19, 7, 7, 7, 7, 7, 7, 
	7, 7, 7
    };

static const ANTLR3_INT32 dfa3_T14[] =
    {
	7, 7, 13, 5, 7, 14, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa3_T15[] =
    {
	7, 7, 7, 5, 7, 7, 7, 7, 7, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7
    };

static const ANTLR3_INT32 dfa3_T16[] =
    {
	7, 7, 13, 5, 7, 18, 7, 7, 13, -1, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa3_T17[] =
    {
	10, 7, 4, 5, 7, 6, 7, 7, 4, -1, 7, 7, 7, 7, 7, 12, 7, 7, 7, 7, 7, 7, 7, 
	7, 7
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa3_transitions[] =
{
    dfa3_T3, dfa3_T7, dfa3_T7, dfa3_T1, dfa3_T8, dfa3_T5, dfa3_T17, dfa3_T15, 
    dfa3_T14, dfa3_T8, dfa3_T9, dfa3_T0, dfa3_T16, dfa3_T2, dfa3_T2, dfa3_T11, 
    NULL, NULL, dfa3_T13, dfa3_T4, dfa3_T10, dfa3_T6, dfa3_T12, dfa3_T4, 
    dfa3_T4, dfa3_T4, dfa3_T4, dfa3_T4, dfa3_T0, dfa3_T0, dfa3_T0
};

static ANTLR3_INT32 dfa3_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA3_29;

    	    ANTLR3_MARKER index3_29;


    		LA3_29 = LA(1);

    	     
    	        index3_29 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(e))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(t)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index3_29);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA3_30;

    	    ANTLR3_MARKER index3_30;


    		LA3_30 = LA(1);

    	     
    	        index3_30 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(e))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(c)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index3_30);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA3_28;

    	    ANTLR3_MARKER index3_28;


    		LA3_28 = LA(1);

    	     
    	        index3_28 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(e))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((((IS_TOKEN(b)))||((IS_TOKEN(p))))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index3_28);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA3_11;

    	    ANTLR3_MARKER index3_11;


    		LA3_11 = LA(1);

    	     
    	        index3_11 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(e))) )
    	    {
    	        s = 16;
    	    }

    	    else if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 17;
    	    }

    		 
    			SEEK(index3_11);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 110:26: ( email CR LF )*";
    EXCEPTION->decisionNum  = 3;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 3
 */
static
ANTLR3_CYCLIC_DFA cdfa3
    =	{
	    3,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 110:26: ( email CR LF )*",
	    (CDFA_SPECIAL_FUNC) dfa3_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa3_eot,	    /* EOT table			    */
	    dfa3_eof,	    /* EOF table			    */
	    dfa3_min,	    /* Minimum tokens for each state    */
	    dfa3_max,	    /* Maximum tokens for each state    */
	    dfa3_accept,	/* Accept table			    */
	    dfa3_special,	/* Special transition states	    */
	    dfa3_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 3
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 111:26: ( phone_field )*
 */
static const ANTLR3_INT32 dfa4_eot[856] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa4_eof[856] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 27, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	27, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, 
	-1, -1, -1, 27, 27, -1, -1, -1, -1, 27, -1, 27, -1, -1, -1, -1, -1, -1, 
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, 27, -1, -1, -1, 
	-1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 27, -1, -1, 27, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 27, -1, -1, -1, -1, 27, 27, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, 27, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, 27, 27, -1, -1, -1, 27, -1, 27, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 27, -1, -1, 27, 27, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 27, 27, -1, -1, -1, 27, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	27, 27, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, -1, -1, -1, 
	27, -1, -1, 27, -1, 27, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 27, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 27, 27
    };
static const ANTLR3_INT32 dfa4_min[856] =
    {
	6, 11, 11, 4, 4, 4, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 13, 4, 4, 4, 4, 
	4, 13, 0, 6, 0, -1, 11, 11, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 6, 4, 4, 13, 4, 4, 6, 4, 4, 
	4, 4, 4, 6, 11, 11, 13, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 13, 13, 4, 4, 4, 
	4, 0, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 6, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 11, 11, 4, 13, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 13, 4, 4, 13, 6, 4, 4, 4, 4, 4, 4, 6, 4, 4, 13, 4, 4, 4, 13, 4, 
	6, 6, 4, 13, 4, 4, 6, 4, 6, 4, 11, 11, 11, 11, 4, 6, 4, 4, 4, 4, 4, 4, 
	4, 4, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 13, 13, 13, 4, 4, 4, 4, 13, 4, 4, 4, 6, 4, 4, 4, 13, 4, 4, 
	4, 13, 4, 4, 4, 4, 4, 4, 6, 0, 6, 4, 4, 4, 4, 4, 4, 13, 6, 4, 4, 4, 4, 
	11, 11, 6, 4, 4, 6, 4, 4, 4, 11, 11, 11, 11, 4, 4, 4, 4, 4, 4, 13, 4, 13, 
	4, 4, 4, 4, 6, 13, 4, 4, 4, 11, 11, 13, 4, 4, 4, 4, 13, 4, 4, 4, 4, 13, 
	4, 6, 4, 13, 4, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 6, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 0, 4, 11, 11, 4, 6, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 
	4, 4, 13, 4, 4, 4, 13, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 
	13, 4, 4, 6, 4, 4, 4, 11, 11, 4, 13, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 6, 
	13, 4, 4, 4, 6, 6, 4, 4, 4, 4, 4, 13, 4, 13, 4, 6, 6, 13, 11, 11, 4, 4, 
	4, 4, 13, 4, 4, 4, 6, 4, 4, 4, 4, 4, 4, 4, 13, 6, 6, 13, 13, 4, 6, 4, 6, 
	4, 6, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 0, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 13, 4, 4, 6, 11, 
	11, 6, 6, 4, 4, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 4, 13, 4, 4, 4, 4, 6, 4, 4, 4, 4, 4, 13, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 4, 6, 4, 4, 4, 11, 11, 13, 4, 4, 4, 
	4, 13, 4, 4, 4, 13, 4, 4, 4, 6, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 6, 4, 4, 11, 11, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 0, 4, 4, 4, 4, 6, 6, 13, 4, 4, 6, 13, 4, 13, 11, 11, 4, 4, 
	4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 6, 6, 6, 4, 13, 4, 
	13, 4, 4, 4, 4, 4, 4, 6, 4, 4, 4, 4, 6, 4, 4, 6, 4, 6, 4, 13, 4, 4, 4, 
	4, 4, 4, 4, 4, 6, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 6, 
	4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 
	4, 4, 4, 6, 6
    };
static const ANTLR3_INT32 dfa4_max[856] =
    {
	12, 11, 11, 28, 28, 28, -1, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 13, 
	28, 28, 28, 28, 28, 13, 0, 12, 0, -1, 11, 11, 28, 28, 28, 28, 28, 13, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 28, 13, 
	28, 28, 28, 12, 28, 28, 13, 28, 28, 12, 28, 28, 28, 28, 28, 12, 11, 11, 
	13, 28, 28, 28, 28, 28, 12, 28, 28, 28, 28, 13, 13, 28, 28, 28, 28, 0, 
	28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 12, 
	12, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 12, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 
	28, 28, 28, 28, 28, 11, 11, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	13, 28, 28, 13, 12, 28, 28, 28, 28, 28, 28, 12, 28, 28, 13, 28, 28, 28, 
	13, 28, 12, 12, 28, 13, 28, 28, 12, 28, 12, 28, 11, 11, 11, 11, 28, 12, 
	28, 28, 28, 28, 28, 28, 28, 28, 11, 11, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 13, 13, 13, 28, 28, 28, 28, 13, 28, 28, 28, 12, 28, 28, 28, 
	13, 28, 28, 28, 13, 28, 28, 28, 28, 28, 28, 12, 0, 12, 28, 28, 28, 28, 
	28, 28, 13, 12, 28, 28, 28, 28, 11, 11, 12, 28, 28, 12, 28, 28, 28, 11, 
	11, 11, 11, 28, 28, 28, 28, 28, 28, 13, 28, 13, 28, 28, 28, 28, 12, 13, 
	28, 28, 28, 11, 11, 13, 28, 28, 28, 28, 13, 28, 28, 28, 28, 13, 28, 12, 
	28, 13, 28, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, 28, 28, 28, 12, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 12, 28, 
	28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 13, 28, 28, 28, 28, 28, 0, 28, 11, 11, 28, 12, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 
	28, 28, 12, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 12, 28, 28, 13, 28, 
	28, 28, 13, 28, 28, 28, 28, 28, 12, 28, 28, 28, 28, 28, 28, 28, 28, 13, 
	28, 13, 28, 28, 12, 28, 28, 28, 11, 11, 28, 13, 28, 28, 28, 28, 28, 28, 
	28, 13, 28, 28, 12, 13, 28, 28, 28, 12, 12, 28, 28, 28, 28, 28, 13, 28, 
	13, 28, 12, 12, 13, 11, 11, 28, 28, 28, 28, 13, 28, 28, 28, 12, 28, 28, 
	28, 28, 28, 28, 28, 13, 12, 12, 13, 13, 28, 12, 28, 12, 28, 12, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 0, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 13, 28, 
	28, 28, 13, 28, 28, 12, 11, 11, 12, 12, 28, 28, 11, 11, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 12, 28, 13, 28, 28, 28, 28, 12, 28, 28, 28, 28, 28, 13, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 0, 28, 12, 28, 28, 28, 11, 11, 
	13, 28, 28, 28, 28, 13, 28, 28, 28, 13, 28, 28, 28, 12, 28, 28, 13, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 12, 28, 28, 
	11, 11, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	0, 28, 28, 28, 28, 12, 12, 13, 28, 28, 12, 13, 28, 13, 11, 11, 28, 28, 
	28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 12, 
	12, 12, 28, 13, 28, 13, 28, 28, 28, 28, 28, 28, 12, 28, 28, 28, 28, 12, 
	28, 28, 12, 28, 12, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 12, 28, 13, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 12, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 13, 28, 28, 28, 12, 12
    };
static const ANTLR3_INT32 dfa4_accept[856] =
    {
	-1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa4_special[856] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 0, -1, 5, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 2, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 9, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 4, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, 7, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 8, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	6, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa4_T_empty	    NULL

static const ANTLR3_INT32 dfa4_T0[] =
    {
	555, 555, 555, 516, 555, 555, 555, 555, 555, -1, 555, 555, 555, 555, 555, 
	555, 555, 555, 555, 555, 555, 555, 555, 555, 555
    };

static const ANTLR3_INT32 dfa4_T1[] =
    {
	45, 45, 164, 35, 139, 192, 140, 45, 164, -1, 45, 45, 45, 45, 45, 45, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T2[] =
    {
	546, -1, -1, 547, -1, -1, 546
    };

static const ANTLR3_INT32 dfa4_T3[] =
    {
	45, 45, 53, 54, 45, 80, 45, 45, 53, -1, 45, 45, 45, 45, 45, 33, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T4[] =
    {
	786, 786, 786, 762, 786, 786, 786, 786, 786, -1, 786, 786, 786, 786, 786, 
	786, 786, 786, 786, 786, 786, 786, 786, 786, 786
    };

static const ANTLR3_INT32 dfa4_T5[] =
    {
	581, 583, 577, 584, 582, 579, 580, 583, 577, -1, 583, 583, 583, 583, 583, 
	578, 583, 583, 583, 583, 583, 583, 583, 583, 583
    };

static const ANTLR3_INT32 dfa4_T6[] =
    {
	468, 468, 468, 467, 468, 678, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T7[] =
    {
	468, 468, 468, 467, 468, 678, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	720, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T8[] =
    {
	845, 468, 843, 837, 846, 842, 844, 468, 843, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T9[] =
    {
	468, 468, 828, 467, 468, 827, 468, 468, 828, -1, 468, 468, 468, 468, 606, 
	834, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T10[] =
    {
	297, -1, -1, 298, -1, -1, 297
    };

static const ANTLR3_INT32 dfa4_T11[] =
    {
	45, 45, 45, 35, 45, 107, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T12[] =
    {
	45, 45, 45, 35, 45, 107, 45, 45, 45, -1, 45, 45, 45, 45, 45, 149, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T13[] =
    {
	103, 45, 101, 93, 104, 111, 102, 45, 101, -1, 45, 45, 45, 45, 45, 33, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T14[] =
    {
	45, 45, 77, 35, 45, 88, 45, 45, 77, -1, 45, 45, 45, 45, 75, 112, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T15[] =
    {
	242, 242, 242, 271, 242, 242, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T16[] =
    {
	211
    };

static const ANTLR3_INT32 dfa4_T17[] =
    {
	845, 468, 852, 850, 846, 853, 844, 468, 852, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T18[] =
    {
	508, 508, 508, 446, 508, 507, 508, 508, 508, -1, 508, 508, 508, 508, 508, 
	508, 508, 508, 508, 508, 508, 508, 508, 508, 508
    };

static const ANTLR3_INT32 dfa4_T19[] =
    {
	683, -1, -1, 684, -1, -1, 683
    };

static const ANTLR3_INT32 dfa4_T20[] =
    {
	687
    };

static const ANTLR3_INT32 dfa4_T21[] =
    {
	103, 45, 144, 141, 104, 145, 102, 45, 144, -1, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T22[] =
    {
	374, 374, 511, 375, 374, 551, 374, 374, 511, -1, 374, 374, 374, 374, 374, 
	550, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T23[] =
    {
	468, 468, 748, 752, 716, 798, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	807, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T24[] =
    {
	348, 350, 345, 344, 349, 360, 347, 350, 345, -1, 350, 350, 350, 350, 350, 
	346, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T25[] =
    {
	255, 255, 304, 256, 255, 334, 255, 255, 304, -1, 255, 255, 255, 255, 255, 
	333, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T26[] =
    {
	6, 6, 6, 16, 6, 13, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T27[] =
    {
	531, 531, 531, 485, 531, 530, 531, 531, 531, -1, 531, 531, 531, 531, 531, 
	531, 531, 531, 531, 531, 531, 531, 531, 531, 531
    };

static const ANTLR3_INT32 dfa4_T28[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa4_T29[] =
    {
	45, 45, 164, 166, 139, 192, 140, 45, 164, -1, 45, 45, 45, 45, 45, 209, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T30[] =
    {
	521, 468, 522, 516, 464, 523, 465, 468, 522, -1, 468, 468, 468, 468, 468, 
	468, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T31[] =
    {
	30
    };

static const ANTLR3_INT32 dfa4_T32[] =
    {
	302
    };

static const ANTLR3_INT32 dfa4_T33[] =
    {
	348, 350, 418, 417, 349, 420, 347, 350, 418, -1, 350, 350, 350, 350, 350, 
	419, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T34[] =
    {
	255, 255, 471, 528, 480, 529, 481, 255, 471, -1, 255, 255, 255, 255, 255, 
	380, 478, 255, 472, 473, 474, 476, 475, 479, 477
    };

static const ANTLR3_INT32 dfa4_T35[] =
    {
	765, 45, 766, 762, 736, 767, 737, 45, 766, -1, 45, 45, 45, 45, 45, 45, 
	734, 45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T36[] =
    {
	6, 6, 11, 6, 6, 12, 6, 6, 11, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T37[] =
    {
	760
    };

static const ANTLR3_INT32 dfa4_T38[] =
    {
	621
    };

static const ANTLR3_INT32 dfa4_T39[] =
    {
	689, 6, 627, 690, 637, 628, 638, 6, 627, -1, 6, 6, 6, 6, 6, 156, 635, 6, 
	629, 630, 631, 633, 632, 636, 634
    };

static const ANTLR3_INT32 dfa4_T40[] =
    {
	255, 255, 304, 335, 255, 305, 255, 255, 304, -1, 255, 255, 255, 255, 331, 
	332, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T41[] =
    {
	668, 670, 699, 701, 669, 702, 667, 670, 699, -1, 670, 670, 670, 670, 670, 
	700, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T42[] =
    {
	840, 670, 838, 837, 841, 847, 839, 670, 838, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T43[] =
    {
	468, 468, 824, 611, 468, 823, 468, 468, 824, -1, 468, 468, 468, 468, 606, 
	832, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T44[] =
    {
	744
    };

static const ANTLR3_INT32 dfa4_T45[] =
    {
	242, 242, 499, 316, 242, 498, 242, 242, 499, -1, 242, 242, 242, 242, 242, 
	315, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T46[] =
    {
	96, 98, 92, 93, 97, 91, 95, 98, 92, -1, 98, 98, 98, 98, 98, 94, 98, 98, 
	98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T47[] =
    {
	484, 374, 768, 485, 403, 769, 404, 374, 768, -1, 374, 374, 374, 374, 374, 
	772, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T48[] =
    {
	544
    };

static const ANTLR3_INT32 dfa4_T49[] =
    {
	45, 45, 60, 73, 45, 59, 45, 45, 60, -1, 45, 45, 45, 45, 75, 74, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T50[] =
    {
	468, 468, 759, 615, 468, 758, 468, 468, 759, -1, 468, 468, 468, 468, 468, 
	614, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T51[] =
    {
	255, 255, 471, 256, 480, 470, 481, 255, 471, -1, 255, 255, 255, 255, 255, 
	255, 478, 255, 472, 473, 474, 476, 475, 479, 477
    };

static const ANTLR3_INT32 dfa4_T52[] =
    {
	527
    };

static const ANTLR3_INT32 dfa4_T53[] =
    {
	294, 294, 294, 263, 294, 293, 294, 294, 294, -1, 294, 294, 294, 294, 294, 
	294, 294, 294, 294, 294, 294, 294, 294, 294, 294
    };

static const ANTLR3_INT32 dfa4_T54[] =
    {
	390, 255, 387, 381, 391, 388, 389, 255, 387, -1, 255, 255, 255, 255, 255, 
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T55[] =
    {
	45, 45, 170, 84, 45, 169, 45, 45, 170, -1, 45, 45, 45, 45, 45, 83, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T56[] =
    {
	482
    };

static const ANTLR3_INT32 dfa4_T57[] =
    {
	6, 6, 11, 17, 6, 14, 6, 6, 11, -1, 6, 6, 6, 6, 6, 15, 6, 6, 6, 6, 6, 6, 
	6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T58[] =
    {
	242, 242, 311, 230, 242, 321, 242, 242, 311, -1, 242, 242, 242, 242, 242, 
	339, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T59[] =
    {
	468, 468, 824, 564, 561, 823, 468, 468, 824, -1, 468, 468, 468, 468, 468, 
	563, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T60[] =
    {
	336
    };

static const ANTLR3_INT32 dfa4_T61[] =
    {
	193, -1, -1, 194, -1, -1, 193
    };

static const ANTLR3_INT32 dfa4_T62[] =
    {
	774
    };

static const ANTLR3_INT32 dfa4_T63[] =
    {
	590
    };

static const ANTLR3_INT32 dfa4_T64[] =
    {
	45, 45, 60, 61, 63, 59, 45, 45, 60, -1, 45, 45, 45, 45, 45, 62, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T65[] =
    {
	761, 45, 763, 762, 736, 764, 737, 45, 763, -1, 45, 45, 45, 45, 45, 69, 
	734, 45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T66[] =
    {
	255, 255, 255, 256, 255, 255, 255, 255, 255, -1, 255, 255, 255, 255, 255, 
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T67[] =
    {
	279, 255, 280, 275, 253, 281, 254, 255, 280, -1, 255, 255, 255, 255, 255, 
	255, 251, 255, 245, 246, 247, 249, 248, 252, 250
    };

static const ANTLR3_INT32 dfa4_T68[] =
    {
	738
    };

static const ANTLR3_INT32 dfa4_T69[] =
    {
	468, 468, 782, 780, 716, 825, 717, 468, 782, -1, 468, 468, 468, 468, 468, 
	781, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T70[] =
    {
	184
    };

static const ANTLR3_INT32 dfa4_T71[] =
    {
	826
    };

static const ANTLR3_INT32 dfa4_T72[] =
    {
	468, 468, 454, 467, 464, 455, 465, 468, 454, -1, 468, 468, 468, 468, 468, 
	466, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T73[] =
    {
	45, 45, 180, 181, 139, 227, 140, 45, 180, -1, 45, 45, 45, 45, 45, 182, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T74[] =
    {
	351
    };

static const ANTLR3_INT32 dfa4_T75[] =
    {
	356, 242, 421, 344, 357, 422, 355, 242, 421, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T76[] =
    {
	9, 6, 4, 6, 6, 8, 6, 6, 4, -1, 6, 6, 6, 6, 6, 7, 6, 6, 6, 6, 6, 6, 6, 6, 
	6
    };

static const ANTLR3_INT32 dfa4_T77[] =
    {
	486, 374, 487, 485, 403, 488, 404, 374, 487, -1, 374, 374, 374, 374, 374, 
	374, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T78[] =
    {
	242, 242, 273, 271, 242, 322, 242, 242, 273, -1, 242, 242, 242, 242, 242, 
	358, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T79[] =
    {
	515, 468, 517, 516, 464, 536, 465, 468, 517, -1, 468, 468, 468, 468, 468, 
	569, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T80[] =
    {
	255, 255, 471, 528, 480, 470, 481, 255, 471, -1, 255, 255, 255, 255, 255, 
	380, 478, 255, 472, 473, 474, 476, 475, 479, 477
    };

static const ANTLR3_INT32 dfa4_T81[] =
    {
	468, 468, 468, 467, 468, 662, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	705, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T82[] =
    {
	656, 6, 657, 654, 601, 658, 602, 6, 657, -1, 6, 6, 6, 6, 6, 6, 599, 6, 
	593, 594, 595, 597, 596, 600, 598
    };

static const ANTLR3_INT32 dfa4_T83[] =
    {
	45, 45, 45, 35, 45, 99, 45, 45, 45, -1, 45, 45, 45, 45, 45, 143, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T84[] =
    {
	468, 468, 748, 752, 716, 751, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	700, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T85[] =
    {
	840, 670, 849, 850, 841, 851, 839, 670, 849, -1, 670, 670, 670, 670, 670, 
	700, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T86[] =
    {
	625, -1, -1, 626, -1, -1, 625
    };

static const ANTLR3_INT32 dfa4_T87[] =
    {
	45, 45, 32, 35, 43, 31, 44, 45, 32, -1, 45, 45, 45, 45, 45, 33, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T88[] =
    {
	45, 45, 164, 166, 139, 165, 140, 45, 164, -1, 45, 45, 45, 45, 45, 142, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T89[] =
    {
	96, 98, 126, 141, 97, 127, 95, 98, 126, -1, 98, 98, 98, 98, 98, 142, 98, 
	98, 98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T90[] =
    {
	90
    };

static const ANTLR3_INT32 dfa4_T91[] =
    {
	242, 242, 430, 504, 439, 573, 440, 242, 430, -1, 242, 242, 242, 242, 242, 
	427, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T92[] =
    {
	374, 374, 511, 375, 374, 512, 374, 374, 511, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T93[] =
    {
	682
    };

static const ANTLR3_INT32 dfa4_T94[] =
    {
	468, 468, 526, 524, 468, 525, 468, 468, 526, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T95[] =
    {
	45, 45, 53, 54, 45, 52, 45, 45, 53, -1, 45, 45, 45, 45, 45, 33, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T96[] =
    {
	531, 531, 531, 485, 531, 531, 531, 531, 531, -1, 531, 531, 531, 531, 531, 
	531, 531, 531, 531, 531, 531, 531, 531, 531, 531
    };

static const ANTLR3_INT32 dfa4_T97[] =
    {
	274, 255, 243, 275, 253, 276, 254, 255, 243, -1, 255, 255, 255, 255, 255, 
	277, 251, 255, 245, 246, 247, 249, 248, 252, 250
    };

static const ANTLR3_INT32 dfa4_T98[] =
    {
	697, 697, 697, 654, 697, 697, 697, 697, 697, -1, 697, 697, 697, 697, 697, 
	697, 697, 697, 697, 697, 697, 697, 697, 697, 697
    };

static const ANTLR3_INT32 dfa4_T99[] =
    {
	71, -1, -1, 72, -1, -1, 71
    };

static const ANTLR3_INT32 dfa4_T100[] =
    {
	242, 242, 229, 230, 239, 228, 240, 242, 229, -1, 242, 242, 242, 242, 242, 
	241, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T101[] =
    {
	468, 468, 707, 750, 716, 706, 717, 468, 707, -1, 468, 468, 468, 468, 468, 
	664, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T102[] =
    {
	761, 45, 763, 762, 736, 764, 737, 45, 763, -1, 45, 45, 45, 45, 45, 49, 
	734, 45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T103[] =
    {
	515, 468, 517, 516, 464, 518, 465, 468, 517, -1, 468, 468, 468, 468, 468, 
	519, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T104[] =
    {
	508, 508, 508, 545, 508, 507, 508, 508, 508, -1, 508, 508, 508, 508, 508, 
	508, 508, 508, 508, 508, 508, 508, 508, 508, 508
    };

static const ANTLR3_INT32 dfa4_T105[] =
    {
	45, 45, 130, 163, 139, 129, 140, 45, 130, -1, 45, 45, 45, 45, 45, 94, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T106[] =
    {
	468, 468, 605, 564, 468, 609, 468, 468, 605, -1, 468, 468, 468, 468, 468, 
	616, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T107[] =
    {
	255, 255, 304, 256, 255, 303, 255, 255, 304, -1, 255, 255, 255, 255, 331, 
	332, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T108[] =
    {
	583, 583, 583, 375, 583, 583, 583, 583, 583, -1, 583, 583, 583, 583, 583, 
	578, 583, 583, 583, 583, 583, 583, 583, 583, 583
    };

static const ANTLR3_INT32 dfa4_T109[] =
    {
	813, 583, 809, 810, 814, 811, 812, 583, 809, -1, 583, 583, 583, 583, 583, 
	578, 583, 583, 583, 583, 583, 583, 583, 583, 583
    };

static const ANTLR3_INT32 dfa4_T110[] =
    {
	468, 468, 748, 780, 716, 751, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	781, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T111[] =
    {
	468, 468, 559, 524, 468, 558, 468, 468, 559, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T112[] =
    {
	491, 255, 405, 489, 415, 490, 416, 255, 405, -1, 255, 255, 255, 255, 255, 
	277, 413, 255, 407, 408, 409, 411, 410, 414, 412
    };

static const ANTLR3_INT32 dfa4_T113[] =
    {
	588, 374, 585, 584, 589, 586, 587, 374, 585, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T114[] =
    {
	242, 242, 444, 291, 242, 443, 242, 242, 444, -1, 242, 242, 242, 242, 242, 
	290, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T115[] =
    {
	374, 374, 641, 694, 650, 695, 651, 374, 641, -1, 374, 374, 374, 374, 374, 
	578, 648, 374, 642, 643, 644, 646, 645, 649, 647
    };

static const ANTLR3_INT32 dfa4_T116[] =
    {
	206, 206, 206, 6, 206, 206, 206, 206, 206, -1, 206, 206, 206, 206, 206, 
	201, 206, 206, 206, 206, 206, 206, 206, 206, 206
    };

static const ANTLR3_INT32 dfa4_T117[] =
    {
	204, 206, 200, 6, 205, 202, 203, 206, 200, -1, 206, 206, 206, 206, 206, 
	201, 206, 206, 206, 206, 206, 206, 206, 206, 206
    };

static const ANTLR3_INT32 dfa4_T118[] =
    {
	45, 45, 164, 181, 139, 165, 140, 45, 164, -1, 45, 45, 45, 45, 45, 182, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T119[] =
    {
	777
    };

static const ANTLR3_INT32 dfa4_T120[] =
    {
	619, -1, -1, 620, -1, -1, 619
    };

static const ANTLR3_INT32 dfa4_T121[] =
    {
	786, 786, 786, 762, 786, 785, 786, 786, 786, -1, 786, 786, 786, 786, 786, 
	786, 786, 786, 786, 786, 786, 786, 786, 786, 786
    };

static const ANTLR3_INT32 dfa4_T122[] =
    {
	152, 6, 113, 153, 123, 154, 124, 6, 113, -1, 6, 6, 6, 6, 6, 155, 121, 6, 
	115, 116, 117, 119, 118, 122, 120
    };

static const ANTLR3_INT32 dfa4_T123[] =
    {
	515, 468, 803, 516, 464, 804, 465, 468, 803, -1, 468, 468, 468, 468, 468, 
	805, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T124[] =
    {
	55, 45, 56, 47, 43, 57, 44, 45, 56, -1, 45, 45, 45, 45, 45, 45, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T125[] =
    {
	653, 6, 591, 654, 601, 592, 602, 6, 591, -1, 6, 6, 6, 6, 6, 156, 599, 6, 
	593, 594, 595, 597, 596, 600, 598
    };

static const ANTLR3_INT32 dfa4_T126[] =
    {
	374, 374, 790, 375, 374, 789, 374, 374, 790, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T127[] =
    {
	6, 6, 215, 258, 224, 259, 225, 6, 215, -1, 6, 6, 6, 6, 6, 201, 222, 6, 
	216, 217, 218, 220, 219, 223, 221
    };

static const ANTLR3_INT32 dfa4_T128[] =
    {
	327
    };

static const ANTLR3_INT32 dfa4_T129[] =
    {
	468, 468, 605, 467, 468, 604, 468, 468, 605, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T130[] =
    {
	242, 242, 503, 291, 501, 502, 440, 242, 503, -1, 242, 242, 242, 242, 242, 
	290, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T131[] =
    {
	6, 6, 6, 6, 6, 175, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T132[] =
    {
	242, 242, 311, 230, 242, 312, 242, 242, 311, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T133[] =
    {
	840, 670, 838, 837, 841, 847, 839, 670, 838, -1, 670, 670, 670, 670, 670, 
	719, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T134[] =
    {
	468, 468, 468, 467, 468, 662, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T135[] =
    {
	328, -1, -1, 329, -1, -1, 328
    };

static const ANTLR3_INT32 dfa4_T136[] =
    {
	533
    };

static const ANTLR3_INT32 dfa4_T137[] =
    {
	242, 242, 503, 541, 439, 502, 440, 242, 503, -1, 242, 242, 242, 242, 242, 
	542, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T138[] =
    {
	242, 242, 538, 316, 501, 686, 440, 242, 538, -1, 242, 242, 242, 242, 242, 
	315, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T139[] =
    {
	45, 45, 45, 35, 45, 99, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T140[] =
    {
	6, 6, 11, 6, 6, 12, 6, 6, 11, -1, 6, 6, 6, 6, 6, 15, 6, 6, 6, 6, 6, 6, 
	6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T141[] =
    {
	96, 98, 92, 93, 97, 91, 95, 98, 92, -1, 98, 98, 98, 98, 98, 125, 98, 98, 
	98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T142[] =
    {
	374, 374, 740, 375, 372, 741, 373, 374, 740, -1, 374, 374, 374, 374, 374, 
	374, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T143[] =
    {
	374, 374, 790, 375, 374, 802, 374, 374, 790, -1, 374, 374, 374, 374, 374, 
	801, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T144[] =
    {
	674, 468, 672, 665, 675, 680, 673, 468, 672, -1, 468, 468, 468, 468, 468, 
	681, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T145[] =
    {
	468, 468, 828, 564, 468, 831, 468, 468, 828, -1, 468, 468, 468, 468, 468, 
	833, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T146[] =
    {
	359
    };

static const ANTLR3_INT32 dfa4_T147[] =
    {
	242, 242, 444, 291, 442, 443, 242, 242, 444, -1, 242, 242, 242, 242, 242, 
	290, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T148[] =
    {
	45, 45, 77, 61, 45, 78, 45, 45, 77, -1, 45, 45, 45, 45, 45, 76, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T149[] =
    {
	242, 242, 314, 316, 242, 313, 242, 242, 314, -1, 242, 242, 242, 242, 242, 
	315, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T150[] =
    {
	468, 468, 559, 524, 468, 558, 468, 468, 559, -1, 468, 468, 468, 468, 606, 
	607, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T151[] =
    {
	242, 242, 499, 316, 442, 498, 242, 242, 499, -1, 242, 242, 242, 242, 242, 
	315, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T152[] =
    {
	66, 66, 66, 47, 66, 66, 66, 66, 66, -1, 66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66
    };

static const ANTLR3_INT32 dfa4_T153[] =
    {
	294, 294, 294, 324, 294, 293, 294, 294, 294, -1, 294, 294, 294, 294, 294, 
	294, 294, 294, 294, 294, 294, 294, 294, 294, 294
    };

static const ANTLR3_INT32 dfa4_T154[] =
    {
	356, 242, 354, 344, 357, 361, 355, 242, 354, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T155[] =
    {
	566
    };

static const ANTLR3_INT32 dfa4_T156[] =
    {
	698
    };

static const ANTLR3_INT32 dfa4_T157[] =
    {
	492, 255, 493, 489, 415, 494, 416, 255, 493, -1, 255, 255, 255, 255, 255, 
	255, 413, 255, 407, 408, 409, 411, 410, 414, 412
    };

static const ANTLR3_INT32 dfa4_T158[] =
    {
	468, 468, 468, 615, 468, 468, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	614, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T159[] =
    {
	453
    };

static const ANTLR3_INT32 dfa4_T160[] =
    {
	468, 468, 605, 524, 468, 609, 468, 468, 605, -1, 468, 468, 468, 468, 468, 
	608, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T161[] =
    {
	3
    };

static const ANTLR3_INT32 dfa4_T162[] =
    {
	350, 350, 350, 230, 350, 350, 350, 350, 350, -1, 350, 350, 350, 350, 350, 
	419, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T163[] =
    {
	45, 45, 45, 84, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 83, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T164[] =
    {
	356, 242, 421, 417, 357, 422, 355, 242, 421, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T165[] =
    {
	242, 242, 497, 506, 439, 505, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	419, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T166[] =
    {
	840, 670, 849, 837, 841, 851, 839, 670, 849, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T167[] =
    {
	21, 6, 18, 23, 22, 19, 20, 6, 18, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T168[] =
    {
	468, 468, 748, 750, 716, 751, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	664, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T169[] =
    {
	157, 6, 158, 153, 123, 159, 124, 6, 158, -1, 6, 6, 6, 6, 6, 6, 121, 6, 
	115, 116, 117, 119, 118, 122, 120
    };

static const ANTLR3_INT32 dfa4_T170[] =
    {
	670, 670, 670, 467, 670, 670, 670, 670, 670, -1, 670, 670, 670, 670, 670, 
	700, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T171[] =
    {
	96, 98, 126, 93, 97, 127, 95, 98, 126, -1, 98, 98, 98, 98, 98, 94, 98, 
	98, 98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T172[] =
    {
	207, -1, -1, 208, -1, -1, 207
    };

static const ANTLR3_INT32 dfa4_T173[] =
    {
	818, 374, 815, 810, 819, 816, 817, 374, 815, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T174[] =
    {
	323
    };

static const ANTLR3_INT32 dfa4_T175[] =
    {
	45, 45, 164, 163, 139, 165, 140, 45, 164, -1, 45, 45, 45, 45, 45, 94, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T176[] =
    {
	284
    };

static const ANTLR3_INT32 dfa4_T177[] =
    {
	98, 98, 98, 35, 98, 98, 98, 98, 98, -1, 98, 98, 98, 98, 98, 142, 98, 98, 
	98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T178[] =
    {
	795
    };

static const ANTLR3_INT32 dfa4_T179[] =
    {
	48, 45, 50, 47, 43, 185, 44, 45, 50, -1, 45, 45, 45, 45, 45, 197, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T180[] =
    {
	264, 242, 229, 263, 239, 228, 240, 242, 229, -1, 242, 242, 242, 242, 242, 
	262, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T181[] =
    {
	845, 468, 843, 837, 846, 848, 844, 468, 843, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T182[] =
    {
	718
    };

static const ANTLR3_INT32 dfa4_T183[] =
    {
	103, 45, 101, 93, 104, 100, 102, 45, 101, -1, 45, 45, 45, 45, 45, 33, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T184[] =
    {
	468, 468, 828, 524, 468, 831, 468, 468, 828, -1, 468, 468, 468, 468, 468, 
	830, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T185[] =
    {
	226
    };

static const ANTLR3_INT32 dfa4_T186[] =
    {
	306, -1, -1, 307, -1, -1, 306
    };

static const ANTLR3_INT32 dfa4_T187[] =
    {
	337
    };

static const ANTLR3_INT32 dfa4_T188[] =
    {
	45, 45, 77, 54, 45, 78, 45, 45, 77, -1, 45, 45, 45, 45, 45, 87, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T189[] =
    {
	109
    };

static const ANTLR3_INT32 dfa4_T190[] =
    {
	743, 743, 743, 773, 743, 742, 743, 743, 743, -1, 743, 743, 743, 743, 743, 
	743, 743, 743, 743, 743, 743, 743, 743, 743, 743
    };

static const ANTLR3_INT32 dfa4_T191[] =
    {
	79
    };

static const ANTLR3_INT32 dfa4_T192[] =
    {
	348, 350, 345, 344, 349, 343, 347, 350, 345, -1, 350, 350, 350, 350, 350, 
	346, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T193[] =
    {
	128
    };

static const ANTLR3_INT32 dfa4_T194[] =
    {
	468, 468, 468, 524, 468, 468, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T195[] =
    {
	308, -1, -1, 309, -1, -1, 308
    };

static const ANTLR3_INT32 dfa4_T196[] =
    {
	500
    };

static const ANTLR3_INT32 dfa4_T197[] =
    {
	45, 45, 45, 54, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 33, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T198[] =
    {
	668, 670, 666, 665, 669, 663, 667, 670, 666, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T199[] =
    {
	150, -1, -1, 151, -1, -1, 150
    };

static const ANTLR3_INT32 dfa4_T200[] =
    {
	468, 468, 517, 467, 464, 536, 465, 468, 517, -1, 468, 468, 468, 468, 468, 
	468, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T201[] =
    {
	6, 6, 11, 6, 6, 14, 6, 6, 11, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T202[] =
    {
	301, 301, 301, 275, 301, 301, 301, 301, 301, -1, 301, 301, 301, 301, 301, 
	301, 301, 301, 301, 301, 301, 301, 301, 301, 301
    };

static const ANTLR3_INT32 dfa4_T203[] =
    {
	374, 374, 511, 552, 374, 512, 374, 374, 511, -1, 374, 374, 374, 374, 548, 
	549, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T204[] =
    {
	513, -1, -1, 514, -1, -1, 513
    };

static const ANTLR3_INT32 dfa4_T205[] =
    {
	535, 535, 535, 489, 535, 535, 535, 535, 535, -1, 535, 535, 535, 535, 535, 
	535, 535, 535, 535, 535, 535, 535, 535, 535, 535
    };

static const ANTLR3_INT32 dfa4_T206[] =
    {
	45, 45, 50, 35, 43, 185, 44, 45, 50, -1, 45, 45, 45, 45, 45, 45, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T207[] =
    {
	374, 374, 641, 375, 650, 640, 651, 374, 641, -1, 374, 374, 374, 374, 374, 
	374, 648, 374, 642, 643, 644, 646, 645, 649, 647
    };

static const ANTLR3_INT32 dfa4_T208[] =
    {
	555, 555, 555, 516, 555, 554, 555, 555, 555, -1, 555, 555, 555, 555, 555, 
	555, 555, 555, 555, 555, 555, 555, 555, 555, 555
    };

static const ANTLR3_INT32 dfa4_T209[] =
    {
	6, 6, 215, 6, 224, 214, 225, 6, 215, -1, 6, 6, 6, 6, 6, 6, 222, 6, 216, 
	217, 218, 220, 219, 223, 221
    };

static const ANTLR3_INT32 dfa4_T210[] =
    {
	377
    };

static const ANTLR3_INT32 dfa4_T211[] =
    {
	468, 468, 605, 467, 468, 609, 468, 468, 605, -1, 468, 468, 468, 468, 468, 
	661, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T212[] =
    {
	6, 6, 627, 6, 637, 628, 638, 6, 627, -1, 6, 6, 6, 6, 6, 6, 635, 6, 629, 
	630, 631, 633, 632, 636, 634
    };

static const ANTLR3_INT32 dfa4_T213[] =
    {
	173, 173, 173, 153, 173, 173, 173, 173, 173, -1, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 173, 173
    };

static const ANTLR3_INT32 dfa4_T214[] =
    {
	556
    };

static const ANTLR3_INT32 dfa4_T215[] =
    {
	242, 242, 242, 316, 242, 242, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	315, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T216[] =
    {
	374, 374, 374, 375, 374, 374, 374, 374, 374, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T217[] =
    {
	450, 374, 451, 446, 372, 452, 373, 374, 451, -1, 374, 374, 374, 374, 374, 
	374, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T218[] =
    {
	535, 535, 535, 568, 535, 534, 535, 535, 535, -1, 535, 535, 535, 535, 535, 
	535, 535, 535, 535, 535, 535, 535, 535, 535, 535
    };

static const ANTLR3_INT32 dfa4_T219[] =
    {
	691, 6, 692, 690, 637, 693, 638, 6, 692, -1, 6, 6, 6, 6, 6, 6, 635, 6, 
	629, 630, 631, 633, 632, 636, 634
    };

static const ANTLR3_INT32 dfa4_T220[] =
    {
	374, 374, 393, 375, 403, 394, 404, 374, 393, -1, 374, 374, 374, 374, 374, 
	374, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T221[] =
    {
	242, 242, 260, 230, 239, 261, 240, 242, 260, -1, 242, 242, 242, 242, 242, 
	242, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T222[] =
    {
	761, 45, 763, 762, 736, 784, 737, 45, 763, -1, 45, 45, 45, 45, 45, 197, 
	734, 45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T223[] =
    {
	674, 468, 703, 665, 675, 704, 673, 468, 703, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T224[] =
    {
	242, 242, 311, 340, 242, 312, 242, 242, 311, -1, 242, 242, 242, 242, 319, 
	338, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T225[] =
    {
	468, 468, 526, 524, 468, 617, 468, 468, 526, -1, 468, 468, 468, 468, 468, 
	681, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T226[] =
    {
	374, 374, 641, 694, 650, 640, 651, 374, 641, -1, 374, 374, 374, 374, 374, 
	578, 648, 374, 642, 643, 644, 646, 645, 649, 647
    };

static const ANTLR3_INT32 dfa4_T227[] =
    {
	468, 468, 822, 524, 468, 821, 468, 468, 822, -1, 468, 468, 468, 468, 606, 
	829, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T228[] =
    {
	342
    };

static const ANTLR3_INT32 dfa4_T229[] =
    {
	384, 386, 379, 381, 385, 382, 383, 386, 379, -1, 386, 386, 386, 386, 386, 
	380, 386, 386, 386, 386, 386, 386, 386, 386, 386
    };

static const ANTLR3_INT32 dfa4_T230[] =
    {
	195, -1, -1, 196, -1, -1, 195
    };

static const ANTLR3_INT32 dfa4_T231[] =
    {
	45, 45, 53, 54, 45, 80, 45, 45, 53, -1, 45, 45, 45, 45, 45, 106, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T232[] =
    {
	242, 242, 430, 271, 439, 429, 440, 242, 430, -1, 242, 242, 242, 242, 242, 
	241, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T233[] =
    {
	6, 6, 215, 258, 224, 214, 225, 6, 215, -1, 6, 6, 6, 6, 6, 201, 222, 6, 
	216, 217, 218, 220, 219, 223, 221
    };

static const ANTLR3_INT32 dfa4_T234[] =
    {
	299
    };

static const ANTLR3_INT32 dfa4_T235[] =
    {
	797
    };

static const ANTLR3_INT32 dfa4_T236[] =
    {
	45, 45, 68, 54, 45, 67, 45, 45, 68, -1, 45, 45, 45, 45, 75, 86, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T237[] =
    {
	423
    };

static const ANTLR3_INT32 dfa4_T238[] =
    {
	9, 6, 4, 6, 6, 5, 6, 6, 4, -1, 6, 6, 6, 6, 6, 10, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T239[] =
    {
	775
    };

static const ANTLR3_INT32 dfa4_T240[] =
    {
	749
    };

static const ANTLR3_INT32 dfa4_T241[] =
    {
	242, 242, 497, 230, 439, 496, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	242, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T242[] =
    {
	468, 468, 707, 750, 716, 796, 717, 468, 707, -1, 468, 468, 468, 468, 468, 
	719, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T243[] =
    {
	64
    };

static const ANTLR3_INT32 dfa4_T244[] =
    {
	348, 350, 345, 344, 349, 343, 347, 350, 345, -1, 350, 350, 350, 350, 350, 
	427, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T245[] =
    {
	242, 242, 273, 271, 242, 272, 242, 242, 273, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T246[] =
    {
	468, 468, 793, 467, 464, 794, 465, 468, 793, -1, 468, 468, 468, 468, 468, 
	466, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T247[] =
    {
	45, 45, 130, 163, 139, 190, 140, 45, 130, -1, 45, 45, 45, 45, 45, 125, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T248[] =
    {
	108
    };

static const ANTLR3_INT32 dfa4_T249[] =
    {
	242, 242, 289, 291, 287, 288, 242, 242, 289, -1, 242, 242, 242, 242, 242, 
	290, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T250[] =
    {
	70
    };

static const ANTLR3_INT32 dfa4_T251[] =
    {
	242, 242, 242, 230, 242, 242, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T252[] =
    {
	268, 242, 269, 263, 239, 270, 240, 242, 269, -1, 242, 242, 242, 242, 242, 
	242, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T253[] =
    {
	198
    };

static const ANTLR3_INT32 dfa4_T254[] =
    {
	283
    };

static const ANTLR3_INT32 dfa4_T255[] =
    {
	753, -1, -1, 754, -1, -1, 753
    };

static const ANTLR3_INT32 dfa4_T256[] =
    {
	445, 374, 362, 446, 372, 447, 373, 374, 362, -1, 374, 374, 374, 374, 374, 
	448, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T257[] =
    {
	242, 242, 538, 539, 439, 537, 440, 242, 538, -1, 242, 242, 242, 242, 242, 
	540, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T258[] =
    {
	242, 242, 497, 541, 439, 505, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	542, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T259[] =
    {
	167
    };

static const ANTLR3_INT32 dfa4_T260[] =
    {
	255, 255, 405, 256, 415, 406, 416, 255, 405, -1, 255, 255, 255, 255, 255, 
	255, 413, 255, 407, 408, 409, 411, 410, 414, 412
    };

static const ANTLR3_INT32 dfa4_T261[] =
    {
	374, 374, 511, 375, 374, 510, 374, 374, 511, -1, 374, 374, 374, 374, 548, 
	549, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T262[] =
    {
	242, 242, 497, 506, 439, 496, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	419, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T263[] =
    {
	274, 255, 243, 275, 253, 244, 254, 255, 243, -1, 255, 255, 255, 255, 255, 
	278, 251, 255, 245, 246, 247, 249, 248, 252, 250
    };

static const ANTLR3_INT32 dfa4_T264[] =
    {
	653, 6, 591, 654, 601, 655, 602, 6, 591, -1, 6, 6, 6, 6, 6, 155, 599, 6, 
	593, 594, 595, 597, 596, 600, 598
    };

static const ANTLR3_INT32 dfa4_T265[] =
    {
	255, 255, 255, 256, 255, 378, 255, 255, 255, -1, 255, 255, 255, 255, 255, 
	469, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T266[] =
    {
	484, 374, 393, 485, 403, 483, 404, 374, 393, -1, 374, 374, 374, 374, 374, 
	448, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T267[] =
    {
	689, 6, 627, 690, 637, 688, 638, 6, 627, -1, 6, 6, 6, 6, 6, 155, 635, 6, 
	629, 630, 631, 633, 632, 636, 634
    };

static const ANTLR3_INT32 dfa4_T268[] =
    {
	468, 468, 725, 564, 468, 724, 468, 468, 725, -1, 468, 468, 468, 468, 468, 
	563, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T269[] =
    {
	45, 45, 147, 61, 45, 146, 45, 45, 147, -1, 45, 45, 45, 45, 45, 62, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T270[] =
    {
	468, 468, 756, 564, 757, 755, 717, 468, 756, -1, 468, 468, 468, 468, 468, 
	563, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T271[] =
    {
	374, 374, 790, 375, 374, 791, 374, 374, 790, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T272[] =
    {
	468, 468, 605, 467, 468, 623, 468, 468, 605, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T273[] =
    {
	484, 374, 768, 485, 403, 788, 404, 374, 768, -1, 374, 374, 374, 374, 374, 
	770, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T274[] =
    {
	356, 242, 354, 344, 357, 353, 355, 242, 354, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T275[] =
    {
	45, 45, 161, 61, 162, 160, 140, 45, 161, -1, 45, 45, 45, 45, 45, 62, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T276[] =
    {
	6, 6, 6, 6, 6, 176, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T277[] =
    {
	468, 468, 756, 778, 716, 755, 717, 468, 756, -1, 468, 468, 468, 468, 468, 
	779, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T278[] =
    {
	468, 468, 782, 615, 757, 825, 717, 468, 782, -1, 468, 468, 468, 468, 468, 
	614, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T279[] =
    {
	445, 374, 740, 446, 372, 771, 373, 374, 740, -1, 374, 374, 374, 374, 374, 
	770, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T280[] =
    {
	468, 468, 725, 564, 723, 724, 468, 468, 725, -1, 468, 468, 468, 468, 468, 
	563, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T281[] =
    {
	45, 45, 161, 177, 139, 160, 140, 45, 161, -1, 45, 45, 45, 45, 45, 178, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T282[] =
    {
	376
    };

static const ANTLR3_INT32 dfa4_T283[] =
    {
	45, 45, 180, 84, 162, 227, 140, 45, 180, -1, 45, 45, 45, 45, 45, 83, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T284[] =
    {
	242, 242, 242, 291, 242, 242, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	290, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T285[] =
    {
	264, 242, 260, 263, 239, 265, 240, 242, 260, -1, 242, 242, 242, 242, 242, 
	285, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T286[] =
    {
	468, 468, 613, 615, 468, 612, 468, 468, 613, -1, 468, 468, 468, 468, 468, 
	614, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T287[] =
    {
	45, 45, 147, 61, 148, 146, 45, 45, 147, -1, 45, 45, 45, 45, 45, 62, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T288[] =
    {
	173, 173, 173, 186, 173, 172, 173, 173, 173, -1, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 173, 173
    };

static const ANTLR3_INT32 dfa4_T289[] =
    {
	468, 468, 759, 615, 723, 758, 468, 468, 759, -1, 468, 468, 468, 468, 468, 
	614, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T290[] =
    {
	45, 45, 82, 84, 45, 81, 45, 45, 82, -1, 45, 45, 45, 45, 45, 83, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T291[] =
    {
	89
    };

static const ANTLR3_INT32 dfa4_T292[] =
    {
	553
    };

static const ANTLR3_INT32 dfa4_T293[] =
    {
	674, 468, 672, 665, 675, 671, 673, 468, 672, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T294[] =
    {
	555, 555, 555, 603, 555, 554, 555, 555, 555, -1, 555, 555, 555, 555, 555, 
	555, 555, 555, 555, 555, 555, 555, 555, 555, 555
    };

static const ANTLR3_INT32 dfa4_T295[] =
    {
	45, 45, 170, 84, 148, 169, 45, 45, 170, -1, 45, 45, 45, 45, 45, 83, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T296[] =
    {
	242, 242, 311, 230, 242, 310, 242, 242, 311, -1, 242, 242, 242, 242, 319, 
	338, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T297[] =
    {
	468, 468, 822, 524, 468, 821, 468, 468, 822, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T298[] =
    {
	374, 374, 790, 552, 374, 791, 374, 374, 790, -1, 374, 374, 374, 374, 548, 
	800, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T299[] =
    {
	674, 468, 703, 701, 675, 704, 673, 468, 703, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T300[] =
    {
	45, 45, 68, 54, 45, 67, 45, 45, 68, -1, 45, 45, 45, 45, 45, 33, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T301[] =
    {
	6, 6, 6, 6, 6, 176, 6, 6, 6, -1, 6, 6, 6, 6, 187, 188, 6, 6, 6, 6, 6, 6, 
	6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T302[] =
    {
	48, 45, 50, 47, 43, 51, 44, 45, 50, -1, 45, 45, 45, 45, 45, 69, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T303[] =
    {
	622
    };

static const ANTLR3_INT32 dfa4_T304[] =
    {
	509
    };

static const ANTLR3_INT32 dfa4_T305[] =
    {
	468, 468, 828, 467, 468, 827, 468, 468, 828, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T306[] =
    {
	255, 255, 304, 256, 255, 303, 255, 255, 304, -1, 255, 255, 255, 255, 255, 
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T307[] =
    {
	45, 45, 77, 35, 45, 88, 45, 45, 77, -1, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T308[] =
    {
	255, 255, 255, 256, 255, 378, 255, 255, 255, -1, 255, 255, 255, 255, 255, 
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T309[] =
    {
	515, 468, 454, 516, 464, 455, 465, 468, 454, -1, 468, 468, 468, 468, 468, 
	520, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T310[] =
    {
	468, 468, 828, 467, 468, 831, 468, 468, 828, -1, 468, 468, 468, 468, 468, 
	835, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T311[] =
    {
	45, 45, 77, 35, 45, 78, 45, 45, 77, -1, 45, 45, 45, 45, 45, 105, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T312[] =
    {
	267
    };

static const ANTLR3_INT32 dfa4_T313[] =
    {
	173, 173, 173, 153, 173, 172, 173, 173, 173, -1, 173, 173, 173, 173, 173, 
	173, 173, 173, 173, 173, 173, 173, 173, 173, 173
    };

static const ANTLR3_INT32 dfa4_T314[] =
    {
	776
    };

static const ANTLR3_INT32 dfa4_T315[] =
    {
	6, 6, 6, 6, 6, 13, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T316[] =
    {
	668, 670, 666, 665, 669, 676, 667, 670, 666, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T317[] =
    {
	392
    };

static const ANTLR3_INT32 dfa4_T318[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa4_T319[] =
    {
	242, 242, 289, 318, 242, 288, 242, 242, 289, -1, 242, 242, 242, 242, 319, 
	317, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T320[] =
    {
	652
    };

static const ANTLR3_INT32 dfa4_T321[] =
    {
	174
    };

static const ANTLR3_INT32 dfa4_T322[] =
    {
	58
    };

static const ANTLR3_INT32 dfa4_T323[] =
    {
	45, 45, 726, 35, 736, 727, 737, 45, 726, -1, 45, 45, 45, 45, 45, 33, 734, 
	45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T324[] =
    {
	386, 386, 386, 256, 386, 386, 386, 386, 386, -1, 386, 386, 386, 386, 386, 
	380, 386, 386, 386, 386, 386, 386, 386, 386, 386
    };

static const ANTLR3_INT32 dfa4_T325[] =
    {
	25
    };

static const ANTLR3_INT32 dfa4_T326[] =
    {
	491, 255, 405, 489, 415, 406, 416, 255, 405, -1, 255, 255, 255, 255, 255, 
	278, 413, 255, 407, 408, 409, 411, 410, 414, 412
    };

static const ANTLR3_INT32 dfa4_T327[] =
    {
	24
    };

static const ANTLR3_INT32 dfa4_T328[] =
    {
	677
    };

static const ANTLR3_INT32 dfa4_T329[] =
    {
	26
    };

static const ANTLR3_INT32 dfa4_T330[] =
    {
	348, 350, 418, 344, 349, 420, 347, 350, 418, -1, 350, 350, 350, 350, 350, 
	346, 350, 350, 350, 350, 350, 350, 350, 350, 350
    };

static const ANTLR3_INT32 dfa4_T331[] =
    {
	786, 786, 786, 799, 786, 785, 786, 786, 786, -1, 786, 786, 786, 786, 786, 
	786, 786, 786, 786, 786, 786, 786, 786, 786, 786
    };

static const ANTLR3_INT32 dfa4_T332[] =
    {
	508, 508, 508, 446, 508, 508, 508, 508, 508, -1, 508, 508, 508, 508, 508, 
	508, 508, 508, 508, 508, 508, 508, 508, 508, 508
    };

static const ANTLR3_INT32 dfa4_T333[] =
    {
	28, -1, -1, 29, -1, -1, 28
    };

static const ANTLR3_INT32 dfa4_T334[] =
    {
	743, 743, 743, 690, 743, 743, 743, 743, 743, -1, 743, 743, 743, 743, 743, 
	743, 743, 743, 743, 743, 743, 743, 743, 743, 743
    };

static const ANTLR3_INT32 dfa4_T335[] =
    {
	374, 374, 790, 375, 374, 789, 374, 374, 790, -1, 374, 374, 374, 374, 548, 
	800, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T336[] =
    {
	6, 6, 6, 6, 6, 175, 6, 6, 6, -1, 6, 6, 6, 6, 187, 188, 6, 6, 6, 6, 6, 6, 
	6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T337[] =
    {
	6, 6, 4, 6, 6, 5, 6, 6, 4, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6
    };

static const ANTLR3_INT32 dfa4_T338[] =
    {
	242, 242, 430, 271, 439, 573, 440, 242, 430, -1, 242, 242, 242, 242, 242, 
	241, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T339[] =
    {
	845, 468, 843, 837, 846, 848, 844, 468, 843, -1, 468, 468, 468, 468, 468, 
	681, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T340[] =
    {
	531, 531, 531, 567, 531, 530, 531, 531, 531, -1, 531, 531, 531, 531, 531, 
	531, 531, 531, 531, 531, 531, 531, 531, 531, 531
    };

static const ANTLR3_INT32 dfa4_T341[] =
    {
	242, 242, 497, 230, 439, 571, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	242, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T342[] =
    {
	103, 45, 101, 93, 104, 100, 102, 45, 101, -1, 45, 45, 45, 45, 45, 106, 
	45, 45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T343[] =
    {
	242, 242, 273, 271, 242, 322, 242, 242, 273, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T344[] =
    {
	294, 294, 294, 263, 294, 294, 294, 294, 294, -1, 294, 294, 294, 294, 294, 
	294, 294, 294, 294, 294, 294, 294, 294, 294, 294
    };

static const ANTLR3_INT32 dfa4_T345[] =
    {
	468, 468, 605, 685, 468, 623, 468, 468, 605, -1, 468, 468, 468, 468, 606, 
	660, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T346[] =
    {
	468, 468, 707, 524, 716, 706, 717, 468, 707, -1, 468, 468, 468, 468, 468, 
	466, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T347[] =
    {
	48, 45, 32, 47, 43, 31, 44, 45, 32, -1, 45, 45, 45, 45, 45, 46, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T348[] =
    {
	242, 242, 242, 230, 242, 341, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	424, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T349[] =
    {
	242, 242, 242, 230, 242, 341, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T350[] =
    {
	532
    };

static const ANTLR3_INT32 dfa4_T351[] =
    {
	45, 45, 130, 54, 139, 129, 140, 45, 130, -1, 45, 45, 45, 45, 45, 33, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T352[] =
    {
	659
    };

static const ANTLR3_INT32 dfa4_T353[] =
    {
	468, 468, 748, 467, 716, 747, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	468, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T354[] =
    {
	301, 301, 301, 275, 301, 300, 301, 301, 301, -1, 301, 301, 301, 301, 301, 
	301, 301, 301, 301, 301, 301, 301, 301, 301, 301
    };

static const ANTLR3_INT32 dfa4_T355[] =
    {
	515, 468, 793, 516, 464, 794, 465, 468, 793, -1, 468, 468, 468, 468, 468, 
	806, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T356[] =
    {
	668, 670, 666, 665, 669, 676, 667, 670, 666, -1, 670, 670, 670, 670, 670, 
	719, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T357[] =
    {
	45, 45, 164, 35, 139, 168, 140, 45, 164, -1, 45, 45, 45, 45, 45, 45, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T358[] =
    {
	242, 242, 497, 506, 439, 571, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	624, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T359[] =
    {
	282
    };

static const ANTLR3_INT32 dfa4_T360[] =
    {
	845, 468, 852, 837, 846, 853, 844, 468, 852, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T361[] =
    {
	374, 374, 768, 375, 403, 769, 404, 374, 768, -1, 374, 374, 374, 374, 374, 
	374, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T362[] =
    {
	468, 468, 562, 564, 561, 560, 468, 468, 562, -1, 468, 468, 468, 468, 468, 
	563, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T363[] =
    {
	745
    };

static const ANTLR3_INT32 dfa4_T364[] =
    {
	535, 535, 535, 489, 535, 534, 535, 535, 535, -1, 535, 535, 535, 535, 535, 
	535, 535, 535, 535, 535, 535, 535, 535, 535, 535
    };

static const ANTLR3_INT32 dfa4_T365[] =
    {
	468, 468, 468, 467, 468, 468, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	468, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T366[] =
    {
	103, 45, 144, 93, 104, 145, 102, 45, 144, -1, 45, 45, 45, 45, 45, 33, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T367[] =
    {
	468, 468, 782, 780, 716, 783, 717, 468, 782, -1, 468, 468, 468, 468, 468, 
	781, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T368[] =
    {
	45, 45, 45, 35, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T369[] =
    {
	575
    };

static const ANTLR3_INT32 dfa4_T370[] =
    {
	468, 468, 748, 778, 716, 751, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	779, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T371[] =
    {
	45, 45, 180, 181, 139, 179, 140, 45, 180, -1, 45, 45, 45, 45, 45, 182, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T372[] =
    {
	171
    };

static const ANTLR3_INT32 dfa4_T373[] =
    {
	45, 45, 164, 177, 139, 165, 140, 45, 164, -1, 45, 45, 45, 45, 45, 178, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T374[] =
    {
	808
    };

static const ANTLR3_INT32 dfa4_T375[] =
    {
	572
    };

static const ANTLR3_INT32 dfa4_T376[] =
    {
	468, 468, 748, 752, 716, 747, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	700, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T377[] =
    {
	445, 374, 362, 446, 372, 363, 373, 374, 362, -1, 374, 374, 374, 374, 374, 
	449, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T378[] =
    {
	618
    };

static const ANTLR3_INT32 dfa4_T379[] =
    {
	374, 374, 374, 375, 374, 576, 374, 374, 374, -1, 374, 374, 374, 374, 374, 
	639, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T380[] =
    {
	428
    };

static const ANTLR3_INT32 dfa4_T381[] =
    {
	45, 45, 164, 166, 139, 168, 140, 45, 164, -1, 45, 45, 45, 45, 45, 142, 
	137, 45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T382[] =
    {
	6, 6, 6, 6, 6, 199, 6, 6, 6, -1, 6, 6, 6, 6, 6, 213, 6, 6, 6, 6, 6, 6, 
	6, 6, 6
    };

static const ANTLR3_INT32 dfa4_T383[] =
    {
	854
    };

static const ANTLR3_INT32 dfa4_T384[] =
    {
	189
    };

static const ANTLR3_INT32 dfa4_T385[] =
    {
	210
    };

static const ANTLR3_INT32 dfa4_T386[] =
    {
	674, 468, 672, 665, 675, 680, 673, 468, 672, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T387[] =
    {
	840, 670, 838, 837, 841, 836, 839, 670, 838, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T388[] =
    {
	697, 697, 697, 746, 697, 696, 697, 697, 697, -1, 697, 697, 697, 697, 697, 
	697, 697, 697, 697, 697, 697, 697, 697, 697, 697
    };

static const ANTLR3_INT32 dfa4_T389[] =
    {
	468, 468, 468, 564, 468, 468, 468, 468, 468, -1, 468, 468, 468, 468, 468, 
	563, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T390[] =
    {
	242, 242, 538, 539, 439, 686, 440, 242, 538, -1, 242, 242, 242, 242, 242, 
	540, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T391[] =
    {
	515, 468, 517, 516, 464, 518, 465, 468, 517, -1, 468, 468, 468, 468, 468, 
	557, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T392[] =
    {
	96, 98, 92, 93, 97, 110, 95, 98, 92, -1, 98, 98, 98, 98, 98, 94, 98, 98, 
	98, 98, 98, 98, 98, 98, 98
    };

static const ANTLR3_INT32 dfa4_T393[] =
    {
	45, 45, 45, 61, 45, 45, 45, 45, 45, -1, 45, 45, 45, 45, 45, 62, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T394[] =
    {
	468, 468, 605, 467, 468, 604, 468, 468, 605, -1, 468, 468, 468, 468, 606, 
	660, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T395[] =
    {
	264, 242, 260, 263, 239, 261, 240, 242, 260, -1, 242, 242, 242, 242, 242, 
	286, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T396[] =
    {
	242, 242, 242, 230, 242, 352, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	441, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T397[] =
    {
	743, 743, 743, 690, 743, 742, 743, 743, 743, -1, 743, 743, 743, 743, 743, 
	743, 743, 743, 743, 743, 743, 743, 743, 743, 743
    };

static const ANTLR3_INT32 dfa4_T398[] =
    {
	45, 45, 763, 35, 736, 784, 737, 45, 763, -1, 45, 45, 45, 45, 45, 45, 734, 
	45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T399[] =
    {
	374, 374, 511, 375, 374, 510, 374, 374, 511, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T400[] =
    {
	255, 255, 304, 256, 255, 305, 255, 255, 304, -1, 255, 255, 255, 255, 255, 
	255, 255, 255, 255, 255, 255, 255, 255, 255, 255
    };

static const ANTLR3_INT32 dfa4_T401[] =
    {
	761, 45, 726, 762, 736, 727, 737, 45, 726, -1, 45, 45, 45, 45, 45, 46, 
	734, 45, 728, 729, 730, 732, 731, 735, 733
    };

static const ANTLR3_INT32 dfa4_T402[] =
    {
	374, 374, 374, 375, 374, 576, 374, 374, 374, -1, 374, 374, 374, 374, 374, 
	374, 374, 374, 374, 374, 374, 374, 374, 374, 374
    };

static const ANTLR3_INT32 dfa4_T403[] =
    {
	45, 45, 77, 35, 45, 212, 45, 45, 77, -1, 45, 45, 45, 45, 45, 45, 45, 45, 
	45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T404[] =
    {
	697, 697, 697, 654, 697, 696, 697, 697, 697, -1, 697, 697, 697, 697, 697, 
	697, 697, 697, 697, 697, 697, 697, 697, 697, 697
    };

static const ANTLR3_INT32 dfa4_T405[] =
    {
	515, 468, 803, 516, 464, 804, 465, 468, 803, -1, 468, 468, 468, 468, 468, 
	820, 462, 468, 456, 457, 458, 460, 459, 463, 461
    };

static const ANTLR3_INT32 dfa4_T406[] =
    {
	6, 6, 6, 6, 6, 199, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa4_T407[] =
    {
	721, -1, -1, 722, -1, -1, 721
    };

static const ANTLR3_INT32 dfa4_T408[] =
    {
	66, 66, 66, 85, 66, 65, 66, 66, 66, -1, 66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66
    };

static const ANTLR3_INT32 dfa4_T409[] =
    {
	242, 242, 430, 504, 439, 429, 440, 242, 430, -1, 242, 242, 242, 242, 242, 
	346, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T410[] =
    {
	292
    };

static const ANTLR3_INT32 dfa4_T411[] =
    {
	374, 374, 362, 375, 372, 363, 373, 374, 362, -1, 374, 374, 374, 374, 374, 
	374, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T412[] =
    {
	468, 468, 562, 611, 468, 560, 468, 468, 562, -1, 468, 468, 468, 468, 606, 
	610, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };

static const ANTLR3_INT32 dfa4_T413[] =
    {
	48, 45, 50, 47, 43, 51, 44, 45, 50, -1, 45, 45, 45, 45, 45, 49, 41, 45, 
	34, 36, 37, 39, 38, 42, 40
    };

static const ANTLR3_INT32 dfa4_T414[] =
    {
	264, 242, 260, 263, 239, 265, 240, 242, 260, -1, 242, 242, 242, 242, 242, 
	266, 237, 242, 231, 232, 233, 235, 234, 238, 236
    };

static const ANTLR3_INT32 dfa4_T415[] =
    {
	301, 301, 301, 330, 301, 300, 301, 301, 301, -1, 301, 301, 301, 301, 301, 
	301, 301, 301, 301, 301, 301, 301, 301, 301, 301
    };

static const ANTLR3_INT32 dfa4_T416[] =
    {
	425, -1, -1, 426, -1, -1, 425
    };

static const ANTLR3_INT32 dfa4_T417[] =
    {
	574
    };

static const ANTLR3_INT32 dfa4_T418[] =
    {
	242, 242, 311, 291, 242, 321, 242, 242, 311, -1, 242, 242, 242, 242, 242, 
	320, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T419[] =
    {
	242, 242, 497, 539, 439, 505, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	540, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T420[] =
    {
	242, 242, 296, 271, 242, 295, 242, 242, 296, -1, 242, 242, 242, 242, 242, 
	241, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T421[] =
    {
	45, 45, 77, 257, 45, 212, 45, 45, 77, -1, 45, 45, 45, 45, 75, 112, 45, 
	45, 45, 45, 45, 45, 45, 45, 45
    };

static const ANTLR3_INT32 dfa4_T422[] =
    {
	242, 242, 311, 230, 242, 310, 242, 242, 311, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T423[] =
    {
	787
    };

static const ANTLR3_INT32 dfa4_T424[] =
    {
	6, 6, 113, 6, 123, 114, 124, 6, 113, -1, 6, 6, 6, 6, 6, 6, 121, 6, 115, 
	116, 117, 119, 118, 122, 120
    };

static const ANTLR3_INT32 dfa4_T425[] =
    {
	6, 6, 591, 6, 601, 592, 602, 6, 591, -1, 6, 6, 6, 6, 6, 6, 599, 6, 593, 
	594, 595, 597, 596, 600, 598
    };

static const ANTLR3_INT32 dfa4_T426[] =
    {
	484, 374, 393, 485, 403, 394, 404, 374, 393, -1, 374, 374, 374, 374, 374, 
	449, 401, 374, 395, 396, 397, 399, 398, 402, 400
    };

static const ANTLR3_INT32 dfa4_T427[] =
    {
	242, 242, 242, 230, 242, 352, 242, 242, 242, -1, 242, 242, 242, 242, 242, 
	242, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T428[] =
    {
	570
    };

static const ANTLR3_INT32 dfa4_T429[] =
    {
	152, 6, 113, 153, 123, 114, 124, 6, 113, -1, 6, 6, 6, 6, 6, 156, 121, 6, 
	115, 116, 117, 119, 118, 122, 120
    };

static const ANTLR3_INT32 dfa4_T430[] =
    {
	543
    };

static const ANTLR3_INT32 dfa4_T431[] =
    {
	356, 242, 354, 344, 357, 353, 355, 242, 354, -1, 242, 242, 242, 242, 242, 
	358, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T432[] =
    {
	679
    };

static const ANTLR3_INT32 dfa4_T433[] =
    {
	495
    };

static const ANTLR3_INT32 dfa4_T434[] =
    {
	668, 670, 699, 665, 669, 702, 667, 670, 699, -1, 670, 670, 670, 670, 670, 
	664, 670, 670, 670, 670, 670, 670, 670, 670, 670
    };

static const ANTLR3_INT32 dfa4_T435[] =
    {
	792
    };

static const ANTLR3_INT32 dfa4_T436[] =
    {
	565
    };

static const ANTLR3_INT32 dfa4_T437[] =
    {
	66, 66, 66, 47, 66, 65, 66, 66, 66, -1, 66, 66, 66, 66, 66, 66, 66, 66, 
	66, 66, 66, 66, 66, 66, 66
    };

static const ANTLR3_INT32 dfa4_T438[] =
    {
	739
    };

static const ANTLR3_INT32 dfa4_T439[] =
    {
	445, 374, 740, 446, 372, 741, 373, 374, 740, -1, 374, 374, 374, 374, 374, 
	772, 370, 374, 364, 365, 366, 368, 367, 371, 369
    };

static const ANTLR3_INT32 dfa4_T440[] =
    {
	242, 242, 296, 271, 242, 295, 242, 242, 296, -1, 242, 242, 242, 242, 319, 
	325, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T441[] =
    {
	855
    };

static const ANTLR3_INT32 dfa4_T442[] =
    {
	255, 255, 243, 256, 253, 244, 254, 255, 243, -1, 255, 255, 255, 255, 255, 
	255, 251, 255, 245, 246, 247, 249, 248, 252, 250
    };

static const ANTLR3_INT32 dfa4_T443[] =
    {
	191
    };

static const ANTLR3_INT32 dfa4_T444[] =
    {
	183
    };

static const ANTLR3_INT32 dfa4_T445[] =
    {
	242, 242, 311, 271, 242, 321, 242, 242, 311, -1, 242, 242, 242, 242, 242, 
	326, 242, 242, 242, 242, 242, 242, 242, 242, 242
    };

static const ANTLR3_INT32 dfa4_T446[] =
    {
	242, 242, 497, 504, 439, 505, 440, 242, 497, -1, 242, 242, 242, 242, 242, 
	346, 437, 242, 431, 432, 433, 435, 434, 438, 436
    };

static const ANTLR3_INT32 dfa4_T447[] =
    {
	468, 468, 707, 524, 716, 796, 717, 468, 707, -1, 468, 468, 468, 468, 468, 
	466, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T448[] =
    {
	45, 45, 130, 54, 139, 190, 140, 45, 130, -1, 45, 45, 45, 45, 45, 33, 137, 
	45, 131, 132, 133, 135, 134, 138, 136
    };

static const ANTLR3_INT32 dfa4_T449[] =
    {
	468, 468, 748, 467, 716, 798, 717, 468, 748, -1, 468, 468, 468, 468, 468, 
	468, 714, 468, 708, 709, 710, 712, 711, 715, 713
    };

static const ANTLR3_INT32 dfa4_T450[] =
    {
	468, 468, 526, 524, 468, 617, 468, 468, 526, -1, 468, 468, 468, 468, 468, 
	466, 468, 468, 468, 468, 468, 468, 468, 468, 468
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa4_transitions[] =
{
    dfa4_T318, dfa4_T161, dfa4_T161, dfa4_T337, dfa4_T76, dfa4_T238, NULL, 
    dfa4_T36, dfa4_T76, dfa4_T315, dfa4_T201, dfa4_T140, dfa4_T140, dfa4_T26, 
    dfa4_T57, dfa4_T167, dfa4_T327, dfa4_T325, dfa4_T167, dfa4_T167, dfa4_T167, 
    dfa4_T167, dfa4_T167, dfa4_T329, dfa4_T28, dfa4_T333, dfa4_T28, NULL, 
    dfa4_T31, dfa4_T31, dfa4_T87, dfa4_T347, dfa4_T413, dfa4_T95, dfa4_T124, 
    dfa4_T322, dfa4_T124, dfa4_T124, dfa4_T124, dfa4_T124, dfa4_T124, dfa4_T124, 
    dfa4_T124, dfa4_T124, dfa4_T124, dfa4_T368, dfa4_T64, dfa4_T243, dfa4_T437, 
    dfa4_T300, dfa4_T302, dfa4_T302, dfa4_T95, dfa4_T197, dfa4_T250, dfa4_T152, 
    dfa4_T124, dfa4_T124, dfa4_T99, dfa4_T49, dfa4_T148, dfa4_T191, dfa4_T3, 
    dfa4_T290, dfa4_T99, dfa4_T408, dfa4_T152, dfa4_T236, dfa4_T188, dfa4_T307, 
    dfa4_T333, dfa4_T291, dfa4_T291, dfa4_T90, dfa4_T46, dfa4_T139, dfa4_T183, 
    dfa4_T311, dfa4_T311, dfa4_T333, dfa4_T231, dfa4_T290, dfa4_T163, dfa4_T11, 
    dfa4_T248, dfa4_T189, dfa4_T392, dfa4_T13, dfa4_T14, dfa4_T424, dfa4_T28, 
    dfa4_T141, dfa4_T171, dfa4_T193, dfa4_T351, dfa4_T89, dfa4_T89, dfa4_T89, 
    dfa4_T177, dfa4_T83, dfa4_T342, dfa4_T366, dfa4_T21, dfa4_T21, dfa4_T21, 
    dfa4_T21, dfa4_T287, dfa4_T12, dfa4_T199, dfa4_T99, dfa4_T392, dfa4_T13, 
    dfa4_T89, dfa4_T122, dfa4_T429, dfa4_T169, dfa4_T169, dfa4_T169, dfa4_T169, 
    dfa4_T169, dfa4_T169, dfa4_T169, dfa4_T169, dfa4_T169, dfa4_T169, dfa4_T275, 
    dfa4_T89, dfa4_T89, dfa4_T333, dfa4_T105, dfa4_T175, dfa4_T88, dfa4_T88, 
    dfa4_T88, dfa4_T88, dfa4_T88, dfa4_T88, dfa4_T88, dfa4_T88, dfa4_T88, 
    dfa4_T88, dfa4_T259, dfa4_T357, dfa4_T177, dfa4_T21, dfa4_T21, dfa4_T269, 
    dfa4_T393, dfa4_T55, dfa4_T295, dfa4_T372, dfa4_T372, dfa4_T313, dfa4_T321, 
    dfa4_T122, dfa4_T131, dfa4_T276, dfa4_T213, dfa4_T169, dfa4_T169, dfa4_T281, 
    dfa4_T373, dfa4_T371, dfa4_T444, dfa4_T88, dfa4_T88, dfa4_T70, dfa4_T99, 
    dfa4_T381, dfa4_T55, dfa4_T163, dfa4_T206, dfa4_T288, dfa4_T213, dfa4_T99, 
    dfa4_T336, dfa4_T301, dfa4_T384, dfa4_T448, dfa4_T371, dfa4_T118, dfa4_T443, 
    dfa4_T1, dfa4_T61, dfa4_T230, dfa4_T179, dfa4_T253, dfa4_T406, dfa4_T117, 
    dfa4_T61, dfa4_T247, dfa4_T172, dfa4_T29, dfa4_T385, dfa4_T385, dfa4_T16, 
    dfa4_T16, dfa4_T403, dfa4_T99, dfa4_T382, dfa4_T117, dfa4_T209, dfa4_T117, 
    dfa4_T117, dfa4_T117, dfa4_T117, dfa4_T116, dfa4_T185, dfa4_T185, dfa4_T283, 
    dfa4_T100, dfa4_T442, dfa4_T421, dfa4_T116, dfa4_T233, dfa4_T127, dfa4_T127, 
    dfa4_T127, dfa4_T127, dfa4_T127, dfa4_T127, dfa4_T127, dfa4_T127, dfa4_T127, 
    dfa4_T127, dfa4_T127, dfa4_T221, dfa4_T73, dfa4_T180, dfa4_T414, dfa4_T312, 
    dfa4_T252, dfa4_T252, dfa4_T252, dfa4_T252, dfa4_T252, dfa4_T252, dfa4_T252, 
    dfa4_T252, dfa4_T252, dfa4_T252, dfa4_T245, dfa4_T251, dfa4_T97, dfa4_T263, 
    dfa4_T67, dfa4_T67, dfa4_T67, dfa4_T67, dfa4_T67, dfa4_T67, dfa4_T67, 
    dfa4_T67, dfa4_T67, dfa4_T67, dfa4_T66, dfa4_T359, dfa4_T254, dfa4_T176, 
    dfa4_T127, dfa4_T285, dfa4_T395, dfa4_T249, dfa4_T410, dfa4_T53, dfa4_T285, 
    dfa4_T420, dfa4_T10, dfa4_T344, dfa4_T252, dfa4_T252, dfa4_T234, dfa4_T245, 
    dfa4_T15, dfa4_T354, dfa4_T32, dfa4_T97, dfa4_T306, dfa4_T400, dfa4_T202, 
    dfa4_T67, dfa4_T67, dfa4_T186, dfa4_T28, dfa4_T195, dfa4_T422, dfa4_T132, 
    dfa4_T149, dfa4_T319, dfa4_T418, dfa4_T343, dfa4_T174, dfa4_T10, dfa4_T153, 
    dfa4_T344, dfa4_T440, dfa4_T445, dfa4_T128, dfa4_T128, dfa4_T135, dfa4_T415, 
    dfa4_T202, dfa4_T10, dfa4_T107, dfa4_T25, dfa4_T40, dfa4_T60, dfa4_T60, 
    dfa4_T187, dfa4_T187, dfa4_T296, dfa4_T58, dfa4_T224, dfa4_T149, dfa4_T215, 
    dfa4_T349, dfa4_T228, dfa4_T192, dfa4_T74, dfa4_T427, dfa4_T274, dfa4_T58, 
    dfa4_T78, dfa4_T135, dfa4_T146, dfa4_T24, dfa4_T154, dfa4_T411, dfa4_T282, 
    dfa4_T282, dfa4_T210, dfa4_T308, dfa4_T229, dfa4_T54, dfa4_T25, dfa4_T317, 
    dfa4_T220, dfa4_T260, dfa4_T33, dfa4_T164, dfa4_T237, dfa4_T348, dfa4_T416, 
    dfa4_T244, dfa4_T380, dfa4_T330, dfa4_T232, dfa4_T33, dfa4_T33, dfa4_T33, 
    dfa4_T162, dfa4_T28, dfa4_T396, dfa4_T431, dfa4_T75, dfa4_T164, dfa4_T164, 
    dfa4_T164, dfa4_T147, dfa4_T10, dfa4_T24, dfa4_T154, dfa4_T256, dfa4_T377, 
    dfa4_T217, dfa4_T217, dfa4_T217, dfa4_T217, dfa4_T217, dfa4_T217, dfa4_T217, 
    dfa4_T217, dfa4_T217, dfa4_T217, dfa4_T216, dfa4_T159, dfa4_T72, dfa4_T10, 
    dfa4_T265, dfa4_T229, dfa4_T51, dfa4_T56, dfa4_T229, dfa4_T229, dfa4_T229, 
    dfa4_T229, dfa4_T324, dfa4_T54, dfa4_T54, dfa4_T54, dfa4_T54, dfa4_T54, 
    dfa4_T28, dfa4_T266, dfa4_T426, dfa4_T77, dfa4_T77, dfa4_T77, dfa4_T77, 
    dfa4_T77, dfa4_T77, dfa4_T77, dfa4_T77, dfa4_T77, dfa4_T77, dfa4_T112, 
    dfa4_T326, dfa4_T157, dfa4_T157, dfa4_T157, dfa4_T157, dfa4_T157, dfa4_T157, 
    dfa4_T157, dfa4_T157, dfa4_T157, dfa4_T157, dfa4_T433, dfa4_T33, dfa4_T241, 
    dfa4_T33, dfa4_T164, dfa4_T164, dfa4_T28, dfa4_T151, dfa4_T196, dfa4_T196, 
    dfa4_T130, dfa4_T135, dfa4_T409, dfa4_T446, dfa4_T165, dfa4_T165, dfa4_T165, 
    dfa4_T165, dfa4_T165, dfa4_T165, dfa4_T165, dfa4_T165, dfa4_T165, dfa4_T165, 
    dfa4_T162, dfa4_T45, dfa4_T114, dfa4_T284, dfa4_T18, dfa4_T304, dfa4_T256, 
    dfa4_T399, dfa4_T92, dfa4_T332, dfa4_T217, dfa4_T217, dfa4_T204, dfa4_T103, 
    dfa4_T309, dfa4_T30, dfa4_T30, dfa4_T30, dfa4_T30, dfa4_T30, dfa4_T30, 
    dfa4_T30, dfa4_T30, dfa4_T30, dfa4_T30, dfa4_T94, dfa4_T52, dfa4_T365, 
    dfa4_T324, dfa4_T80, dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T34, 
    dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T34, dfa4_T186, 
    dfa4_T266, dfa4_T27, dfa4_T350, dfa4_T96, dfa4_T77, dfa4_T77, dfa4_T136, 
    dfa4_T112, dfa4_T364, dfa4_T205, dfa4_T157, dfa4_T157, dfa4_T10, dfa4_T262, 
    dfa4_T165, dfa4_T45, dfa4_T215, dfa4_T200, dfa4_T257, dfa4_T137, dfa4_T258, 
    dfa4_T430, dfa4_T165, dfa4_T48, dfa4_T104, dfa4_T332, dfa4_T2, dfa4_T261, 
    dfa4_T22, dfa4_T203, dfa4_T292, dfa4_T292, dfa4_T208, dfa4_T214, dfa4_T391, 
    dfa4_T391, dfa4_T111, dfa4_T362, dfa4_T0, dfa4_T30, dfa4_T30, dfa4_T436, 
    dfa4_T94, dfa4_T194, dfa4_T2, dfa4_T155, dfa4_T34, dfa4_T340, dfa4_T96, 
    dfa4_T204, dfa4_T186, dfa4_T218, dfa4_T205, dfa4_T79, dfa4_T257, dfa4_T419, 
    dfa4_T428, dfa4_T341, dfa4_T375, dfa4_T338, dfa4_T61, dfa4_T230, dfa4_T417, 
    dfa4_T369, dfa4_T369, dfa4_T402, dfa4_T5, dfa4_T113, dfa4_T22, dfa4_T63, 
    dfa4_T425, dfa4_T294, dfa4_T0, dfa4_T2, dfa4_T129, dfa4_T150, dfa4_T160, 
    dfa4_T412, dfa4_T286, dfa4_T106, dfa4_T450, dfa4_T378, dfa4_T120, dfa4_T195, 
    dfa4_T38, dfa4_T303, dfa4_T272, dfa4_T172, dfa4_T358, dfa4_T61, dfa4_T91, 
    dfa4_T86, dfa4_T212, dfa4_T379, dfa4_T5, dfa4_T207, dfa4_T5, dfa4_T5, 
    dfa4_T5, dfa4_T5, dfa4_T108, dfa4_T320, dfa4_T113, dfa4_T113, dfa4_T113, 
    dfa4_T113, dfa4_T113, dfa4_T28, dfa4_T264, dfa4_T125, dfa4_T82, dfa4_T82, 
    dfa4_T82, dfa4_T82, dfa4_T82, dfa4_T82, dfa4_T82, dfa4_T82, dfa4_T82, 
    dfa4_T82, dfa4_T352, dfa4_T394, dfa4_T211, dfa4_T134, dfa4_T198, dfa4_T293, 
    dfa4_T211, dfa4_T316, dfa4_T328, dfa4_T286, dfa4_T158, dfa4_T6, dfa4_T432, 
    dfa4_T386, dfa4_T225, dfa4_T120, dfa4_T93, dfa4_T93, dfa4_T19, dfa4_T186, 
    dfa4_T345, dfa4_T138, dfa4_T20, dfa4_T20, dfa4_T267, dfa4_T39, dfa4_T219, 
    dfa4_T219, dfa4_T219, dfa4_T219, dfa4_T219, dfa4_T219, dfa4_T219, dfa4_T219, 
    dfa4_T219, dfa4_T219, dfa4_T108, dfa4_T226, dfa4_T115, dfa4_T115, dfa4_T115, 
    dfa4_T115, dfa4_T115, dfa4_T115, dfa4_T115, dfa4_T115, dfa4_T115, dfa4_T115, 
    dfa4_T115, dfa4_T19, dfa4_T404, dfa4_T156, dfa4_T264, dfa4_T98, dfa4_T82, 
    dfa4_T82, dfa4_T86, dfa4_T41, dfa4_T299, dfa4_T81, dfa4_T198, dfa4_T346, 
    dfa4_T182, dfa4_T434, dfa4_T41, dfa4_T41, dfa4_T41, dfa4_T170, dfa4_T293, 
    dfa4_T223, dfa4_T299, dfa4_T299, dfa4_T299, dfa4_T356, dfa4_T28, dfa4_T7, 
    dfa4_T407, dfa4_T144, dfa4_T280, dfa4_T323, dfa4_T68, dfa4_T68, dfa4_T438, 
    dfa4_T390, dfa4_T142, dfa4_T267, dfa4_T397, dfa4_T44, dfa4_T334, dfa4_T219, 
    dfa4_T219, dfa4_T363, dfa4_T115, dfa4_T388, dfa4_T98, dfa4_T204, dfa4_T41, 
    dfa4_T353, dfa4_T240, dfa4_T41, dfa4_T299, dfa4_T299, dfa4_T170, dfa4_T101, 
    dfa4_T168, dfa4_T84, dfa4_T84, dfa4_T84, dfa4_T84, dfa4_T84, dfa4_T84, 
    dfa4_T84, dfa4_T84, dfa4_T84, dfa4_T84, dfa4_T255, dfa4_T270, dfa4_T289, 
    dfa4_T37, dfa4_T37, dfa4_T50, dfa4_T268, dfa4_T389, dfa4_T102, dfa4_T401, 
    dfa4_T35, dfa4_T35, dfa4_T35, dfa4_T35, dfa4_T35, dfa4_T35, dfa4_T35, 
    dfa4_T35, dfa4_T35, dfa4_T35, dfa4_T361, dfa4_T28, dfa4_T279, dfa4_T439, 
    dfa4_T190, dfa4_T334, dfa4_T2, dfa4_T195, dfa4_T62, dfa4_T376, dfa4_T84, 
    dfa4_T86, dfa4_T239, dfa4_T84, dfa4_T314, dfa4_T119, dfa4_T119, dfa4_T277, 
    dfa4_T370, dfa4_T367, dfa4_T50, dfa4_T158, dfa4_T398, dfa4_T121, dfa4_T423, 
    dfa4_T65, dfa4_T65, dfa4_T4, dfa4_T35, dfa4_T35, dfa4_T273, dfa4_T47, 
    dfa4_T126, dfa4_T279, dfa4_T271, dfa4_T435, dfa4_T204, dfa4_T61, dfa4_T230, 
    dfa4_T246, dfa4_T178, dfa4_T447, dfa4_T235, dfa4_T449, dfa4_T110, dfa4_T367, 
    dfa4_T222, dfa4_T331, dfa4_T4, dfa4_T2, dfa4_T273, dfa4_T335, dfa4_T143, 
    dfa4_T298, dfa4_T2, dfa4_T123, dfa4_T355, dfa4_T61, dfa4_T242, dfa4_T172, 
    dfa4_T23, dfa4_T374, dfa4_T109, dfa4_T173, dfa4_T143, dfa4_T405, dfa4_T405, 
    dfa4_T297, dfa4_T59, dfa4_T278, dfa4_T2, dfa4_T109, dfa4_T71, dfa4_T109, 
    dfa4_T109, dfa4_T109, dfa4_T109, dfa4_T173, dfa4_T173, dfa4_T173, dfa4_T173, 
    dfa4_T173, dfa4_T305, dfa4_T227, dfa4_T184, dfa4_T43, dfa4_T145, dfa4_T69, 
    dfa4_T204, dfa4_T9, dfa4_T310, dfa4_T387, dfa4_T8, dfa4_T310, dfa4_T42, 
    dfa4_T181, dfa4_T85, dfa4_T17, dfa4_T387, dfa4_T383, dfa4_T166, dfa4_T85, 
    dfa4_T85, dfa4_T85, dfa4_T8, dfa4_T360, dfa4_T17, dfa4_T17, dfa4_T17, 
    dfa4_T133, dfa4_T339, dfa4_T85, dfa4_T441, dfa4_T85, dfa4_T17, dfa4_T17, 
    dfa4_T120, dfa4_T2
};

static ANTLR3_INT32 dfa4_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA4_24;

    	    ANTLR3_MARKER index4_24;


    		LA4_24 = LA(1);

    	     
    	        index4_24 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(b))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_24);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA4_283;

    	    ANTLR3_MARKER index4_283;


    		LA4_283 = LA(1);

    	     
    	        index4_283 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_283);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA4_90;

    	    ANTLR3_MARKER index4_90;


    		LA4_90 = LA(1);

    	     
    	        index4_90 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_90);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA4_590;

    	    ANTLR3_MARKER index4_590;


    		LA4_590 = LA(1);

    	     
    	        index4_590 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_590);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA4_392;

    	    ANTLR3_MARKER index4_392;


    		LA4_392 = LA(1);

    	     
    	        index4_392 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_392);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 5:

    	{
    	    ANTLR3_UINT32 LA4_26;

    	    ANTLR3_MARKER index4_26;


    		LA4_26 = LA(1);

    	     
    	        index4_26 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(c))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_26);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 6:

    	{
    	    ANTLR3_UINT32 LA4_739;

    	    ANTLR3_MARKER index4_739;


    		LA4_739 = LA(1);

    	     
    	        index4_739 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_739);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 7:

    	{
    	    ANTLR3_UINT32 LA4_423;

    	    ANTLR3_MARKER index4_423;


    		LA4_423 = LA(1);

    	     
    	        index4_423 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_423);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 8:

    	{
    	    ANTLR3_UINT32 LA4_677;

    	    ANTLR3_MARKER index4_677;


    		LA4_677 = LA(1);

    	     
    	        index4_677 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_677);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 9:

    	{
    	    ANTLR3_UINT32 LA4_351;

    	    ANTLR3_MARKER index4_351;


    		LA4_351 = LA(1);

    	     
    	        index4_351 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(p))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(t))) )
    	    {
    	        s = 27;
    	    }

    		 
    			SEEK(index4_351);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 111:26: ( phone_field )*";
    EXCEPTION->decisionNum  = 4;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 4
 */
static
ANTLR3_CYCLIC_DFA cdfa4
    =	{
	    4,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 111:26: ( phone_field )*",
	    (CDFA_SPECIAL_FUNC) dfa4_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa4_eot,	    /* EOT table			    */
	    dfa4_eof,	    /* EOF table			    */
	    dfa4_min,	    /* Minimum tokens for each state    */
	    dfa4_max,	    /* Maximum tokens for each state    */
	    dfa4_accept,	/* Accept table			    */
	    dfa4_special,	/* Special transition states	    */
	    dfa4_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 4
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    112:26: ( connection CR LF )?
 */
static const ANTLR3_INT32 dfa5_eot[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa5_eof[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa5_min[11] =
    {
	6, 11, 11, 6, 4, 4, -1, 4, -1, 6, 6
    };
static const ANTLR3_INT32 dfa5_max[11] =
    {
	12, 11, 11, 12, 19, 19, -1, 19, -1, 12, 19
    };
static const ANTLR3_INT32 dfa5_accept[11] =
    {
	-1, -1, -1, -1, -1, -1, 1, -1, 2, -1, -1
    };
static const ANTLR3_INT32 dfa5_special[11] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa5_T_empty	    NULL

static const ANTLR3_INT32 dfa5_T0[] =
    {
	6, -1, -1, 10, -1, -1, 6
    };

static const ANTLR3_INT32 dfa5_T1[] =
    {
	8, -1, 4, -1, -1, 7, -1, -1, 4, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR3_INT32 dfa5_T2[] =
    {
	8, -1, 4, -1, -1, 5, -1, -1, 4, -1, -1, -1, -1, -1, -1, 9
    };

static const ANTLR3_INT32 dfa5_T3[] =
    {
	3
    };

static const ANTLR3_INT32 dfa5_T4[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa5_T5[] =
    {
	6, 8, -1, 10, -1, -1, 6, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR3_INT32 dfa5_T6[] =
    {
	4, -1, -1, 5, -1, -1, 4
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa5_transitions[] =
{
    dfa5_T4, dfa5_T3, dfa5_T3, dfa5_T6, dfa5_T1, dfa5_T2, NULL, dfa5_T1, 
    NULL, dfa5_T0, dfa5_T5
};


/* Declare tracking structure for Cyclic DFA 5
 */
static
ANTLR3_CYCLIC_DFA cdfa5
    =	{
	    5,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"112:26: ( connection CR LF )?",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa5_eot,	    /* EOT table			    */
	    dfa5_eof,	    /* EOF table			    */
	    dfa5_min,	    /* Minimum tokens for each state    */
	    dfa5_max,	    /* Maximum tokens for each state    */
	    dfa5_accept,	/* Accept table			    */
	    dfa5_special,	/* Special transition states	    */
	    dfa5_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 5
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 113:26: ( bandwidth CR LF )*
 */
static const ANTLR3_INT32 dfa6_eot[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa6_eof[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa6_min[7] =
    {
	6, 11, 11, 6, 4, -1, -1
    };
static const ANTLR3_INT32 dfa6_max[7] =
    {
	12, 11, 11, 12, 19, -1, -1
    };
static const ANTLR3_INT32 dfa6_accept[7] =
    {
	-1, -1, -1, -1, -1, 1, 2
    };
static const ANTLR3_INT32 dfa6_special[7] =
    {
	-1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa6_T_empty	    NULL

static const ANTLR3_INT32 dfa6_T0[] =
    {
	5, -1, 5, -1, -1, 4, -1, -1, 5, -1, -1, -1, -1, -1, -1, 6
    };

static const ANTLR3_INT32 dfa6_T1[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa6_T2[] =
    {
	5, -1, -1, 4, -1, -1, 5
    };

static const ANTLR3_INT32 dfa6_T3[] =
    {
	3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa6_transitions[] =
{
    dfa6_T1, dfa6_T3, dfa6_T3, dfa6_T2, dfa6_T0, NULL, NULL
};


/* Declare tracking structure for Cyclic DFA 6
 */
static
ANTLR3_CYCLIC_DFA cdfa6
    =	{
	    6,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 113:26: ( bandwidth CR LF )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa6_eot,	    /* EOT table			    */
	    dfa6_eof,	    /* EOF table			    */
	    dfa6_min,	    /* Minimum tokens for each state    */
	    dfa6_max,	    /* Maximum tokens for each state    */
	    dfa6_accept,	/* Accept table			    */
	    dfa6_special,	/* Special transition states	    */
	    dfa6_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 6
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 115:26: ( repeat_time CR LF )*
 */
static const ANTLR3_INT32 dfa7_eot[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_eof[42] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_min[42] =
    {
	6, 11, 11, -1, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 4, 13, 4, 0, 4, 4, 0, 
	4, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 13, 4, 0, 0, 4
    };
static const ANTLR3_INT32 dfa7_max[42] =
    {
	12, 11, 11, -1, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 28, 28, 13, 28, 
	0, 28, 28, 0, 28, -1, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 
	13, 28, 0, 0, 28
    };
static const ANTLR3_INT32 dfa7_accept[42] =
    {
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa7_special[42] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	3, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, 0, 2, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa7_T_empty	    NULL

static const ANTLR3_INT32 dfa7_T0[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa7_T1[] =
    {
	3, 3, 3, 10, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa7_T2[] =
    {
	3, 3, 31, 36, 3, 30, 3, 3, 31, -1, 3, 3, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T3[] =
    {
	3, 3, 31, 10, 3, 41, 3, 3, 31, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T4[] =
    {
	3, 3, 33, 16, 3, 32, 3, 3, 33, -1, 3, 3, 3, 3, 3, 15, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T5[] =
    {
	3, 3, 25, 10, 3, 24, 3, 3, 25, -1, 3, 3, 3, 3, 3, 29, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T6[] =
    {
	3, 3, 12, 10, 3, 20, 3, 3, 12, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T7[] =
    {
	3, 3, 31, 36, 3, 41, 3, 3, 31, -1, 3, 3, 3, 3, 3, 29, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T8[] =
    {
	3, 3, 12, 10, 3, 17, 3, 3, 12, -1, 3, 3, 3, 3, 3, 22, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T9[] =
    {
	3, 3, 6, 3, 3, 5, 3, 3, 6, -1, 3, 3, 3, 3, 3, 8, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa7_T10[] =
    {
	3, 3, 35, 16, 3, 34, 3, 3, 35, -1, 3, 3, 3, 3, 3, 15, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T11[] =
    {
	4
    };

static const ANTLR3_INT32 dfa7_T12[] =
    {
	3, 3, 6, 3, 3, 5, 3, 3, 6, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa7_T13[] =
    {
	40
    };

static const ANTLR3_INT32 dfa7_T14[] =
    {
	3, 3, 3, 10, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa7_T15[] =
    {
	3, 3, 12, 10, 3, 17, 3, 3, 12, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T16[] =
    {
	39
    };

static const ANTLR3_INT32 dfa7_T17[] =
    {
	3, 3, 25, 10, 3, 28, 3, 3, 25, -1, 3, 3, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T18[] =
    {
	3, 3, 3, 16, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 15, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa7_T19[] =
    {
	3, 3, 14, 16, 3, 13, 3, 3, 14, -1, 3, 3, 3, 3, 3, 19, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T20[] =
    {
	3, 3, 12, 10, 3, 11, 3, 3, 12, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T21[] =
    {
	3, 3, 35, 37, 3, 34, 3, 3, 35, -1, 3, 3, 3, 3, 3, 38, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T22[] =
    {
	21
    };

static const ANTLR3_INT32 dfa7_T23[] =
    {
	3, 3, 3, 37, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 38, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa7_T24[] =
    {
	3, 3, 14, 16, 3, 13, 3, 3, 14, -1, 3, 3, 3, 3, 3, 15, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T25[] =
    {
	3, 3, 25, 10, 3, 24, 3, 3, 25, -1, 3, 3, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T26[] =
    {
	3, 3, 12, 10, 3, 20, 3, 3, 12, -1, 3, 3, 3, 3, 3, 27, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T27[] =
    {
	18
    };

static const ANTLR3_INT32 dfa7_T28[] =
    {
	3, 3, 3, 36, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 26, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa7_T29[] =
    {
	3, 3, 3, 3, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 9, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa7_T30[] =
    {
	3, 3, 31, 10, 3, 30, 3, 3, 31, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa7_T31[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa7_transitions[] =
{
    dfa7_T31, dfa7_T11, dfa7_T11, NULL, dfa7_T12, dfa7_T9, dfa7_T29, dfa7_T20, 
    dfa7_T24, dfa7_T15, dfa7_T27, dfa7_T20, dfa7_T1, dfa7_T19, dfa7_T18, 
    dfa7_T6, dfa7_T22, dfa7_T8, dfa7_T0, dfa7_T25, dfa7_T26, dfa7_T0, dfa7_T17, 
    NULL, dfa7_T5, dfa7_T14, dfa7_T30, dfa7_T4, dfa7_T17, dfa7_T10, dfa7_T2, 
    dfa7_T28, dfa7_T4, dfa7_T18, dfa7_T21, dfa7_T23, dfa7_T16, dfa7_T13, 
    dfa7_T3, dfa7_T0, dfa7_T0, dfa7_T7
};

static ANTLR3_INT32 dfa7_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA7_39;

    	    ANTLR3_MARKER index7_39;


    		LA7_39 = LA(1);

    	     
    	        index7_39 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(r))) )
    	    {
    	        s = 23;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(m))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index7_39);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA7_21;

    	    ANTLR3_MARKER index7_21;


    		LA7_21 = LA(1);

    	     
    	        index7_21 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(r))) )
    	    {
    	        s = 23;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(z))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index7_21);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA7_40;

    	    ANTLR3_MARKER index7_40;


    		LA7_40 = LA(1);

    	     
    	        index7_40 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(r))) )
    	    {
    	        s = 23;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(z)))||((IS_TOKEN(m))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index7_40);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA7_18;

    	    ANTLR3_MARKER index7_18;


    		LA7_18 = LA(1);

    	     
    	        index7_18 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(r))) )
    	    {
    	        s = 23;
    	    }

    	    else if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index7_18);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 115:26: ( repeat_time CR LF )*";
    EXCEPTION->decisionNum  = 7;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 7
 */
static
ANTLR3_CYCLIC_DFA cdfa7
    =	{
	    7,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 115:26: ( repeat_time CR LF )*",
	    (CDFA_SPECIAL_FUNC) dfa7_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa7_eot,	    /* EOT table			    */
	    dfa7_eof,	    /* EOF table			    */
	    dfa7_min,	    /* Minimum tokens for each state    */
	    dfa7_max,	    /* Maximum tokens for each state    */
	    dfa7_accept,	/* Accept table			    */
	    dfa7_special,	/* Special transition states	    */
	    dfa7_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 7
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    116:26: ( zone_adjustments CR LF )?
 */
static const ANTLR3_INT32 dfa8_eot[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa8_eof[31] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa8_min[31] =
    {
	6, 11, 11, -1, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 0, 4, 4, -1, 4, 4, 4, 
	4, 4, 4, 4, 4, 13, 4, 0, 4
    };
static const ANTLR3_INT32 dfa8_max[31] =
    {
	12, 11, 11, -1, 28, 28, 28, 28, 28, 28, 28, 13, 28, 28, 28, 0, 28, 28, 
	-1, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 0, 28
    };
static const ANTLR3_INT32 dfa8_accept[31] =
    {
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa8_special[31] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa8_T_empty	    NULL

static const ANTLR3_INT32 dfa8_T0[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa8_T1[] =
    {
	3, 3, 22, 11, 3, 21, 3, 3, 22, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa8_T2[] =
    {
	3, 3, 9, 11, 3, 12, 3, 3, 9, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T3[] =
    {
	3, 3, 3, 3, 3, 16, 3, 3, 3, -1, 3, 3, 3, 3, 3, 19, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T4[] =
    {
	3, 3, 25, 27, 3, 26, 3, 3, 25, -1, 3, 3, 3, 3, 3, 28, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa8_T5[] =
    {
	3, 3, 3, 3, 3, 30, 3, 3, 3, -1, 3, 3, 3, 3, 3, 19, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T6[] =
    {
	3, 3, 9, 11, 7, 8, 3, 3, 9, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T7[] =
    {
	4
    };

static const ANTLR3_INT32 dfa8_T8[] =
    {
	3, 3, 3, 3, 3, 16, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T9[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa8_T10[] =
    {
	29
    };

static const ANTLR3_INT32 dfa8_T11[] =
    {
	3, 3, 3, 3, 3, 5, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa8_T12[] =
    {
	3, 3, 3, 11, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T13[] =
    {
	15
    };

static const ANTLR3_INT32 dfa8_T14[] =
    {
	3, 3, 3, 27, 3, 3, 3, 3, 3, -1, 3, 3, 3, 3, 3, 28, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T15[] =
    {
	3, 3, 3, 3, 3, 30, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T16[] =
    {
	3, 3, 3, 3, 3, 5, 3, 3, 3, -1, 3, 3, 3, 3, 3, 6, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa8_T17[] =
    {
	3, 3, 25, 27, 3, 24, 3, 3, 25, -1, 3, 3, 3, 3, 3, 28, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa8_T18[] =
    {
	3, 3, 3, 3, 3, 14, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T19[] =
    {
	3, 3, 3, 3, 3, 14, 3, 3, 3, -1, 3, 3, 3, 3, 3, 17, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T20[] =
    {
	3, 3, 9, 11, 3, 8, 3, 3, 9, -1, 3, 3, 3, 3, 3, 13, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa8_T21[] =
    {
	3, 3, 25, 11, 23, 24, 3, 3, 25, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };

static const ANTLR3_INT32 dfa8_T22[] =
    {
	3, 3, 22, 11, 20, 21, 3, 3, 22, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 
	3, 3, 3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa8_transitions[] =
{
    dfa8_T0, dfa8_T7, dfa8_T7, NULL, dfa8_T11, dfa8_T16, dfa8_T6, dfa8_T2, 
    dfa8_T20, dfa8_T12, dfa8_T18, dfa8_T13, dfa8_T2, dfa8_T8, dfa8_T19, 
    dfa8_T9, dfa8_T3, dfa8_T22, NULL, dfa8_T21, dfa8_T1, dfa8_T1, dfa8_T12, 
    dfa8_T4, dfa8_T17, dfa8_T14, dfa8_T4, dfa8_T10, dfa8_T15, dfa8_T9, dfa8_T5
};

static ANTLR3_INT32 dfa8_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA8_29;

    	    ANTLR3_MARKER index8_29;


    		LA8_29 = LA(1);

    	     
    	        index8_29 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(z))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(m))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index8_29);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA8_15;

    	    ANTLR3_MARKER index8_15;


    		LA8_15 = LA(1);

    	     
    	        index8_15 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(z))) )
    	    {
    	        s = 18;
    	    }

    	    else if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index8_15);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"116:26: ( zone_adjustments CR LF )?";
    EXCEPTION->decisionNum  = 8;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 8
 */
static
ANTLR3_CYCLIC_DFA cdfa8
    =	{
	    8,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"116:26: ( zone_adjustments CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa8_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa8_eot,	    /* EOT table			    */
	    dfa8_eof,	    /* EOF table			    */
	    dfa8_min,	    /* Minimum tokens for each state    */
	    dfa8_max,	    /* Maximum tokens for each state    */
	    dfa8_accept,	/* Accept table			    */
	    dfa8_special,	/* Special transition states	    */
	    dfa8_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 8
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    117:26: ( key_field CR LF )?
 */
static const ANTLR3_INT32 dfa9_eot[46] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_eof[46] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_min[46] =
    {
	6, 11, 11, -1, 4, 4, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 
	4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 0
    };
static const ANTLR3_INT32 dfa9_max[46] =
    {
	12, 11, 11, -1, 28, 28, -1, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	13, 28, 28, 28, 28, 0, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 13, 28, 0
    };
static const ANTLR3_INT32 dfa9_accept[46] =
    {
	-1, -1, -1, 2, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa9_special[46] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 0
    };

/** Used when there is no transition table entry for a particular state */
#define dfa9_T_empty	    NULL

static const ANTLR3_INT32 dfa9_T0[] =
    {
	19, 6, 5, 18, 16, 7, 17, 6, 5, -1, 6, 6, 6, 6, 6, 20, 14, 6, 8, 9, 10, 
	12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa9_T1[] =
    {
	29, 29, 29, 6, 29, 29, 29, 29, 29, -1, 29, 29, 29, 29, 29, 30, 29, 29, 
	29, 29, 29, 29, 29, 29, 29
    };

static const ANTLR3_INT32 dfa9_T2[] =
    {
	6, 6, 32, 43, 41, 31, 42, 6, 32, -1, 6, 6, 6, 6, 6, 30, 39, 6, 33, 34, 
	35, 37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa9_T3[] =
    {
	24, 24, 24, 18, 24, 24, 24, 24, 24, -1, 24, 24, 24, 24, 24, 24, 24, 24, 
	24, 24, 24, 24, 24, 24, 24
    };

static const ANTLR3_INT32 dfa9_T4[] =
    {
	6, 6, 6, 6, 6, 25, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa9_T5[] =
    {
	6, 6, 5, 6, 16, 7, 17, 6, 5, -1, 6, 6, 6, 6, 6, 6, 14, 6, 8, 9, 10, 12, 
	11, 15, 13
    };

static const ANTLR3_INT32 dfa9_T6[] =
    {
	19, 6, 21, 18, 16, 22, 17, 6, 21, -1, 6, 6, 6, 6, 6, 6, 14, 6, 8, 9, 10, 
	12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa9_T7[] =
    {
	6, 6, 32, 43, 41, 44, 42, 6, 32, -1, 6, 6, 6, 6, 6, 30, 39, 6, 33, 34, 
	35, 37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa9_T8[] =
    {
	6, 6, 6, 6, 6, 25, 6, 6, 6, -1, 6, 6, 6, 6, 26, 27, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa9_T9[] =
    {
	23
    };

static const ANTLR3_INT32 dfa9_T10[] =
    {
	4
    };

static const ANTLR3_INT32 dfa9_T11[] =
    {
	45
    };

static const ANTLR3_INT32 dfa9_T12[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa9_T13[] =
    {
	6, 6, 6, 6, 6, 28, 6, 6, 6, -1, 6, 6, 6, 6, 6, 27, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa9_T14[] =
    {
	6, 6, 32, 6, 41, 31, 42, 6, 32, -1, 6, 6, 6, 6, 6, 6, 39, 6, 33, 34, 35, 
	37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa9_T15[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa9_T16[] =
    {
	6, 6, 6, 6, 6, 28, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa9_transitions[] =
{
    dfa9_T15, dfa9_T10, dfa9_T10, NULL, dfa9_T5, dfa9_T0, NULL, dfa9_T0, 
    dfa9_T6, dfa9_T6, dfa9_T6, dfa9_T6, dfa9_T6, dfa9_T6, dfa9_T6, dfa9_T6, 
    dfa9_T6, dfa9_T6, dfa9_T9, dfa9_T3, dfa9_T4, dfa9_T6, dfa9_T6, dfa9_T12, 
    dfa9_T3, dfa9_T8, dfa9_T16, dfa9_T1, dfa9_T13, dfa9_T1, dfa9_T14, dfa9_T2, 
    dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T7, 
    dfa9_T7, dfa9_T7, dfa9_T7, dfa9_T11, dfa9_T7, dfa9_T12
};

static ANTLR3_INT32 dfa9_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA9_45;

    	    ANTLR3_MARKER index9_45;


    		LA9_45 = LA(1);

    	     
    	        index9_45 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(m))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index9_45);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA9_23;

    	    ANTLR3_MARKER index9_23;


    		LA9_23 = LA(1);

    	     
    	        index9_23 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(a))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index9_23);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"117:26: ( key_field CR LF )?";
    EXCEPTION->decisionNum  = 9;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 9
 */
static
ANTLR3_CYCLIC_DFA cdfa9
    =	{
	    9,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"117:26: ( key_field CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa9_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa9_eot,	    /* EOT table			    */
	    dfa9_eof,	    /* EOF table			    */
	    dfa9_min,	    /* Minimum tokens for each state    */
	    dfa9_max,	    /* Maximum tokens for each state    */
	    dfa9_accept,	/* Accept table			    */
	    dfa9_special,	/* Special transition states	    */
	    dfa9_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 9
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 118:26: ( attribute CR LF )*
 */
static const ANTLR3_INT32 dfa10_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa10_eof[8] =
    {
	3, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa10_min[8] =
    {
	6, 11, 11, -1, 6, 4, 4, -1
    };
static const ANTLR3_INT32 dfa10_max[8] =
    {
	12, 11, 11, -1, 28, 28, 28, -1
    };
static const ANTLR3_INT32 dfa10_accept[8] =
    {
	-1, -1, -1, 2, -1, -1, -1, 1
    };
static const ANTLR3_INT32 dfa10_special[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa10_T_empty	    NULL

static const ANTLR3_INT32 dfa10_T0[] =
    {
	4
    };

static const ANTLR3_INT32 dfa10_T1[] =
    {
	5, -1, 7, 6, 7, -1, 5, -1, -1, -1, -1, -1, -1, -1, 7, -1, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa10_T2[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa10_T3[] =
    {
	7, -1, 5, 7, 7, 6, 7, -1, 5, -1, -1, -1, -1, -1, -1, 3, 7, -1, 7, 7, 7, 
	7, 7, 7, 7
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa10_transitions[] =
{
    dfa10_T2, dfa10_T0, dfa10_T0, NULL, dfa10_T1, dfa10_T3, dfa10_T3, NULL
};


/* Declare tracking structure for Cyclic DFA 10
 */
static
ANTLR3_CYCLIC_DFA cdfa10
    =	{
	    10,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 118:26: ( attribute CR LF )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa10_eot,	    /* EOT table			    */
	    dfa10_eof,	    /* EOF table			    */
	    dfa10_min,	    /* Minimum tokens for each state    */
	    dfa10_max,	    /* Maximum tokens for each state    */
	    dfa10_accept,	/* Accept table			    */
	    dfa10_special,	/* Special transition states	    */
	    dfa10_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 10
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    342:1: rtcp_fb_param : ( ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );
 */
static const ANTLR3_INT32 dfa36_eot[6] =
    {
	-1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa36_eof[6] =
    {
	-1, 4, 4, -1, -1, -1
    };
static const ANTLR3_INT32 dfa36_min[6] =
    {
	6, 6, 6, 0, -1, -1
    };
static const ANTLR3_INT32 dfa36_max[6] =
    {
	12, 19, 19, 0, -1, -1
    };
static const ANTLR3_INT32 dfa36_accept[6] =
    {
	-1, -1, -1, -1, 2, 1
    };
static const ANTLR3_INT32 dfa36_special[6] =
    {
	-1, 2, 0, 1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa36_T_empty	    NULL

static const ANTLR3_INT32 dfa36_T0[] =
    {
	1, -1, 2, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, 3
    };

static const ANTLR3_INT32 dfa36_T1[] =
    {
	1, -1, 2, -1, -1, -1, 1
    };

static const ANTLR3_INT32 dfa36_T2[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa36_transitions[] =
{
    dfa36_T1, dfa36_T0, dfa36_T0, dfa36_T2, NULL, NULL
};

static ANTLR3_INT32 dfa36_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA36_2;

    	    ANTLR3_MARKER index36_2;


    		LA36_2 = LA(1);

    	     
    	        index36_2 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA36_2 == SPACE) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA36_2 == COMMON_CHAR || LA36_2 == HEX_CHAR) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA36_2 == DASH) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (synpred13_belle_sdp(ctx)) && (LA36_2 == EOF) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index36_2);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA36_3;

    	    ANTLR3_MARKER index36_3;


    		LA36_3 = LA(1);

    	     
    	        index36_3 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (( (( ((IS_TOKEN(app))) && ((IS_TOKEN(app))) )) && (synpred12_belle_sdp(ctx)) )) )
    	    {
    	        s = 5;
    	    }

    	    else if ( (synpred13_belle_sdp(ctx)) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index36_3);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA36_1;

    	    ANTLR3_MARKER index36_1;


    		LA36_1 = LA(1);

    	     
    	        index36_1 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( (LA36_1 == SPACE) )
    	    {
    	        s = 3;
    	    }

    	    else if ( (LA36_1 == COMMON_CHAR || LA36_1 == HEX_CHAR) )
    	    {
    	        s = 1;
    	    }

    	    else if ( (LA36_1 == DASH) )
    	    {
    	        s = 2;
    	    }

    	    else if ( (synpred13_belle_sdp(ctx)) && (LA36_1 == EOF) )
    	    {
    	        s = 4;
    	    }

    		 
    			SEEK(index36_1);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"342:1: rtcp_fb_param : ( ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );";
    EXCEPTION->decisionNum  = 36;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 36
 */
static
ANTLR3_CYCLIC_DFA cdfa36
    =	{
	    36,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"342:1: rtcp_fb_param : ( ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );",
	    (CDFA_SPECIAL_FUNC) dfa36_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa36_eot,	    /* EOT table			    */
	    dfa36_eof,	    /* EOF table			    */
	    dfa36_min,	    /* Minimum tokens for each state    */
	    dfa36_max,	    /* Maximum tokens for each state    */
	    dfa36_accept,	/* Accept table			    */
	    dfa36_special,	/* Special transition states	    */
	    dfa36_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 36
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    394:21: ( info CR LF )?
 */
static const ANTLR3_INT32 dfa41_eot[69] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa41_eof[69] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa41_min[69] =
    {
	6, 11, 11, -1, 4, 4, 13, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 
	0, 4, 4, 4, 0, 4, 4, 4, 4, -1, 4, 4, 4, 4, 13, 13, 4, 4, 4, 4, 4, 4, 4, 
	4, 4, 4, 4, 4, 4, 0, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 0
    };
static const ANTLR3_INT32 dfa41_max[69] =
    {
	12, 11, 11, -1, 28, 28, 13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 13, 28, 28, 0, 28, 28, 28, 0, 28, 28, 28, 28, -1, 28, 28, 28, 28, 13, 
	13, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 0, 0, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 13, 28, 0
    };
static const ANTLR3_INT32 dfa41_accept[69] =
    {
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa41_special[69] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, 2, -1, -1, -1, 0, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 1, 4, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 3
    };

/** Used when there is no transition table entry for a particular state */
#define dfa41_T_empty	    NULL

static const ANTLR3_INT32 dfa41_T0[] =
    {
	30, 30, 30, 19, 30, 29, 30, 30, 30, -1, 30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30
    };

static const ANTLR3_INT32 dfa41_T1[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa41_T2[] =
    {
	18, 18, 27, 6, 18, 28, 18, 18, 27, -1, 18, 18, 18, 18, 35, 34, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T3[] =
    {
	52
    };

static const ANTLR3_INT32 dfa41_T4[] =
    {
	18, 18, 54, 66, 63, 67, 64, 18, 54, -1, 18, 18, 18, 18, 18, 49, 61, 18, 
	55, 56, 57, 59, 58, 62, 60
    };

static const ANTLR3_INT32 dfa41_T5[] =
    {
	46, 48, 43, 37, 47, 44, 45, 48, 43, -1, 48, 48, 48, 48, 48, 49, 48, 48, 
	48, 48, 48, 48, 48, 48, 48
    };

static const ANTLR3_INT32 dfa41_T6[] =
    {
	41, 18, 38, 37, 42, 39, 40, 18, 38, -1, 18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T7[] =
    {
	23, 18, 24, 19, 16, 25, 17, 18, 24, -1, 18, 18, 18, 18, 18, 18, 14, 18, 
	8, 9, 10, 12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa41_T8[] =
    {
	18, 18, 54, 6, 63, 53, 64, 18, 54, -1, 18, 18, 18, 18, 18, 18, 61, 18, 
	55, 56, 57, 59, 58, 62, 60
    };

static const ANTLR3_INT32 dfa41_T9[] =
    {
	18, 18, 5, 6, 16, 7, 17, 18, 5, -1, 18, 18, 18, 18, 18, 18, 14, 18, 8, 
	9, 10, 12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa41_T10[] =
    {
	18, 18, 18, 6, 18, 50, 18, 18, 18, -1, 18, 18, 18, 18, 18, 65, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T11[] =
    {
	30, 30, 30, 36, 30, 29, 30, 30, 30, -1, 30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30
    };

static const ANTLR3_INT32 dfa41_T12[] =
    {
	18, 18, 27, 6, 18, 28, 18, 18, 27, -1, 18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T13[] =
    {
	30, 30, 30, 19, 30, 30, 30, 30, 30, -1, 30, 30, 30, 30, 30, 30, 30, 30, 
	30, 30, 30, 30, 30, 30, 30
    };

static const ANTLR3_INT32 dfa41_T14[] =
    {
	4
    };

static const ANTLR3_INT32 dfa41_T15[] =
    {
	68
    };

static const ANTLR3_INT32 dfa41_T16[] =
    {
	22
    };

static const ANTLR3_INT32 dfa41_T17[] =
    {
	18, 18, 54, 66, 63, 53, 64, 18, 54, -1, 18, 18, 18, 18, 18, 49, 61, 18, 
	55, 56, 57, 59, 58, 62, 60
    };

static const ANTLR3_INT32 dfa41_T18[] =
    {
	48, 48, 48, 6, 48, 48, 48, 48, 48, -1, 48, 48, 48, 48, 48, 49, 48, 48, 
	48, 48, 48, 48, 48, 48, 48
    };

static const ANTLR3_INT32 dfa41_T19[] =
    {
	21, 18, 5, 19, 16, 7, 17, 18, 5, -1, 18, 18, 18, 18, 18, 20, 14, 18, 8, 
	9, 10, 12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa41_T20[] =
    {
	51
    };

static const ANTLR3_INT32 dfa41_T21[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa41_T22[] =
    {
	18, 18, 27, 6, 18, 33, 18, 18, 27, -1, 18, 18, 18, 18, 18, 32, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T23[] =
    {
	18, 18, 18, 6, 18, 50, 18, 18, 18, -1, 18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T24[] =
    {
	18, 18, 18, 6, 18, 18, 18, 18, 18, -1, 18, 18, 18, 18, 18, 18, 18, 18, 
	18, 18, 18, 18, 18, 18, 18
    };

static const ANTLR3_INT32 dfa41_T25[] =
    {
	26
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa41_transitions[] =
{
    dfa41_T21, dfa41_T14, dfa41_T14, NULL, dfa41_T9, dfa41_T19, dfa41_T16, 
    dfa41_T19, dfa41_T7, dfa41_T7, dfa41_T7, dfa41_T7, dfa41_T7, dfa41_T7, 
    dfa41_T7, dfa41_T7, dfa41_T7, dfa41_T7, dfa41_T24, dfa41_T25, dfa41_T12, 
    dfa41_T0, dfa41_T1, dfa41_T13, dfa41_T7, dfa41_T7, dfa41_T1, dfa41_T22, 
    dfa41_T2, dfa41_T11, dfa41_T13, NULL, dfa41_T6, dfa41_T22, dfa41_T5, 
    dfa41_T23, dfa41_T20, dfa41_T3, dfa41_T6, dfa41_T6, dfa41_T6, dfa41_T6, 
    dfa41_T6, dfa41_T5, dfa41_T5, dfa41_T5, dfa41_T5, dfa41_T5, dfa41_T18, 
    dfa41_T8, dfa41_T10, dfa41_T1, dfa41_T1, dfa41_T17, dfa41_T4, dfa41_T4, 
    dfa41_T4, dfa41_T4, dfa41_T4, dfa41_T4, dfa41_T4, dfa41_T4, dfa41_T4, 
    dfa41_T4, dfa41_T4, dfa41_T18, dfa41_T15, dfa41_T4, dfa41_T1
};

static ANTLR3_INT32 dfa41_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA41_26;

    	    ANTLR3_MARKER index41_26;


    		LA41_26 = LA(1);

    	     
    	        index41_26 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(a))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index41_26);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA41_51;

    	    ANTLR3_MARKER index41_51;


    		LA41_51 = LA(1);

    	     
    	        index41_51 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(b)))||((IS_TOKEN(a))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index41_51);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 2:

    	{
    	    ANTLR3_UINT32 LA41_22;

    	    ANTLR3_MARKER index41_22;


    		LA41_22 = LA(1);

    	     
    	        index41_22 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index41_22);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 3:

    	{
    	    ANTLR3_UINT32 LA41_68;

    	    ANTLR3_MARKER index41_68;


    		LA41_68 = LA(1);

    	     
    	        index41_68 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index41_68);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 4:

    	{
    	    ANTLR3_UINT32 LA41_52;

    	    ANTLR3_MARKER index41_52;


    		LA41_52 = LA(1);

    	     
    	        index41_52 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(i))) )
    	    {
    	        s = 31;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(c))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index41_52);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"394:21: ( info CR LF )?";
    EXCEPTION->decisionNum  = 41;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 41
 */
static
ANTLR3_CYCLIC_DFA cdfa41
    =	{
	    41,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"394:21: ( info CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa41_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa41_eot,	    /* EOT table			    */
	    dfa41_eof,	    /* EOF table			    */
	    dfa41_min,	    /* Minimum tokens for each state    */
	    dfa41_max,	    /* Maximum tokens for each state    */
	    dfa41_accept,	/* Accept table			    */
	    dfa41_special,	/* Special transition states	    */
	    dfa41_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 41
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    395:22: ( connection CR LF )?
 */
static const ANTLR3_INT32 dfa42_eot[26] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa42_eof[26] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa42_min[26] =
    {
	6, 11, 11, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 4, 
	4, 0, -1
    };
static const ANTLR3_INT32 dfa42_max[26] =
    {
	12, 11, 11, -1, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	13, 28, 28, 28, 28, 28, 0, -1
    };
static const ANTLR3_INT32 dfa42_accept[26] =
    {
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, 1
    };
static const ANTLR3_INT32 dfa42_special[26] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa42_T_empty	    NULL

static const ANTLR3_INT32 dfa42_T0[] =
    {
	16, 3, 13, 18, 17, 14, 15, 3, 13, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3
    };

static const ANTLR3_INT32 dfa42_T1[] =
    {
	22, 3, 19, 18, 23, 20, 21, 3, 19, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3, 3, 3, 3
    };

static const ANTLR3_INT32 dfa42_T2[] =
    {
	3, 3, 8, 3, 3, 9, 3, 3, 8, -1, 3, 3, 3, 3, 3, 12, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa42_T3[] =
    {
	3, 3, 5, 3, 3, 6, 3, 3, 5, -1, 3, 3, 3, 3, 3, 7, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa42_T4[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa42_T5[] =
    {
	4
    };

static const ANTLR3_INT32 dfa42_T6[] =
    {
	3, 3, 5, 3, 3, 6, 3, 3, 5, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa42_T7[] =
    {
	3, 3, 8, 3, 3, 9, 3, 3, 8, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa42_T8[] =
    {
	3, 3, 8, 3, 3, 11, 3, 3, 8, -1, 3, 3, 3, 3, 3, 10, 3, 3, 3, 3, 3, 3, 3, 
	3, 3
    };

static const ANTLR3_INT32 dfa42_T9[] =
    {
	24
    };

static const ANTLR3_INT32 dfa42_T10[] =
    {
	-1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa42_transitions[] =
{
    dfa42_T4, dfa42_T5, dfa42_T5, NULL, dfa42_T6, dfa42_T3, dfa42_T3, dfa42_T7, 
    dfa42_T8, dfa42_T2, dfa42_T0, dfa42_T8, dfa42_T1, dfa42_T0, dfa42_T0, 
    dfa42_T0, dfa42_T0, dfa42_T0, dfa42_T9, dfa42_T1, dfa42_T1, dfa42_T1, 
    dfa42_T1, dfa42_T1, dfa42_T10, NULL
};

static ANTLR3_INT32 dfa42_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA42_24;

    	    ANTLR3_MARKER index42_24;


    		LA42_24 = LA(1);

    	     
    	        index42_24 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(c))) )
    	    {
    	        s = 25;
    	    }

    	    else if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index42_24);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"395:22: ( connection CR LF )?";
    EXCEPTION->decisionNum  = 42;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 42
 */
static
ANTLR3_CYCLIC_DFA cdfa42
    =	{
	    42,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"395:22: ( connection CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa42_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa42_eot,	    /* EOT table			    */
	    dfa42_eof,	    /* EOF table			    */
	    dfa42_min,	    /* Minimum tokens for each state    */
	    dfa42_max,	    /* Maximum tokens for each state    */
	    dfa42_accept,	/* Accept table			    */
	    dfa42_special,	/* Special transition states	    */
	    dfa42_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 42
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 396:22: ( bandwidth CR LF )*
 */
static const ANTLR3_INT32 dfa43_eot[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa43_eof[12] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa43_min[12] =
    {
	6, 11, 11, -1, 4, 4, 4, 4, 4, 13, 0, -1
    };
static const ANTLR3_INT32 dfa43_max[12] =
    {
	12, 11, 11, -1, 28, 28, 28, 28, 28, 13, 0, -1
    };
static const ANTLR3_INT32 dfa43_accept[12] =
    {
	-1, -1, -1, 2, -1, -1, -1, -1, -1, -1, -1, 1
    };
static const ANTLR3_INT32 dfa43_special[12] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa43_T_empty	    NULL

static const ANTLR3_INT32 dfa43_T0[] =
    {
	7, 3, 5, 3, 3, 6, 3, 3, 5, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa43_T1[] =
    {
	10
    };

static const ANTLR3_INT32 dfa43_T2[] =
    {
	3, 3, 3, 9, 3, 8, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa43_T3[] =
    {
	3, 3, 5, 3, 3, 6, 3, 3, 5, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };

static const ANTLR3_INT32 dfa43_T4[] =
    {
	4
    };

static const ANTLR3_INT32 dfa43_T5[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa43_T6[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa43_T7[] =
    {
	3, 3, 3, 3, 3, 8, 3, 3, 3, -1, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 
	3
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa43_transitions[] =
{
    dfa43_T6, dfa43_T4, dfa43_T4, NULL, dfa43_T3, dfa43_T0, dfa43_T0, dfa43_T7, 
    dfa43_T2, dfa43_T1, dfa43_T5, NULL
};

static ANTLR3_INT32 dfa43_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA43_10;

    	    ANTLR3_MARKER index43_10;


    		LA43_10 = LA(1);

    	     
    	        index43_10 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(b))) )
    	    {
    	        s = 11;
    	    }

    	    else if ( ((((IS_TOKEN(k)))||((IS_TOKEN(a))))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index43_10);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"()* loopback of 396:22: ( bandwidth CR LF )*";
    EXCEPTION->decisionNum  = 43;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 43
 */
static
ANTLR3_CYCLIC_DFA cdfa43
    =	{
	    43,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 396:22: ( bandwidth CR LF )*",
	    (CDFA_SPECIAL_FUNC) dfa43_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa43_eot,	    /* EOT table			    */
	    dfa43_eof,	    /* EOF table			    */
	    dfa43_min,	    /* Minimum tokens for each state    */
	    dfa43_max,	    /* Maximum tokens for each state    */
	    dfa43_accept,	/* Accept table			    */
	    dfa43_special,	/* Special transition states	    */
	    dfa43_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 43
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    397:22: ( key_field CR LF )?
 */
static const ANTLR3_INT32 dfa44_eot[46] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_eof[46] =
    {
	3, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_min[46] =
    {
	6, 11, 11, -1, 4, 4, -1, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 4, 4, 
	4, 0, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 13, 4, 0
    };
static const ANTLR3_INT32 dfa44_max[46] =
    {
	12, 11, 11, -1, 28, 28, -1, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	13, 28, 28, 28, 28, 0, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 
	28, 28, 28, 28, 28, 28, 28, 13, 28, 0
    };
static const ANTLR3_INT32 dfa44_accept[46] =
    {
	-1, -1, -1, 2, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa44_special[46] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, 1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 
	-1, -1, -1, -1, -1, -1, -1, -1, -1, 0
    };

/** Used when there is no transition table entry for a particular state */
#define dfa44_T_empty	    NULL

static const ANTLR3_INT32 dfa44_T0[] =
    {
	6, 6, 32, 43, 41, 44, 42, 6, 32, -1, 6, 6, 6, 6, 6, 30, 39, 6, 33, 34, 
	35, 37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa44_T1[] =
    {
	24, 24, 24, 18, 24, 24, 24, 24, 24, -1, 24, 24, 24, 24, 24, 24, 24, 24, 
	24, 24, 24, 24, 24, 24, 24
    };

static const ANTLR3_INT32 dfa44_T2[] =
    {
	6, 6, 6, 6, 6, 28, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa44_T3[] =
    {
	19, 6, 21, 18, 16, 22, 17, 6, 21, -1, 6, 6, 6, 6, 6, 6, 14, 6, 8, 9, 10, 
	12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa44_T4[] =
    {
	29, 29, 29, 6, 29, 29, 29, 29, 29, -1, 29, 29, 29, 29, 29, 30, 29, 29, 
	29, 29, 29, 29, 29, 29, 29
    };

static const ANTLR3_INT32 dfa44_T5[] =
    {
	19, 6, 5, 18, 16, 7, 17, 6, 5, -1, 6, 6, 6, 6, 6, 20, 14, 6, 8, 9, 10, 
	12, 11, 15, 13
    };

static const ANTLR3_INT32 dfa44_T6[] =
    {
	6, 6, 32, 43, 41, 31, 42, 6, 32, -1, 6, 6, 6, 6, 6, 30, 39, 6, 33, 34, 
	35, 37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa44_T7[] =
    {
	6, 6, 6, 6, 6, 25, 6, 6, 6, -1, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa44_T8[] =
    {
	6, 6, 5, 6, 16, 7, 17, 6, 5, -1, 6, 6, 6, 6, 6, 6, 14, 6, 8, 9, 10, 12, 
	11, 15, 13
    };

static const ANTLR3_INT32 dfa44_T9[] =
    {
	4
    };

static const ANTLR3_INT32 dfa44_T10[] =
    {
	-1
    };

static const ANTLR3_INT32 dfa44_T11[] =
    {
	6, 6, 6, 6, 6, 25, 6, 6, 6, -1, 6, 6, 6, 6, 26, 27, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa44_T12[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa44_T13[] =
    {
	45
    };

static const ANTLR3_INT32 dfa44_T14[] =
    {
	6, 6, 6, 6, 6, 28, 6, 6, 6, -1, 6, 6, 6, 6, 6, 27, 6, 6, 6, 6, 6, 6, 6, 
	6, 6
    };

static const ANTLR3_INT32 dfa44_T15[] =
    {
	6, 6, 32, 6, 41, 31, 42, 6, 32, -1, 6, 6, 6, 6, 6, 6, 39, 6, 33, 34, 35, 
	37, 36, 40, 38
    };

static const ANTLR3_INT32 dfa44_T16[] =
    {
	23
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa44_transitions[] =
{
    dfa44_T12, dfa44_T9, dfa44_T9, NULL, dfa44_T8, dfa44_T5, NULL, dfa44_T5, 
    dfa44_T3, dfa44_T3, dfa44_T3, dfa44_T3, dfa44_T3, dfa44_T3, dfa44_T3, 
    dfa44_T3, dfa44_T3, dfa44_T3, dfa44_T16, dfa44_T1, dfa44_T7, dfa44_T3, 
    dfa44_T3, dfa44_T10, dfa44_T1, dfa44_T11, dfa44_T2, dfa44_T4, dfa44_T14, 
    dfa44_T4, dfa44_T15, dfa44_T6, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, 
    dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, dfa44_T0, 
    dfa44_T13, dfa44_T0, dfa44_T10
};

static ANTLR3_INT32 dfa44_sst(pbelle_sdpParser ctx, pANTLR3_BASE_RECOGNIZER recognizer, pANTLR3_INT_STREAM is, pANTLR3_CYCLIC_DFA dfa, ANTLR3_INT32 s)
{
    ANTLR3_INT32    _s;

    _s	    = s;
    switch  (s)
    {
        case 0:

    	{
    	    ANTLR3_UINT32 LA44_45;

    	    ANTLR3_MARKER index44_45;


    		LA44_45 = LA(1);

    	     
    	        index44_45 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( (ANTLR3_TRUE) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index44_45);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;

        case 1:

    	{
    	    ANTLR3_UINT32 LA44_23;

    	    ANTLR3_MARKER index44_23;


    		LA44_23 = LA(1);

    	     
    	        index44_23 = INDEX();

    	        REWINDLAST();

    	    s = -1;
    	    if ( ((IS_TOKEN(k))) )
    	    {
    	        s = 6;
    	    }

    	    else if ( ((IS_TOKEN(a))) )
    	    {
    	        s = 3;
    	    }

    		 
    			SEEK(index44_23);

    	    if ( s>=0 )
    	    {
    		return s;
    	    }
    	}
    	break;
    }
    if (BACKTRACKING > 0)
    {
	FAILEDFLAG = ANTLR3_TRUE;
	return	-1;
    }

    CONSTRUCTEX();
    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
    EXCEPTION->message      = (void *)"397:22: ( key_field CR LF )?";
    EXCEPTION->decisionNum  = 44;
    EXCEPTION->state        = _s;
    return -1;
}


/* Declare tracking structure for Cyclic DFA 44
 */
static
ANTLR3_CYCLIC_DFA cdfa44
    =	{
	    44,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"397:22: ( key_field CR LF )?",
	    (CDFA_SPECIAL_FUNC) dfa44_sst,
	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa44_eot,	    /* EOT table			    */
	    dfa44_eof,	    /* EOF table			    */
	    dfa44_min,	    /* Minimum tokens for each state    */
	    dfa44_max,	    /* Maximum tokens for each state    */
	    dfa44_accept,	/* Accept table			    */
	    dfa44_special,	/* Special transition states	    */
	    dfa44_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 44
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 398:22: ( attribute CR LF )*
 */
static const ANTLR3_INT32 dfa45_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa45_eof[8] =
    {
	1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa45_min[8] =
    {
	6, -1, 11, 11, 6, 4, 4, -1
    };
static const ANTLR3_INT32 dfa45_max[8] =
    {
	12, -1, 11, 11, 28, 28, 28, -1
    };
static const ANTLR3_INT32 dfa45_accept[8] =
    {
	-1, 2, -1, -1, -1, -1, -1, 1
    };
static const ANTLR3_INT32 dfa45_special[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa45_T_empty	    NULL

static const ANTLR3_INT32 dfa45_T0[] =
    {
	7, -1, 5, 7, 7, 6, 7, -1, 5, -1, -1, -1, -1, -1, -1, 1, 7, -1, 7, 7, 7, 
	7, 7, 7, 7
    };

static const ANTLR3_INT32 dfa45_T1[] =
    {
	4
    };

static const ANTLR3_INT32 dfa45_T2[] =
    {
	5, -1, 7, 6, 7, -1, 5, -1, -1, -1, -1, -1, -1, -1, 7, -1, 7, 7, 7, 7, 7, 
	7, 7
    };

static const ANTLR3_INT32 dfa45_T3[] =
    {
	2, -1, -1, 3, -1, -1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa45_transitions[] =
{
    dfa45_T3, NULL, dfa45_T1, dfa45_T1, dfa45_T2, dfa45_T0, dfa45_T0, NULL
};


/* Declare tracking structure for Cyclic DFA 45
 */
static
ANTLR3_CYCLIC_DFA cdfa45
    =	{
	    45,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 398:22: ( attribute CR LF )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa45_eot,	    /* EOT table			    */
	    dfa45_eof,	    /* EOF table			    */
	    dfa45_min,	    /* Minimum tokens for each state    */
	    dfa45_max,	    /* Maximum tokens for each state    */
	    dfa45_accept,	/* Accept table			    */
	    dfa45_special,	/* Special transition states	    */
	    dfa45_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 45
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 516:17: ( domainlabel DOT )*
 */
static const ANTLR3_INT32 dfa67_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa67_eof[8] =
    {
	-1, 4, -1, 4, -1, 4, 4, -1
    };
static const ANTLR3_INT32 dfa67_min[8] =
    {
	6, 6, -1, 6, -1, 6, 6, 6
    };
static const ANTLR3_INT32 dfa67_max[8] =
    {
	12, 12, -1, 12, -1, 12, 12, 12
    };
static const ANTLR3_INT32 dfa67_accept[8] =
    {
	-1, -1, 1, -1, 2, -1, -1, -1
    };
static const ANTLR3_INT32 dfa67_special[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa67_T_empty	    NULL

static const ANTLR3_INT32 dfa67_T0[] =
    {
	5, -1, 7, 6, 3, -1, 5
    };

static const ANTLR3_INT32 dfa67_T1[] =
    {
	5, -1, 7, 6, -1, -1, 5
    };

static const ANTLR3_INT32 dfa67_T2[] =
    {
	1, -1, -1, 2, -1, -1, 1
    };

static const ANTLR3_INT32 dfa67_T3[] =
    {
	2, -1, -1, 2, -1, -1, 2
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa67_transitions[] =
{
    dfa67_T2, dfa67_T0, NULL, dfa67_T3, NULL, dfa67_T0, dfa67_T0, dfa67_T1
};


/* Declare tracking structure for Cyclic DFA 67
 */
static
ANTLR3_CYCLIC_DFA cdfa67
    =	{
	    67,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 516:17: ( domainlabel DOT )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa67_eot,	    /* EOT table			    */
	    dfa67_eof,	    /* EOF table			    */
	    dfa67_min,	    /* Minimum tokens for each state    */
	    dfa67_max,	    /* Maximum tokens for each state    */
	    dfa67_accept,	/* Accept table			    */
	    dfa67_special,	/* Special transition states	    */
	    dfa67_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 67
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    531:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );
 */
static const ANTLR3_INT32 dfa77_eot[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa77_eof[8] =
    {
	-1, 4, -1, -1, -1, -1, 4, 4
    };
static const ANTLR3_INT32 dfa77_min[8] =
    {
	4, 4, -1, 4, -1, -1, 4, 4
    };
static const ANTLR3_INT32 dfa77_max[8] =
    {
	12, 12, -1, 12, -1, -1, 12, 12
    };
static const ANTLR3_INT32 dfa77_accept[8] =
    {
	-1, -1, 3, -1, 1, 2, -1, -1
    };
static const ANTLR3_INT32 dfa77_special[8] =
    {
	-1, -1, -1, -1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa77_T_empty	    NULL

static const ANTLR3_INT32 dfa77_T0[] =
    {
	5, -1, -1, -1, -1, 6, -1, -1, 7
    };

static const ANTLR3_INT32 dfa77_T1[] =
    {
	3, -1, -1, -1, -1, 7, -1, -1, 7
    };

static const ANTLR3_INT32 dfa77_T2[] =
    {
	3, -1, -1, -1, -1, 6, 4, -1, 7
    };

static const ANTLR3_INT32 dfa77_T3[] =
    {
	2, -1, -1, -1, -1, 1, -1, -1, 1
    };

static const ANTLR3_INT32 dfa77_T4[] =
    {
	3, -1, -1, -1, -1, 1, -1, -1, 1
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa77_transitions[] =
{
    dfa77_T3, dfa77_T4, NULL, dfa77_T0, NULL, NULL, dfa77_T2, dfa77_T1
};


/* Declare tracking structure for Cyclic DFA 77
 */
static
ANTLR3_CYCLIC_DFA cdfa77
    =	{
	    77,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"531:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa77_eot,	    /* EOT table			    */
	    dfa77_eof,	    /* EOF table			    */
	    dfa77_min,	    /* Minimum tokens for each state    */
	    dfa77_max,	    /* Maximum tokens for each state    */
	    dfa77_accept,	/* Accept table			    */
	    dfa77_special,	/* Special transition states	    */
	    dfa77_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 77
 * ---------------------
 *//** Static dfa state tables for Cyclic dfa:
 *    ()* loopback of 532:24: ( COLON hex4 )*
 */
static const ANTLR3_INT32 dfa78_eot[5] =
    {
	-1, -1, -1, -1, -1
    };
static const ANTLR3_INT32 dfa78_eof[5] =
    {
	2, -1, -1, 4, -1
    };
static const ANTLR3_INT32 dfa78_min[5] =
    {
	4, 4, -1, 4, -1
    };
static const ANTLR3_INT32 dfa78_max[5] =
    {
	4, 12, -1, 12, -1
    };
static const ANTLR3_INT32 dfa78_accept[5] =
    {
	-1, -1, 2, -1, 1
    };
static const ANTLR3_INT32 dfa78_special[5] =
    {
	-1, -1, -1, -1, -1
    };

/** Used when there is no transition table entry for a particular state */
#define dfa78_T_empty	    NULL

static const ANTLR3_INT32 dfa78_T0[] =
    {
	1
    };

static const ANTLR3_INT32 dfa78_T1[] =
    {
	2, -1, -1, -1, -1, 3, -1, -1, 4
    };

static const ANTLR3_INT32 dfa78_T2[] =
    {
	4, -1, -1, -1, -1, 3, 2, -1, 4
    };


/* Transition tables are a table of sub tables, with some tables
 * reused for efficiency.
 */
static const ANTLR3_INT32 * const dfa78_transitions[] =
{
    dfa78_T0, dfa78_T1, NULL, dfa78_T2, NULL
};


/* Declare tracking structure for Cyclic DFA 78
 */
static
ANTLR3_CYCLIC_DFA cdfa78
    =	{
	    78,		    /* Decision number of this dfa	    */
	    /* Which decision this represents:   */
	    (const pANTLR3_UCHAR)"()* loopback of 532:24: ( COLON hex4 )*",
	    (CDFA_SPECIAL_FUNC) antlr3dfaspecialStateTransition,	/* Default special state transition function	*/

	    antlr3dfaspecialTransition,		/* DFA specialTransition is currently just a default function in the runtime */
	    antlr3dfapredict,			/* DFA simulator function is in the runtime */
	    dfa78_eot,	    /* EOT table			    */
	    dfa78_eof,	    /* EOF table			    */
	    dfa78_min,	    /* Minimum tokens for each state    */
	    dfa78_max,	    /* Maximum tokens for each state    */
	    dfa78_accept,	/* Accept table			    */
	    dfa78_special,	/* Special transition states	    */
	    dfa78_transitions	/* Table of transition tables	    */

	};
/* End of Cyclic DFA 78
 * ---------------------
 */ 
/* =========================================================================
 * End of DFA tables for the parser
 */

/* ==============================================
 * Parsing rules
 */
/**
 * $ANTLR start session_description
 * belle_sdp.g:102:1: session_description returns [belle_sdp_session_description_t* ret] : version CR LF origin CR LF session_name CR LF ( info CR LF )? ( uri_field CR LF )? ( email CR LF )* ( phone_field )* ( connection CR LF )? ( bandwidth CR LF )* time_field CR LF ( repeat_time CR LF )* ( zone_adjustments CR LF )? ( key_field CR LF )? ( attribute CR LF )* ( media_description )* ;
 */
static belle_sdpParser_session_description_return
session_description(pbelle_sdpParser ctx)
{
    belle_sdpParser_session_description_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CR2;
    pANTLR3_COMMON_TOKEN    LF3;
    pANTLR3_COMMON_TOKEN    CR5;
    pANTLR3_COMMON_TOKEN    LF6;
    pANTLR3_COMMON_TOKEN    CR8;
    pANTLR3_COMMON_TOKEN    LF9;
    pANTLR3_COMMON_TOKEN    CR11;
    pANTLR3_COMMON_TOKEN    LF12;
    pANTLR3_COMMON_TOKEN    CR14;
    pANTLR3_COMMON_TOKEN    LF15;
    pANTLR3_COMMON_TOKEN    CR17;
    pANTLR3_COMMON_TOKEN    LF18;
    pANTLR3_COMMON_TOKEN    CR21;
    pANTLR3_COMMON_TOKEN    LF22;
    pANTLR3_COMMON_TOKEN    CR24;
    pANTLR3_COMMON_TOKEN    LF25;
    pANTLR3_COMMON_TOKEN    CR27;
    pANTLR3_COMMON_TOKEN    LF28;
    pANTLR3_COMMON_TOKEN    CR30;
    pANTLR3_COMMON_TOKEN    LF31;
    pANTLR3_COMMON_TOKEN    CR33;
    pANTLR3_COMMON_TOKEN    LF34;
    pANTLR3_COMMON_TOKEN    CR36;
    pANTLR3_COMMON_TOKEN    LF37;
    pANTLR3_COMMON_TOKEN    CR39;
    pANTLR3_COMMON_TOKEN    LF40;
    belle_sdpParser_version_return version1;
    #undef	RETURN_TYPE_version1
    #define	RETURN_TYPE_version1 belle_sdpParser_version_return

    belle_sdpParser_origin_return origin4;
    #undef	RETURN_TYPE_origin4
    #define	RETURN_TYPE_origin4 belle_sdpParser_origin_return

    belle_sdpParser_session_name_return session_name7;
    #undef	RETURN_TYPE_session_name7
    #define	RETURN_TYPE_session_name7 belle_sdpParser_session_name_return

    belle_sdpParser_info_return info10;
    #undef	RETURN_TYPE_info10
    #define	RETURN_TYPE_info10 belle_sdpParser_info_return

    belle_sdpParser_uri_field_return uri_field13;
    #undef	RETURN_TYPE_uri_field13
    #define	RETURN_TYPE_uri_field13 belle_sdpParser_uri_field_return

    belle_sdpParser_email_return email16;
    #undef	RETURN_TYPE_email16
    #define	RETURN_TYPE_email16 belle_sdpParser_email_return

    belle_sdpParser_phone_field_return phone_field19;
    #undef	RETURN_TYPE_phone_field19
    #define	RETURN_TYPE_phone_field19 belle_sdpParser_phone_field_return

    belle_sdpParser_connection_return connection20;
    #undef	RETURN_TYPE_connection20
    #define	RETURN_TYPE_connection20 belle_sdpParser_connection_return

    belle_sdpParser_bandwidth_return bandwidth23;
    #undef	RETURN_TYPE_bandwidth23
    #define	RETURN_TYPE_bandwidth23 belle_sdpParser_bandwidth_return

    belle_sdpParser_time_field_return time_field26;
    #undef	RETURN_TYPE_time_field26
    #define	RETURN_TYPE_time_field26 belle_sdpParser_time_field_return

    belle_sdpParser_repeat_time_return repeat_time29;
    #undef	RETURN_TYPE_repeat_time29
    #define	RETURN_TYPE_repeat_time29 belle_sdpParser_repeat_time_return

    belle_sdpParser_zone_adjustments_return zone_adjustments32;
    #undef	RETURN_TYPE_zone_adjustments32
    #define	RETURN_TYPE_zone_adjustments32 belle_sdpParser_zone_adjustments_return

    belle_sdpParser_key_field_return key_field35;
    #undef	RETURN_TYPE_key_field35
    #define	RETURN_TYPE_key_field35 belle_sdpParser_key_field_return

    belle_sdpParser_attribute_return attribute38;
    #undef	RETURN_TYPE_attribute38
    #define	RETURN_TYPE_attribute38 belle_sdpParser_attribute_return

    belle_sdpParser_media_description_return media_description41;
    #undef	RETURN_TYPE_media_description41
    #define	RETURN_TYPE_media_description41 belle_sdpParser_media_description_return

    pANTLR3_BASE_TREE CR2_tree;
    pANTLR3_BASE_TREE LF3_tree;
    pANTLR3_BASE_TREE CR5_tree;
    pANTLR3_BASE_TREE LF6_tree;
    pANTLR3_BASE_TREE CR8_tree;
    pANTLR3_BASE_TREE LF9_tree;
    pANTLR3_BASE_TREE CR11_tree;
    pANTLR3_BASE_TREE LF12_tree;
    pANTLR3_BASE_TREE CR14_tree;
    pANTLR3_BASE_TREE LF15_tree;
    pANTLR3_BASE_TREE CR17_tree;
    pANTLR3_BASE_TREE LF18_tree;
    pANTLR3_BASE_TREE CR21_tree;
    pANTLR3_BASE_TREE LF22_tree;
    pANTLR3_BASE_TREE CR24_tree;
    pANTLR3_BASE_TREE LF25_tree;
    pANTLR3_BASE_TREE CR27_tree;
    pANTLR3_BASE_TREE LF28_tree;
    pANTLR3_BASE_TREE CR30_tree;
    pANTLR3_BASE_TREE LF31_tree;
    pANTLR3_BASE_TREE CR33_tree;
    pANTLR3_BASE_TREE LF34_tree;
    pANTLR3_BASE_TREE CR36_tree;
    pANTLR3_BASE_TREE LF37_tree;
    pANTLR3_BASE_TREE CR39_tree;
    pANTLR3_BASE_TREE LF40_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_session_descriptionTop = pbelle_sdpParser_session_descriptionPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(session_description))->current= belle_sdp_session_description_new(); 
    retval.ret=(SCOPE_TOP(session_description))->current;
     
    CR2       = NULL;
    LF3       = NULL;
    CR5       = NULL;
    LF6       = NULL;
    CR8       = NULL;
    LF9       = NULL;
    CR11       = NULL;
    LF12       = NULL;
    CR14       = NULL;
    LF15       = NULL;
    CR17       = NULL;
    LF18       = NULL;
    CR21       = NULL;
    LF22       = NULL;
    CR24       = NULL;
    LF25       = NULL;
    CR27       = NULL;
    LF28       = NULL;
    CR30       = NULL;
    LF31       = NULL;
    CR33       = NULL;
    LF34       = NULL;
    CR36       = NULL;
    LF37       = NULL;
    CR39       = NULL;
    LF40       = NULL;
    version1.tree = NULL;

    origin4.tree = NULL;

    session_name7.tree = NULL;

    info10.tree = NULL;

    uri_field13.tree = NULL;

    email16.tree = NULL;

    phone_field19.tree = NULL;

    connection20.tree = NULL;

    bandwidth23.tree = NULL;

    time_field26.tree = NULL;

    repeat_time29.tree = NULL;

    zone_adjustments32.tree = NULL;

    key_field35.tree = NULL;

    attribute38.tree = NULL;

    media_description41.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    CR2_tree   = NULL;
    LF3_tree   = NULL;
    CR5_tree   = NULL;
    LF6_tree   = NULL;
    CR8_tree   = NULL;
    LF9_tree   = NULL;
    CR11_tree   = NULL;
    LF12_tree   = NULL;
    CR14_tree   = NULL;
    LF15_tree   = NULL;
    CR17_tree   = NULL;
    LF18_tree   = NULL;
    CR21_tree   = NULL;
    LF22_tree   = NULL;
    CR24_tree   = NULL;
    LF25_tree   = NULL;
    CR27_tree   = NULL;
    LF28_tree   = NULL;
    CR30_tree   = NULL;
    LF31_tree   = NULL;
    CR33_tree   = NULL;
    LF34_tree   = NULL;
    CR36_tree   = NULL;
    LF37_tree   = NULL;
    CR39_tree   = NULL;
    LF40_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:105:21: ( version CR LF origin CR LF session_name CR LF ( info CR LF )? ( uri_field CR LF )? ( email CR LF )* ( phone_field )* ( connection CR LF )? ( bandwidth CR LF )* time_field CR LF ( repeat_time CR LF )* ( zone_adjustments CR LF )? ( key_field CR LF )? ( attribute CR LF )* ( media_description )* )
        // belle_sdp.g:105:26: version CR LF origin CR LF session_name CR LF ( info CR LF )? ( uri_field CR LF )? ( email CR LF )* ( phone_field )* ( connection CR LF )? ( bandwidth CR LF )* time_field CR LF ( repeat_time CR LF )* ( zone_adjustments CR LF )? ( key_field CR LF )? ( attribute CR LF )* ( media_description )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_version_in_session_description109);
            version1=version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, version1.tree);

            CR2 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description111);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR2));
            ADAPTOR->addChild(ADAPTOR, root_0, CR2_tree);
            }

            LF3 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description113);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF3_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF3));
            ADAPTOR->addChild(ADAPTOR, root_0, LF3_tree);
            }

            FOLLOWPUSH(FOLLOW_origin_in_session_description140);
            origin4=origin(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, origin4.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_session_description_set_origin((SCOPE_TOP(session_description))->current,
                origin4.ret
                );
            }


            CR5 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description143);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR5_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR5));
            ADAPTOR->addChild(ADAPTOR, root_0, CR5_tree);
            }

            LF6 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description145);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF6_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF6));
            ADAPTOR->addChild(ADAPTOR, root_0, LF6_tree);
            }

            FOLLOWPUSH(FOLLOW_session_name_in_session_description172);
            session_name7=session_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, session_name7.tree);

            CR8 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description174);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR8_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR8));
            ADAPTOR->addChild(ADAPTOR, root_0, CR8_tree);
            }

            LF9 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description176);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF9_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF9));
            ADAPTOR->addChild(ADAPTOR, root_0, LF9_tree);
            }

            // belle_sdp.g:108:26: ( info CR LF )?
            {
                int alt1=2;
                alt1 = cdfa1.predict(ctx, RECOGNIZER, ISTREAM, &cdfa1);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt1)
                {
            	case 1:
            	    // belle_sdp.g:108:27: info CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_info_in_session_description204);
            	        info10=info(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, info10.tree);

            	        CR11 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description206);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR11_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR11));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR11_tree);
            	        }

            	        LF12 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description208);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF12_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF12));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF12_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:109:26: ( uri_field CR LF )?
            {
                int alt2=2;
                alt2 = cdfa2.predict(ctx, RECOGNIZER, ISTREAM, &cdfa2);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt2)
                {
            	case 1:
            	    // belle_sdp.g:109:27: uri_field CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_uri_field_in_session_description238);
            	        uri_field13=uri_field(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, uri_field13.tree);

            	        CR14 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description240);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR14_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR14));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR14_tree);
            	        }

            	        LF15 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description242);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF15_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF15));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF15_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:110:26: ( email CR LF )*

            for (;;)
            {
                int alt3=2;
                alt3 = cdfa3.predict(ctx, RECOGNIZER, ISTREAM, &cdfa3);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt3)
                {
            	case 1:
            	    // belle_sdp.g:110:27: email CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_email_in_session_description272);
            	        email16=email(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, email16.tree);

            	        CR17 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description274);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR17_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR17));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR17_tree);
            	        }

            	        LF18 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description276);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF18_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF18));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF18_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop3;	/* break out of the loop */
            	    break;
                }
            }
            loop3: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:111:26: ( phone_field )*

            for (;;)
            {
                int alt4=2;
                alt4 = cdfa4.predict(ctx, RECOGNIZER, ISTREAM, &cdfa4);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt4)
                {
            	case 1:
            	    // belle_sdp.g:111:26: phone_field
            	    {
            	        FOLLOWPUSH(FOLLOW_phone_field_in_session_description305);
            	        phone_field19=phone_field(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, phone_field19.tree);

            	    }
            	    break;

            	default:
            	    goto loop4;	/* break out of the loop */
            	    break;
                }
            }
            loop4: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:112:26: ( connection CR LF )?
            {
                int alt5=2;
                alt5 = cdfa5.predict(ctx, RECOGNIZER, ISTREAM, &cdfa5);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt5)
                {
            	case 1:
            	    // belle_sdp.g:112:27: connection CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_connection_in_session_description334);
            	        connection20=connection(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, connection20.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_session_description_set_connection((SCOPE_TOP(session_description))->current,
            	            connection20.ret
            	            );
            	        }


            	        CR21 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description338);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR21_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR21));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR21_tree);
            	        }

            	        LF22 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description340);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF22_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF22));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF22_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:113:26: ( bandwidth CR LF )*

            for (;;)
            {
                int alt6=2;
                alt6 = cdfa6.predict(ctx, RECOGNIZER, ISTREAM, &cdfa6);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt6)
                {
            	case 1:
            	    // belle_sdp.g:113:27: bandwidth CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_bandwidth_in_session_description370);
            	        bandwidth23=bandwidth(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bandwidth23.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_session_description_add_bandwidth((SCOPE_TOP(session_description))->current,
            	            bandwidth23.ret
            	            );
            	        }


            	        CR24 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description374);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR24_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR24));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR24_tree);
            	        }

            	        LF25 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description376);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF25_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF25));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF25_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop6;	/* break out of the loop */
            	    break;
                }
            }
            loop6: ; /* Jump out to here if this rule does not match */


            FOLLOWPUSH(FOLLOW_time_field_in_session_description405);
            time_field26=time_field(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, time_field26.tree);

            CR27 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description407);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR27_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR27));
            ADAPTOR->addChild(ADAPTOR, root_0, CR27_tree);
            }

            LF28 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description409);
            if  (HASEXCEPTION())
            {
                goto rulesession_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_session_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF28_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF28));
            ADAPTOR->addChild(ADAPTOR, root_0, LF28_tree);
            }

            // belle_sdp.g:115:26: ( repeat_time CR LF )*

            for (;;)
            {
                int alt7=2;
                alt7 = cdfa7.predict(ctx, RECOGNIZER, ISTREAM, &cdfa7);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt7)
                {
            	case 1:
            	    // belle_sdp.g:115:27: repeat_time CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_repeat_time_in_session_description437);
            	        repeat_time29=repeat_time(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, repeat_time29.tree);

            	        CR30 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description439);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR30_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR30));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR30_tree);
            	        }

            	        LF31 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description441);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF31_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF31));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF31_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:116:26: ( zone_adjustments CR LF )?
            {
                int alt8=2;
                alt8 = cdfa8.predict(ctx, RECOGNIZER, ISTREAM, &cdfa8);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt8)
                {
            	case 1:
            	    // belle_sdp.g:116:27: zone_adjustments CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_zone_adjustments_in_session_description471);
            	        zone_adjustments32=zone_adjustments(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, zone_adjustments32.tree);

            	        CR33 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description473);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR33_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR33));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR33_tree);
            	        }

            	        LF34 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description475);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF34_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF34));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF34_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:117:26: ( key_field CR LF )?
            {
                int alt9=2;
                alt9 = cdfa9.predict(ctx, RECOGNIZER, ISTREAM, &cdfa9);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt9)
                {
            	case 1:
            	    // belle_sdp.g:117:27: key_field CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_key_field_in_session_description505);
            	        key_field35=key_field(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, key_field35.tree);

            	        CR36 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description507);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR36_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR36));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR36_tree);
            	        }

            	        LF37 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description509);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF37_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF37));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF37_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:118:26: ( attribute CR LF )*

            for (;;)
            {
                int alt10=2;
                alt10 = cdfa10.predict(ctx, RECOGNIZER, ISTREAM, &cdfa10);
                if  (HASEXCEPTION())
                {
                    goto rulesession_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_session_descriptionPop(ctx);

                    return retval;
                }

                switch (alt10)
                {
            	case 1:
            	    // belle_sdp.g:118:27: attribute CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_attribute_in_session_description539);
            	        attribute38=attribute(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute38.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_session_description_add_attribute((SCOPE_TOP(session_description))->current,
            	            attribute38.ret
            	            );
            	        }


            	        CR39 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_session_description543);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR39_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR39));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR39_tree);
            	        }

            	        LF40 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_session_description545);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF40_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF40));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF40_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop10;	/* break out of the loop */
            	    break;
                }
            }
            loop10: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:119:26: ( media_description )*

            for (;;)
            {
                int alt11=2;
                switch ( LA(1) )
                {
                case COMMON_CHAR:
                case DIGIT:
                case HEX_CHAR:
                	{
                		alt11=1;
                	}
                    break;

                }

                switch (alt11)
                {
            	case 1:
            	    // belle_sdp.g:119:27: media_description
            	    {
            	        FOLLOWPUSH(FOLLOW_media_description_in_session_description575);
            	        media_description41=media_description(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulesession_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_session_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, media_description41.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_session_description_add_media_description((SCOPE_TOP(session_description))->current,
            	            media_description41.ret
            	            );
            	        }


            	    }
            	    break;

            	default:
            	    goto loop11;	/* break out of the loop */
            	    break;
                }
            }
            loop11: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesession_descriptionEx; /* Prevent compiler warnings */
    rulesession_descriptionEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref((SCOPE_TOP(session_description))->current);
	       
	    retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_session_descriptionPop(ctx);

    return retval;
}
/* $ANTLR end session_description */

/**
 * $ANTLR start version
 * belle_sdp.g:128:1: version :{...}? alpha_num EQUAL (v= DIGIT )+ ;
 */
static belle_sdpParser_version_return
version(pbelle_sdpParser ctx)
{
    belle_sdpParser_version_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    v;
    pANTLR3_COMMON_TOKEN    EQUAL43;
    belle_sdpParser_alpha_num_return alpha_num42;
    #undef	RETURN_TYPE_alpha_num42
    #define	RETURN_TYPE_alpha_num42 belle_sdpParser_alpha_num_return

    pANTLR3_BASE_TREE v_tree;
    pANTLR3_BASE_TREE EQUAL43_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    v       = NULL;
    EQUAL43       = NULL;
    alpha_num42.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    v_tree   = NULL;
    EQUAL43_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:128:8: ({...}? alpha_num EQUAL (v= DIGIT )+ )
        // belle_sdp.g:128:16: {...}? alpha_num EQUAL (v= DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(v))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(v)";
                    EXCEPTION->ruleName	 = (void *)"version";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_version602);
            alpha_num42=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleversionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num42.tree);

            EQUAL43 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_version604);
            if  (HASEXCEPTION())
            {
                goto ruleversionEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL43_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL43));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL43_tree);
            }

            // belle_sdp.g:128:47: (v= DIGIT )+
            {
                int cnt12=0;

                for (;;)
                {
                    int alt12=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt12=1;
            		}
            	    break;

            	}

            	switch (alt12)
            	{
            	    case 1:
            	        // belle_sdp.g:128:47: v= DIGIT
            	        {
            	            v = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_version608);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleversionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            v_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, v));
            	            ADAPTOR->addChild(ADAPTOR, root_0, v_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt12 >= 1 )
            		{
            		    goto loop12;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleversionEx;
            	}
            	cnt12++;
                }
                loop12: ;	/* Jump to here if this rule does not match */
            }

            if ( BACKTRACKING==0 )
            {
                belle_sdp_version_t* version =belle_sdp_version_new();
                                                                        belle_sdp_version_set_version(version,atoi((const char*)(v->getText(v))->chars));
                                                                        belle_sdp_session_description_set_version((SCOPE_TOP(session_description))->current,version);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleversionEx; /* Prevent compiler warnings */
    ruleversionEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end version */

/**
 * $ANTLR start origin
 * belle_sdp.g:134:1: origin returns [belle_sdp_origin_t* ret] :{...}? alpha_num EQUAL username SPACE sess_id SPACE sess_version SPACE nettype SPACE addrtype SPACE addr ;
 */
static belle_sdpParser_origin_return
origin(pbelle_sdpParser ctx)
{
    belle_sdpParser_origin_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL45;
    pANTLR3_COMMON_TOKEN    SPACE47;
    pANTLR3_COMMON_TOKEN    SPACE49;
    pANTLR3_COMMON_TOKEN    SPACE51;
    pANTLR3_COMMON_TOKEN    SPACE53;
    pANTLR3_COMMON_TOKEN    SPACE55;
    belle_sdpParser_alpha_num_return alpha_num44;
    #undef	RETURN_TYPE_alpha_num44
    #define	RETURN_TYPE_alpha_num44 belle_sdpParser_alpha_num_return

    belle_sdpParser_username_return username46;
    #undef	RETURN_TYPE_username46
    #define	RETURN_TYPE_username46 belle_sdpParser_username_return

    belle_sdpParser_sess_id_return sess_id48;
    #undef	RETURN_TYPE_sess_id48
    #define	RETURN_TYPE_sess_id48 belle_sdpParser_sess_id_return

    belle_sdpParser_sess_version_return sess_version50;
    #undef	RETURN_TYPE_sess_version50
    #define	RETURN_TYPE_sess_version50 belle_sdpParser_sess_version_return

    belle_sdpParser_nettype_return nettype52;
    #undef	RETURN_TYPE_nettype52
    #define	RETURN_TYPE_nettype52 belle_sdpParser_nettype_return

    belle_sdpParser_addrtype_return addrtype54;
    #undef	RETURN_TYPE_addrtype54
    #define	RETURN_TYPE_addrtype54 belle_sdpParser_addrtype_return

    belle_sdpParser_addr_return addr56;
    #undef	RETURN_TYPE_addr56
    #define	RETURN_TYPE_addr56 belle_sdpParser_addr_return

    pANTLR3_BASE_TREE EQUAL45_tree;
    pANTLR3_BASE_TREE SPACE47_tree;
    pANTLR3_BASE_TREE SPACE49_tree;
    pANTLR3_BASE_TREE SPACE51_tree;
    pANTLR3_BASE_TREE SPACE53_tree;
    pANTLR3_BASE_TREE SPACE55_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_originTop = pbelle_sdpParser_originPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(origin))->current= belle_sdp_origin_new(); 
    retval.ret=(SCOPE_TOP(origin))->current;
     
    EQUAL45       = NULL;
    SPACE47       = NULL;
    SPACE49       = NULL;
    SPACE51       = NULL;
    SPACE53       = NULL;
    SPACE55       = NULL;
    alpha_num44.tree = NULL;

    username46.tree = NULL;

    sess_id48.tree = NULL;

    sess_version50.tree = NULL;

    nettype52.tree = NULL;

    addrtype54.tree = NULL;

    addr56.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL45_tree   = NULL;
    SPACE47_tree   = NULL;
    SPACE49_tree   = NULL;
    SPACE51_tree   = NULL;
    SPACE53_tree   = NULL;
    SPACE55_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:137:10: ({...}? alpha_num EQUAL username SPACE sess_id SPACE sess_version SPACE nettype SPACE addrtype SPACE addr )
        // belle_sdp.g:137:10: {...}? alpha_num EQUAL username SPACE sess_id SPACE sess_version SPACE nettype SPACE addrtype SPACE addr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(o))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_originPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(o)";
                    EXCEPTION->ruleName	 = (void *)"origin";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_origin695);
            alpha_num44=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num44.tree);

            EQUAL45 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_origin697);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL45_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL45));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL45_tree);
            }

            FOLLOWPUSH(FOLLOW_username_in_origin699);
            username46=username(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, username46.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_origin_set_username((SCOPE_TOP(origin))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, username46.start, username46.stop))
                ->chars);
            }


            SPACE47 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_origin729);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE47_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE47));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE47_tree);
            }

            FOLLOWPUSH(FOLLOW_sess_id_in_origin731);
            sess_id48=sess_id(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sess_id48.tree);

            if ( BACKTRACKING==0 )
            {
                if ((STRSTREAM->toStringTT(STRSTREAM, sess_id48.start, sess_id48.stop))
                ->chars) belle_sdp_origin_set_session_id((SCOPE_TOP(origin))->current,atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, sess_id48.start, sess_id48.stop))
                ->chars));
            }


            SPACE49 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_origin760);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE49_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE49));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE49_tree);
            }

            FOLLOWPUSH(FOLLOW_sess_version_in_origin762);
            sess_version50=sess_version(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sess_version50.tree);

            if ( BACKTRACKING==0 )
            {
                if ((STRSTREAM->toStringTT(STRSTREAM, sess_version50.start, sess_version50.stop))
                ->chars) belle_sdp_origin_set_session_version((SCOPE_TOP(origin))->current,atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, sess_version50.start, sess_version50.stop))
                ->chars));
            }


            SPACE51 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_origin791);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE51_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE51));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE51_tree);
            }

            FOLLOWPUSH(FOLLOW_nettype_in_origin793);
            nettype52=nettype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, nettype52.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_origin_set_network_type((SCOPE_TOP(origin))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, nettype52.start, nettype52.stop))
                ->chars);
            }


            SPACE53 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_origin823);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE53_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE53));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE53_tree);
            }

            FOLLOWPUSH(FOLLOW_addrtype_in_origin825);
            addrtype54=addrtype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, addrtype54.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_origin_set_address_type((SCOPE_TOP(origin))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, addrtype54.start, addrtype54.stop))
                ->chars);
            }


            SPACE55 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_origin856);
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE55_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE55));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE55_tree);
            }

            FOLLOWPUSH(FOLLOW_addr_in_origin858);
            addr56=addr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleoriginEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_originPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, addr56.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_origin_set_address((SCOPE_TOP(origin))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, addr56.start, addr56.stop))
                ->chars);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleoriginEx; /* Prevent compiler warnings */
    ruleoriginEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref((SCOPE_TOP(origin))->current);
	       
	    retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_originPop(ctx);

    return retval;
}
/* $ANTLR end origin */

/**
 * $ANTLR start session_name
 * belle_sdp.g:151:1: session_name :{...}? alpha_num EQUAL text ;
 */
static belle_sdpParser_session_name_return
session_name(pbelle_sdpParser ctx)
{
    belle_sdpParser_session_name_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL58;
    belle_sdpParser_alpha_num_return alpha_num57;
    #undef	RETURN_TYPE_alpha_num57
    #define	RETURN_TYPE_alpha_num57 belle_sdpParser_alpha_num_return

    belle_sdpParser_text_return text59;
    #undef	RETURN_TYPE_text59
    #define	RETURN_TYPE_text59 belle_sdpParser_text_return

    pANTLR3_BASE_TREE EQUAL58_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL58       = NULL;
    alpha_num57.tree = NULL;

    text59.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL58_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:151:13: ({...}? alpha_num EQUAL text )
        // belle_sdp.g:151:16: {...}? alpha_num EQUAL text
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(s))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(s)";
                    EXCEPTION->ruleName	 = (void *)"session_name";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_session_name903);
            alpha_num57=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num57.tree);

            EQUAL58 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_session_name905);
            if  (HASEXCEPTION())
            {
                goto rulesession_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL58_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL58));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL58_tree);
            }

            FOLLOWPUSH(FOLLOW_text_in_session_name907);
            text59=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulesession_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, text59.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_session_name_t* session_name =belle_sdp_session_name_new();
                                                                        belle_sdp_session_name_set_value(session_name,(const char*)(STRSTREAM->toStringTT(STRSTREAM, text59.start, text59.stop))
                ->chars);
                                                                        belle_sdp_session_description_set_session_name((SCOPE_TOP(session_description))->current,session_name);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulesession_nameEx; /* Prevent compiler warnings */
    rulesession_nameEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end session_name */

/**
 * $ANTLR start info
 * belle_sdp.g:155:1: info returns [belle_sdp_info_t* ret] :{...}? alpha_num EQUAL info_value ;
 */
static belle_sdpParser_info_return
info(pbelle_sdpParser ctx)
{
    belle_sdpParser_info_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL61;
    belle_sdpParser_alpha_num_return alpha_num60;
    #undef	RETURN_TYPE_alpha_num60
    #define	RETURN_TYPE_alpha_num60 belle_sdpParser_alpha_num_return

    belle_sdpParser_info_value_return info_value62;
    #undef	RETURN_TYPE_info_value62
    #define	RETURN_TYPE_info_value62 belle_sdpParser_info_value_return

    pANTLR3_BASE_TREE EQUAL61_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_infoTop = pbelle_sdpParser_infoPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(info))->current= belle_sdp_info_new(); 
    retval.ret=(SCOPE_TOP(info))->current;
     
    EQUAL61       = NULL;
    alpha_num60.tree = NULL;

    info_value62.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL61_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:158:5: ({...}? alpha_num EQUAL info_value )
        // belle_sdp.g:158:5: {...}? alpha_num EQUAL info_value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(i))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_infoPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(i)";
                    EXCEPTION->ruleName	 = (void *)"info";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_info939);
            alpha_num60=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_infoPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num60.tree);

            EQUAL61 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_info941);
            if  (HASEXCEPTION())
            {
                goto ruleinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_infoPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL61_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL61));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL61_tree);
            }

            FOLLOWPUSH(FOLLOW_info_value_in_info943);
            info_value62=info_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleinfoEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_infoPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, info_value62.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_info_set_value((SCOPE_TOP(info))->current,(const char*) 
                (STRSTREAM->toStringTT(STRSTREAM, info_value62.start, info_value62.stop))
                ->chars);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinfoEx; /* Prevent compiler warnings */
    ruleinfoEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sdpParser_infoPop(ctx);

    return retval;
}
/* $ANTLR end info */

/**
 * $ANTLR start info_value
 * belle_sdp.g:160:1: info_value options {greedy=false; } : (~ ( CR | LF ) )* ;
 */
static belle_sdpParser_info_value_return
info_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_info_value_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set63;

    pANTLR3_BASE_TREE set63_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set63       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set63_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:160:50: ( (~ ( CR | LF ) )* )
        // belle_sdp.g:160:59: (~ ( CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:160:59: (~ ( CR | LF ) )*

            for (;;)
            {
                int alt13=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case SPACE:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt13=1;
                	}
                    break;

                }

                switch (alt13)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set63=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set63))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleinfo_valueEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop13;	/* break out of the loop */
            	    break;
                }
            }
            loop13: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleinfo_valueEx; /* Prevent compiler warnings */
    ruleinfo_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end info_value */

/**
 * $ANTLR start uri_field
 * belle_sdp.g:162:1: uri_field :{...}? alpha_num EQUAL uri ;
 */
static belle_sdpParser_uri_field_return
uri_field(pbelle_sdpParser ctx)
{
    belle_sdpParser_uri_field_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL65;
    belle_sdpParser_alpha_num_return alpha_num64;
    #undef	RETURN_TYPE_alpha_num64
    #define	RETURN_TYPE_alpha_num64 belle_sdpParser_alpha_num_return

    belle_sdpParser_uri_return uri66;
    #undef	RETURN_TYPE_uri66
    #define	RETURN_TYPE_uri66 belle_sdpParser_uri_return

    pANTLR3_BASE_TREE EQUAL65_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL65       = NULL;
    alpha_num64.tree = NULL;

    uri66.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL65_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:162:10: ({...}? alpha_num EQUAL uri )
        // belle_sdp.g:162:22: {...}? alpha_num EQUAL uri
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(u))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(u)";
                    EXCEPTION->ruleName	 = (void *)"uri_field";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_uri_field1006);
            alpha_num64=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num64.tree);

            EQUAL65 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_uri_field1008);
            if  (HASEXCEPTION())
            {
                goto ruleuri_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL65_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL65));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL65_tree);
            }

            FOLLOWPUSH(FOLLOW_uri_in_uri_field1010);
            uri66=uri(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuri_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, uri66.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuri_fieldEx; /* Prevent compiler warnings */
    ruleuri_fieldEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end uri_field */

/**
 * $ANTLR start email
 * belle_sdp.g:164:1: email returns [belle_sdp_email_t* ret] :{...}? alpha_num EQUAL email_address ;
 */
static belle_sdpParser_email_return
email(pbelle_sdpParser ctx)
{
    belle_sdpParser_email_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL68;
    belle_sdpParser_alpha_num_return alpha_num67;
    #undef	RETURN_TYPE_alpha_num67
    #define	RETURN_TYPE_alpha_num67 belle_sdpParser_alpha_num_return

    belle_sdpParser_email_address_return email_address69;
    #undef	RETURN_TYPE_email_address69
    #define	RETURN_TYPE_email_address69 belle_sdpParser_email_address_return

    pANTLR3_BASE_TREE EQUAL68_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_emailTop = pbelle_sdpParser_emailPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(email))->current= belle_sdp_email_new(); 
    retval.ret=(SCOPE_TOP(email))->current;
     
    EQUAL68       = NULL;
    alpha_num67.tree = NULL;

    email_address69.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL68_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:167:3: ({...}? alpha_num EQUAL email_address )
        // belle_sdp.g:167:12: {...}? alpha_num EQUAL email_address
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(e))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_emailPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(e)";
                    EXCEPTION->ruleName	 = (void *)"email";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_email1047);
            alpha_num67=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleemailEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_emailPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num67.tree);

            EQUAL68 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_email1049);
            if  (HASEXCEPTION())
            {
                goto ruleemailEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_emailPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL68_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL68));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL68_tree);
            }

            FOLLOWPUSH(FOLLOW_email_address_in_email1051);
            email_address69=email_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleemailEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_emailPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, email_address69.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_email_set_value((SCOPE_TOP(email))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, email_address69.start, email_address69.stop))
                ->chars);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleemailEx; /* Prevent compiler warnings */
    ruleemailEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sdpParser_emailPop(ctx);

    return retval;
}
/* $ANTLR end email */

/**
 * $ANTLR start phone_field
 * belle_sdp.g:169:1: phone_field :{...}? alpha_num EQUAL phone_number CR LF ;
 */
static belle_sdpParser_phone_field_return
phone_field(pbelle_sdpParser ctx)
{
    belle_sdpParser_phone_field_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL71;
    pANTLR3_COMMON_TOKEN    CR73;
    pANTLR3_COMMON_TOKEN    LF74;
    belle_sdpParser_alpha_num_return alpha_num70;
    #undef	RETURN_TYPE_alpha_num70
    #define	RETURN_TYPE_alpha_num70 belle_sdpParser_alpha_num_return

    belle_sdpParser_phone_number_return phone_number72;
    #undef	RETURN_TYPE_phone_number72
    #define	RETURN_TYPE_phone_number72 belle_sdpParser_phone_number_return

    pANTLR3_BASE_TREE EQUAL71_tree;
    pANTLR3_BASE_TREE CR73_tree;
    pANTLR3_BASE_TREE LF74_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL71       = NULL;
    CR73       = NULL;
    LF74       = NULL;
    alpha_num70.tree = NULL;

    phone_number72.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL71_tree   = NULL;
    CR73_tree   = NULL;
    LF74_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:169:12: ({...}? alpha_num EQUAL phone_number CR LF )
        // belle_sdp.g:169:21: {...}? alpha_num EQUAL phone_number CR LF
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(p))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(p)";
                    EXCEPTION->ruleName	 = (void *)"phone_field";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_phone_field1068);
            alpha_num70=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulephone_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num70.tree);

            EQUAL71 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_phone_field1070);
            if  (HASEXCEPTION())
            {
                goto rulephone_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL71_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL71));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL71_tree);
            }

            FOLLOWPUSH(FOLLOW_phone_number_in_phone_field1072);
            phone_number72=phone_number(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulephone_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, phone_number72.tree);

            CR73 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_phone_field1074);
            if  (HASEXCEPTION())
            {
                goto rulephone_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR73_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR73));
            ADAPTOR->addChild(ADAPTOR, root_0, CR73_tree);
            }

            LF74 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_phone_field1076);
            if  (HASEXCEPTION())
            {
                goto rulephone_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF74_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF74));
            ADAPTOR->addChild(ADAPTOR, root_0, LF74_tree);
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulephone_fieldEx; /* Prevent compiler warnings */
    rulephone_fieldEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end phone_field */

/**
 * $ANTLR start connection
 * belle_sdp.g:171:1: connection returns [belle_sdp_connection_t* ret] :{...}? alpha_num EQUAL nettype SPACE addrtype SPACE connection_address ;
 */
static belle_sdpParser_connection_return
connection(pbelle_sdpParser ctx)
{
    belle_sdpParser_connection_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL76;
    pANTLR3_COMMON_TOKEN    SPACE78;
    pANTLR3_COMMON_TOKEN    SPACE80;
    belle_sdpParser_alpha_num_return alpha_num75;
    #undef	RETURN_TYPE_alpha_num75
    #define	RETURN_TYPE_alpha_num75 belle_sdpParser_alpha_num_return

    belle_sdpParser_nettype_return nettype77;
    #undef	RETURN_TYPE_nettype77
    #define	RETURN_TYPE_nettype77 belle_sdpParser_nettype_return

    belle_sdpParser_addrtype_return addrtype79;
    #undef	RETURN_TYPE_addrtype79
    #define	RETURN_TYPE_addrtype79 belle_sdpParser_addrtype_return

    belle_sdpParser_connection_address_return connection_address81;
    #undef	RETURN_TYPE_connection_address81
    #define	RETURN_TYPE_connection_address81 belle_sdpParser_connection_address_return

    pANTLR3_BASE_TREE EQUAL76_tree;
    pANTLR3_BASE_TREE SPACE78_tree;
    pANTLR3_BASE_TREE SPACE80_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_connectionTop = pbelle_sdpParser_connectionPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(connection))->current= belle_sdp_connection_new(); 
    retval.ret=(SCOPE_TOP(connection))->current;
     
    EQUAL76       = NULL;
    SPACE78       = NULL;
    SPACE80       = NULL;
    alpha_num75.tree = NULL;

    nettype77.tree = NULL;

    addrtype79.tree = NULL;

    connection_address81.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL76_tree   = NULL;
    SPACE78_tree   = NULL;
    SPACE80_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:174:6: ({...}? alpha_num EQUAL nettype SPACE addrtype SPACE connection_address )
        // belle_sdp.g:174:6: {...}? alpha_num EQUAL nettype SPACE addrtype SPACE connection_address
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(c))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_connectionPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(c)";
                    EXCEPTION->ruleName	 = (void *)"connection";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_connection1106);
            alpha_num75=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num75.tree);

            EQUAL76 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_connection1108);
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL76_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL76));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL76_tree);
            }

            FOLLOWPUSH(FOLLOW_nettype_in_connection1110);
            nettype77=nettype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, nettype77.tree);

            if ( BACKTRACKING==0 )
            {
                 belle_sdp_connection_set_network_type((SCOPE_TOP(connection))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, nettype77.start, nettype77.stop))
                ->chars);
            }


            SPACE78 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_connection1133);
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE78_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE78));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE78_tree);
            }

            FOLLOWPUSH(FOLLOW_addrtype_in_connection1135);
            addrtype79=addrtype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, addrtype79.tree);

            if ( BACKTRACKING==0 )
            {
                 belle_sdp_connection_set_address_type((SCOPE_TOP(connection))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, addrtype79.start, addrtype79.stop))
                ->chars);
            }


            SPACE80 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_connection1157);
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE80_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE80));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE80_tree);
            }

            FOLLOWPUSH(FOLLOW_connection_address_in_connection1159);
            connection_address81=connection_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconnectionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_connectionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, connection_address81.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_connection_set_address((SCOPE_TOP(connection))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, connection_address81.start, connection_address81.stop))
                ->chars);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconnectionEx; /* Prevent compiler warnings */
    ruleconnectionEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(retval.ret
	    );
	      retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_connectionPop(ctx);

    return retval;
}
/* $ANTLR end connection */

/**
 * $ANTLR start bandwidth
 * belle_sdp.g:188:1: bandwidth returns [belle_sdp_bandwidth_t* ret] :{...}? alpha_num EQUAL bwtype COLON bandwidth_value ;
 */
static belle_sdpParser_bandwidth_return
bandwidth(pbelle_sdpParser ctx)
{
    belle_sdpParser_bandwidth_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL83;
    pANTLR3_COMMON_TOKEN    COLON85;
    belle_sdpParser_alpha_num_return alpha_num82;
    #undef	RETURN_TYPE_alpha_num82
    #define	RETURN_TYPE_alpha_num82 belle_sdpParser_alpha_num_return

    belle_sdpParser_bwtype_return bwtype84;
    #undef	RETURN_TYPE_bwtype84
    #define	RETURN_TYPE_bwtype84 belle_sdpParser_bwtype_return

    belle_sdpParser_bandwidth_value_return bandwidth_value86;
    #undef	RETURN_TYPE_bandwidth_value86
    #define	RETURN_TYPE_bandwidth_value86 belle_sdpParser_bandwidth_value_return

    pANTLR3_BASE_TREE EQUAL83_tree;
    pANTLR3_BASE_TREE COLON85_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_bandwidthTop = pbelle_sdpParser_bandwidthPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(bandwidth))->current= belle_sdp_bandwidth_new(); 
    retval.ret=(SCOPE_TOP(bandwidth))->current;
     
    EQUAL83       = NULL;
    COLON85       = NULL;
    alpha_num82.tree = NULL;

    bwtype84.tree = NULL;

    bandwidth_value86.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL83_tree   = NULL;
    COLON85_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:191:3: ({...}? alpha_num EQUAL bwtype COLON bandwidth_value )
        // belle_sdp.g:191:8: {...}? alpha_num EQUAL bwtype COLON bandwidth_value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(b))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_bandwidthPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(b)";
                    EXCEPTION->ruleName	 = (void *)"bandwidth";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_bandwidth1322);
            alpha_num82=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebandwidthEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_bandwidthPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num82.tree);

            EQUAL83 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_bandwidth1324);
            if  (HASEXCEPTION())
            {
                goto rulebandwidthEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_bandwidthPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL83_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL83));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL83_tree);
            }

            FOLLOWPUSH(FOLLOW_bwtype_in_bandwidth1326);
            bwtype84=bwtype(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebandwidthEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_bandwidthPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bwtype84.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_bandwidth_set_type((SCOPE_TOP(bandwidth))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, bwtype84.start, bwtype84.stop))
                ->chars); 
            }


            COLON85 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_bandwidth1337);
            if  (HASEXCEPTION())
            {
                goto rulebandwidthEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_bandwidthPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            COLON85_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON85));
            ADAPTOR->addChild(ADAPTOR, root_0, COLON85_tree);
            }

            FOLLOWPUSH(FOLLOW_bandwidth_value_in_bandwidth1339);
            bandwidth_value86=bandwidth_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulebandwidthEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_bandwidthPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bandwidth_value86.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_bandwidth_set_value((SCOPE_TOP(bandwidth))->current,atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, bandwidth_value86.start, bandwidth_value86.stop))
                ->chars));
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebandwidthEx; /* Prevent compiler warnings */
    rulebandwidthEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(retval.ret
	    );
	      retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_bandwidthPop(ctx);

    return retval;
}
/* $ANTLR end bandwidth */

/**
 * $ANTLR start time_field
 * belle_sdp.g:199:1: time_field :{...}? alpha_num EQUAL start_time SPACE stop_time ;
 */
static belle_sdpParser_time_field_return
time_field(pbelle_sdpParser ctx)
{
    belle_sdpParser_time_field_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL88;
    pANTLR3_COMMON_TOKEN    SPACE90;
    belle_sdpParser_alpha_num_return alpha_num87;
    #undef	RETURN_TYPE_alpha_num87
    #define	RETURN_TYPE_alpha_num87 belle_sdpParser_alpha_num_return

    belle_sdpParser_start_time_return start_time89;
    #undef	RETURN_TYPE_start_time89
    #define	RETURN_TYPE_start_time89 belle_sdpParser_start_time_return

    belle_sdpParser_stop_time_return stop_time91;
    #undef	RETURN_TYPE_stop_time91
    #define	RETURN_TYPE_stop_time91 belle_sdpParser_stop_time_return

    pANTLR3_BASE_TREE EQUAL88_tree;
    pANTLR3_BASE_TREE SPACE90_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL88       = NULL;
    SPACE90       = NULL;
    alpha_num87.tree = NULL;

    start_time89.tree = NULL;

    stop_time91.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL88_tree   = NULL;
    SPACE90_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:199:11: ({...}? alpha_num EQUAL start_time SPACE stop_time )
        // belle_sdp.g:199:15: {...}? alpha_num EQUAL start_time SPACE stop_time
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(t))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(t)";
                    EXCEPTION->ruleName	 = (void *)"time_field";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_time_field1357);
            alpha_num87=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num87.tree);

            EQUAL88 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_time_field1359);
            if  (HASEXCEPTION())
            {
                goto ruletime_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL88_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL88));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL88_tree);
            }

            FOLLOWPUSH(FOLLOW_start_time_in_time_field1376);
            start_time89=start_time(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, start_time89.tree);

            SPACE90 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_time_field1393);
            if  (HASEXCEPTION())
            {
                goto ruletime_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE90_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE90));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE90_tree);
            }

            FOLLOWPUSH(FOLLOW_stop_time_in_time_field1410);
            stop_time91=stop_time(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruletime_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, stop_time91.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_time_description_t* time_description =belle_sdp_time_description_new();
                                         belle_sdp_time_t* time_value =belle_sdp_time_new();
                						 belle_sip_list_t* time_description_list;
                                         belle_sdp_time_set_start(time_value,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, start_time89.start, start_time89.stop))
                ->chars));
                                         belle_sdp_time_set_stop(time_value,atoi((const char*)(STRSTREAM->toStringTT(STRSTREAM, stop_time91.start, stop_time91.stop))
                ->chars));
                                         belle_sdp_time_description_set_time(time_description,time_value);
                                         time_description_list = belle_sip_list_append(NULL,time_description);
                                         belle_sdp_session_description_set_time_descriptions((SCOPE_TOP(session_description))->current,time_description_list);
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletime_fieldEx; /* Prevent compiler warnings */
    ruletime_fieldEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end time_field */

/**
 * $ANTLR start repeat_time
 * belle_sdp.g:211:1: repeat_time :{...}? alpha_num EQUAL repeat_interval ( SPACE typed_time )+ ;
 */
static belle_sdpParser_repeat_time_return
repeat_time(pbelle_sdpParser ctx)
{
    belle_sdpParser_repeat_time_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL93;
    pANTLR3_COMMON_TOKEN    SPACE95;
    belle_sdpParser_alpha_num_return alpha_num92;
    #undef	RETURN_TYPE_alpha_num92
    #define	RETURN_TYPE_alpha_num92 belle_sdpParser_alpha_num_return

    belle_sdpParser_repeat_interval_return repeat_interval94;
    #undef	RETURN_TYPE_repeat_interval94
    #define	RETURN_TYPE_repeat_interval94 belle_sdpParser_repeat_interval_return

    belle_sdpParser_typed_time_return typed_time96;
    #undef	RETURN_TYPE_typed_time96
    #define	RETURN_TYPE_typed_time96 belle_sdpParser_typed_time_return

    pANTLR3_BASE_TREE EQUAL93_tree;
    pANTLR3_BASE_TREE SPACE95_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL93       = NULL;
    SPACE95       = NULL;
    alpha_num92.tree = NULL;

    repeat_interval94.tree = NULL;

    typed_time96.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL93_tree   = NULL;
    SPACE95_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:211:12: ({...}? alpha_num EQUAL repeat_interval ( SPACE typed_time )+ )
        // belle_sdp.g:211:20: {...}? alpha_num EQUAL repeat_interval ( SPACE typed_time )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(r))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(r)";
                    EXCEPTION->ruleName	 = (void *)"repeat_time";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_repeat_time1426);
            alpha_num92=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerepeat_timeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num92.tree);

            EQUAL93 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_repeat_time1428);
            if  (HASEXCEPTION())
            {
                goto rulerepeat_timeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL93_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL93));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL93_tree);
            }

            FOLLOWPUSH(FOLLOW_repeat_interval_in_repeat_time1430);
            repeat_interval94=repeat_interval(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerepeat_timeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, repeat_interval94.tree);

            // belle_sdp.g:211:66: ( SPACE typed_time )+
            {
                int cnt14=0;

                for (;;)
                {
                    int alt14=2;
            	switch ( LA(1) )
            	{
            	case SPACE:
            		{
            			alt14=1;
            		}
            	    break;

            	}

            	switch (alt14)
            	{
            	    case 1:
            	        // belle_sdp.g:211:67: SPACE typed_time
            	        {
            	            SPACE95 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_repeat_time1433);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerepeat_timeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            SPACE95_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE95));
            	            ADAPTOR->addChild(ADAPTOR, root_0, SPACE95_tree);
            	            }

            	            FOLLOWPUSH(FOLLOW_typed_time_in_repeat_time1435);
            	            typed_time96=typed_time(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulerepeat_timeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typed_time96.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt14 >= 1 )
            		{
            		    goto loop14;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulerepeat_timeEx;
            	}
            	cnt14++;
                }
                loop14: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulerepeat_timeEx; /* Prevent compiler warnings */
    rulerepeat_timeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end repeat_time */

/**
 * $ANTLR start zone_adjustments
 * belle_sdp.g:213:1: zone_adjustments :{...}? alpha_num EQUAL sdp_time SPACE ( '-' )? typed_time ( SPACE sdp_time SPACE ( '-' )? typed_time )* ;
 */
static belle_sdpParser_zone_adjustments_return
zone_adjustments(pbelle_sdpParser ctx)
{
    belle_sdpParser_zone_adjustments_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL98;
    pANTLR3_COMMON_TOKEN    SPACE100;
    pANTLR3_COMMON_TOKEN    char_literal101;
    pANTLR3_COMMON_TOKEN    SPACE103;
    pANTLR3_COMMON_TOKEN    SPACE105;
    pANTLR3_COMMON_TOKEN    char_literal106;
    belle_sdpParser_alpha_num_return alpha_num97;
    #undef	RETURN_TYPE_alpha_num97
    #define	RETURN_TYPE_alpha_num97 belle_sdpParser_alpha_num_return

    belle_sdpParser_sdp_time_return sdp_time99;
    #undef	RETURN_TYPE_sdp_time99
    #define	RETURN_TYPE_sdp_time99 belle_sdpParser_sdp_time_return

    belle_sdpParser_typed_time_return typed_time102;
    #undef	RETURN_TYPE_typed_time102
    #define	RETURN_TYPE_typed_time102 belle_sdpParser_typed_time_return

    belle_sdpParser_sdp_time_return sdp_time104;
    #undef	RETURN_TYPE_sdp_time104
    #define	RETURN_TYPE_sdp_time104 belle_sdpParser_sdp_time_return

    belle_sdpParser_typed_time_return typed_time107;
    #undef	RETURN_TYPE_typed_time107
    #define	RETURN_TYPE_typed_time107 belle_sdpParser_typed_time_return

    pANTLR3_BASE_TREE EQUAL98_tree;
    pANTLR3_BASE_TREE SPACE100_tree;
    pANTLR3_BASE_TREE char_literal101_tree;
    pANTLR3_BASE_TREE SPACE103_tree;
    pANTLR3_BASE_TREE SPACE105_tree;
    pANTLR3_BASE_TREE char_literal106_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL98       = NULL;
    SPACE100       = NULL;
    char_literal101       = NULL;
    SPACE103       = NULL;
    SPACE105       = NULL;
    char_literal106       = NULL;
    alpha_num97.tree = NULL;

    sdp_time99.tree = NULL;

    typed_time102.tree = NULL;

    sdp_time104.tree = NULL;

    typed_time107.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL98_tree   = NULL;
    SPACE100_tree   = NULL;
    char_literal101_tree   = NULL;
    SPACE103_tree   = NULL;
    SPACE105_tree   = NULL;
    char_literal106_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:213:17: ({...}? alpha_num EQUAL sdp_time SPACE ( '-' )? typed_time ( SPACE sdp_time SPACE ( '-' )? typed_time )* )
        // belle_sdp.g:213:22: {...}? alpha_num EQUAL sdp_time SPACE ( '-' )? typed_time ( SPACE sdp_time SPACE ( '-' )? typed_time )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(z))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(z)";
                    EXCEPTION->ruleName	 = (void *)"zone_adjustments";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_zone_adjustments1449);
            alpha_num97=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulezone_adjustmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num97.tree);

            EQUAL98 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_zone_adjustments1451);
            if  (HASEXCEPTION())
            {
                goto rulezone_adjustmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL98_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL98));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL98_tree);
            }

            FOLLOWPUSH(FOLLOW_sdp_time_in_zone_adjustments1453);
            sdp_time99=sdp_time(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulezone_adjustmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sdp_time99.tree);

            SPACE100 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_zone_adjustments1455);
            if  (HASEXCEPTION())
            {
                goto rulezone_adjustmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE100_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE100));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE100_tree);
            }

            // belle_sdp.g:213:68: ( '-' )?
            {
                int alt15=2;
                switch ( LA(1) )
                {
                    case DASH:
                    	{
                    		alt15=1;
                    	}
                        break;
                }

                switch (alt15)
                {
            	case 1:
            	    // belle_sdp.g:213:68: '-'
            	    {
            	        char_literal101 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_zone_adjustments1457);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezone_adjustmentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        char_literal101_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal101));
            	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal101_tree);
            	        }

            	    }
            	    break;

                }
            }

            FOLLOWPUSH(FOLLOW_typed_time_in_zone_adjustments1460);
            typed_time102=typed_time(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulezone_adjustmentsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typed_time102.tree);

            // belle_sdp.g:214:26: ( SPACE sdp_time SPACE ( '-' )? typed_time )*

            for (;;)
            {
                int alt17=2;
                switch ( LA(1) )
                {
                case SPACE:
                	{
                		alt17=1;
                	}
                    break;

                }

                switch (alt17)
                {
            	case 1:
            	    // belle_sdp.g:214:27: SPACE sdp_time SPACE ( '-' )? typed_time
            	    {
            	        SPACE103 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_zone_adjustments1488);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezone_adjustmentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE103_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE103));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE103_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_sdp_time_in_zone_adjustments1490);
            	        sdp_time104=sdp_time(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezone_adjustmentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, sdp_time104.tree);

            	        SPACE105 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_zone_adjustments1492);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezone_adjustmentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE105_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE105));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE105_tree);
            	        }

            	        // belle_sdp.g:214:48: ( '-' )?
            	        {
            	            int alt16=2;
            	            switch ( LA(1) )
            	            {
            	                case DASH:
            	                	{
            	                		alt16=1;
            	                	}
            	                    break;
            	            }

            	            switch (alt16)
            	            {
            	        	case 1:
            	        	    // belle_sdp.g:214:48: '-'
            	        	    {
            	        	        char_literal106 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_zone_adjustments1494);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulezone_adjustmentsEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        char_literal106_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal106));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, char_literal106_tree);
            	        	        }

            	        	    }
            	        	    break;

            	            }
            	        }

            	        FOLLOWPUSH(FOLLOW_typed_time_in_zone_adjustments1497);
            	        typed_time107=typed_time(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulezone_adjustmentsEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typed_time107.tree);

            	    }
            	    break;

            	default:
            	    goto loop17;	/* break out of the loop */
            	    break;
                }
            }
            loop17: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulezone_adjustmentsEx; /* Prevent compiler warnings */
    rulezone_adjustmentsEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end zone_adjustments */

/**
 * $ANTLR start key_field
 * belle_sdp.g:216:1: key_field :{...}? alpha_num EQUAL key_value ;
 */
static belle_sdpParser_key_field_return
key_field(pbelle_sdpParser ctx)
{
    belle_sdpParser_key_field_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL109;
    belle_sdpParser_alpha_num_return alpha_num108;
    #undef	RETURN_TYPE_alpha_num108
    #define	RETURN_TYPE_alpha_num108 belle_sdpParser_alpha_num_return

    belle_sdpParser_key_value_return key_value110;
    #undef	RETURN_TYPE_key_value110
    #define	RETURN_TYPE_key_value110 belle_sdpParser_key_value_return

    pANTLR3_BASE_TREE EQUAL109_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL109       = NULL;
    alpha_num108.tree = NULL;

    key_value110.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL109_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:216:10: ({...}? alpha_num EQUAL key_value )
        // belle_sdp.g:216:22: {...}? alpha_num EQUAL key_value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(k))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(k)";
                    EXCEPTION->ruleName	 = (void *)"key_field";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_key_field1517);
            alpha_num108=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekey_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num108.tree);

            EQUAL109 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_key_field1519);
            if  (HASEXCEPTION())
            {
                goto rulekey_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL109_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL109));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL109_tree);
            }

            FOLLOWPUSH(FOLLOW_key_value_in_key_field1521);
            key_value110=key_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulekey_fieldEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, key_value110.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulekey_fieldEx; /* Prevent compiler warnings */
    rulekey_fieldEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end key_field */

/**
 * $ANTLR start key_value
 * belle_sdp.g:217:1: key_value options {greedy=false; } : (~ ( CR | LF ) )* ;
 */
static belle_sdpParser_key_value_return
key_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_key_value_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set111;

    pANTLR3_BASE_TREE set111_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set111       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set111_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:217:38: ( (~ ( CR | LF ) )* )
        // belle_sdp.g:217:47: (~ ( CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:217:47: (~ ( CR | LF ) )*

            for (;;)
            {
                int alt18=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case SPACE:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt18=1;
                	}
                    break;

                }

                switch (alt18)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set111=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set111))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto rulekey_valueEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop18;	/* break out of the loop */
            	    break;
                }
            }
            loop18: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulekey_valueEx; /* Prevent compiler warnings */
    rulekey_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end key_value */

/**
 * $ANTLR start attribute
 * belle_sdp.g:226:1: attribute returns [belle_sdp_attribute_t* ret] :{...}? alpha_num EQUAL attribute_content ;
 */
static belle_sdpParser_attribute_return
attribute(pbelle_sdpParser ctx)
{
    belle_sdpParser_attribute_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL113;
    belle_sdpParser_alpha_num_return alpha_num112;
    #undef	RETURN_TYPE_alpha_num112
    #define	RETURN_TYPE_alpha_num112 belle_sdpParser_alpha_num_return

    belle_sdpParser_attribute_content_return attribute_content114;
    #undef	RETURN_TYPE_attribute_content114
    #define	RETURN_TYPE_attribute_content114 belle_sdpParser_attribute_content_return

    pANTLR3_BASE_TREE EQUAL113_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_attributeTop = pbelle_sdpParser_attributePush(ctx);
    root_0 = NULL;

    retval.ret=NULL;

    EQUAL113       = NULL;
    alpha_num112.tree = NULL;

    attribute_content114.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL113_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:229:3: ({...}? alpha_num EQUAL attribute_content )
        // belle_sdp.g:229:3: {...}? alpha_num EQUAL attribute_content
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(a))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_attributePop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(a)";
                    EXCEPTION->ruleName	 = (void *)"attribute";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_attribute1583);
            alpha_num112=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num112.tree);

            EQUAL113 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_attribute1585);
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL113_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL113));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL113_tree);
            }

            FOLLOWPUSH(FOLLOW_attribute_content_in_attribute1587);
            attribute_content114=attribute_content(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleattributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute_content114.tree);

            if ( BACKTRACKING==0 )
            {
                retval.ret=
                attribute_content114.ret
                ;

            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattributeEx; /* Prevent compiler warnings */
    ruleattributeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       if (retval.ret
	    ) belle_sip_object_unref(retval.ret
	    );
	       retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_attributePop(ctx);

    return retval;
}
/* $ANTLR end attribute */

/**
 * $ANTLR start attribute_content
 * belle_sdp.g:237:1: attribute_content returns [belle_sdp_attribute_t* ret] : attribute_name ( COLON val= attribute_value )? ;
 */
static belle_sdpParser_attribute_content_return
attribute_content(pbelle_sdpParser ctx)
{
    belle_sdpParser_attribute_content_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON116;
    belle_sdpParser_attribute_value_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val belle_sdpParser_attribute_value_return

    belle_sdpParser_attribute_name_return attribute_name115;
    #undef	RETURN_TYPE_attribute_name115
    #define	RETURN_TYPE_attribute_name115 belle_sdpParser_attribute_name_return

    pANTLR3_BASE_TREE COLON116_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    retval.ret=NULL;
     
    COLON116       = NULL;
    val.tree = NULL;

    attribute_name115.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COLON116_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:239:3: ( attribute_name ( COLON val= attribute_value )? )
        // belle_sdp.g:239:3: attribute_name ( COLON val= attribute_value )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_attribute_name_in_attribute_content1611);
            attribute_name115=attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleattribute_contentEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute_name115.tree);

            // belle_sdp.g:239:18: ( COLON val= attribute_value )?
            {
                int alt19=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt19=1;
                    	}
                        break;
                }

                switch (alt19)
                {
            	case 1:
            	    // belle_sdp.g:239:19: COLON val= attribute_value
            	    {
            	        COLON116 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_attribute_content1614);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattribute_contentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON116_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON116));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON116_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_attribute_value_in_attribute_content1618);
            	        val=attribute_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleattribute_contentEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, val.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            retval.ret=belle_sdp_attribute_create((const char*)
            	            (STRSTREAM->toStringTT(STRSTREAM, attribute_name115.start, attribute_name115.stop))
            	            ->chars,(const char*)(STRSTREAM->toStringTT(STRSTREAM, val.start, val.stop))
            	            ->chars);

            	        }


            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                	if (!val.tree) retval.ret=belle_sdp_attribute_create((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, attribute_name115.start, attribute_name115.stop))
                ->chars,NULL);


            }


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattribute_contentEx; /* Prevent compiler warnings */
    ruleattribute_contentEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end attribute_content */

/**
 * $ANTLR start rtcp_xr_attribute
 * belle_sdp.g:244:1: rtcp_xr_attribute returns [belle_sdp_rtcp_xr_attribute_t* ret] :{...}? alpha_num EQUAL {...}? attribute_name ( COLON rtcp_xr_attribute_value ( SPACE rtcp_xr_attribute_value )* )? ;
 */
static belle_sdpParser_rtcp_xr_attribute_return
rtcp_xr_attribute(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_attribute_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL118;
    pANTLR3_COMMON_TOKEN    COLON120;
    pANTLR3_COMMON_TOKEN    SPACE122;
    belle_sdpParser_alpha_num_return alpha_num117;
    #undef	RETURN_TYPE_alpha_num117
    #define	RETURN_TYPE_alpha_num117 belle_sdpParser_alpha_num_return

    belle_sdpParser_attribute_name_return attribute_name119;
    #undef	RETURN_TYPE_attribute_name119
    #define	RETURN_TYPE_attribute_name119 belle_sdpParser_attribute_name_return

    belle_sdpParser_rtcp_xr_attribute_value_return rtcp_xr_attribute_value121;
    #undef	RETURN_TYPE_rtcp_xr_attribute_value121
    #define	RETURN_TYPE_rtcp_xr_attribute_value121 belle_sdpParser_rtcp_xr_attribute_value_return

    belle_sdpParser_rtcp_xr_attribute_value_return rtcp_xr_attribute_value123;
    #undef	RETURN_TYPE_rtcp_xr_attribute_value123
    #define	RETURN_TYPE_rtcp_xr_attribute_value123 belle_sdpParser_rtcp_xr_attribute_value_return

    pANTLR3_BASE_TREE EQUAL118_tree;
    pANTLR3_BASE_TREE COLON120_tree;
    pANTLR3_BASE_TREE SPACE122_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_rtcp_xr_attributeTop = pbelle_sdpParser_rtcp_xr_attributePush(ctx);
    root_0 = NULL;

     (SCOPE_TOP(rtcp_xr_attribute))->current= belle_sdp_rtcp_xr_attribute_new();
    retval.ret= (SCOPE_TOP(rtcp_xr_attribute))->current;

    EQUAL118       = NULL;
    COLON120       = NULL;
    SPACE122       = NULL;
    alpha_num117.tree = NULL;

    attribute_name119.tree = NULL;

    rtcp_xr_attribute_value121.tree = NULL;

    rtcp_xr_attribute_value123.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL118_tree   = NULL;
    COLON120_tree   = NULL;
    SPACE122_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:247:3: ({...}? alpha_num EQUAL {...}? attribute_name ( COLON rtcp_xr_attribute_value ( SPACE rtcp_xr_attribute_value )* )? )
        // belle_sdp.g:247:3: {...}? alpha_num EQUAL {...}? attribute_name ( COLON rtcp_xr_attribute_value ( SPACE rtcp_xr_attribute_value )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(a))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_rtcp_xr_attributePop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(a)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_xr_attribute";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_rtcp_xr_attribute1648);
            alpha_num117=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_xr_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num117.tree);

            EQUAL118 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_rtcp_xr_attribute1650);
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_xr_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL118_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL118));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL118_tree);
            }

            if ( !((IS_TOKEN(rtcp-xr))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_rtcp_xr_attributePop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(rtcp-xr)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_xr_attribute";


            }

            FOLLOWPUSH(FOLLOW_attribute_name_in_rtcp_xr_attribute1654);
            attribute_name119=attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_xr_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute_name119.tree);

            // belle_sdp.g:247:83: ( COLON rtcp_xr_attribute_value ( SPACE rtcp_xr_attribute_value )* )?
            {
                int alt21=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt21=1;
                    	}
                        break;
                }

                switch (alt21)
                {
            	case 1:
            	    // belle_sdp.g:247:84: COLON rtcp_xr_attribute_value ( SPACE rtcp_xr_attribute_value )*
            	    {
            	        COLON120 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_rtcp_xr_attribute1659);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_xr_attributeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_rtcp_xr_attributePop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON120_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON120));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON120_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1661);
            	        rtcp_xr_attribute_value121=rtcp_xr_attribute_value(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_xr_attributeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_rtcp_xr_attributePop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_value121.tree);

            	        // belle_sdp.g:247:114: ( SPACE rtcp_xr_attribute_value )*

            	        for (;;)
            	        {
            	            int alt20=2;
            	            switch ( LA(1) )
            	            {
            	            case SPACE:
            	            	{
            	            		alt20=1;
            	            	}
            	                break;

            	            }

            	            switch (alt20)
            	            {
            	        	case 1:
            	        	    // belle_sdp.g:247:115: SPACE rtcp_xr_attribute_value
            	        	    {
            	        	        SPACE122 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_xr_attribute1664);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulertcp_xr_attributeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sdpParser_rtcp_xr_attributePop(ctx);

            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        SPACE122_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE122));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE122_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_value_in_rtcp_xr_attribute1666);
            	        	        rtcp_xr_attribute_value123=rtcp_xr_attribute_value(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulertcp_xr_attributeEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            pbelle_sdpParser_rtcp_xr_attributePop(ctx);

            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_value123.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop20;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop20: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_attributeEx; /* Prevent compiler warnings */
    rulertcp_xr_attributeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	       belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	       belle_sip_object_unref(retval.ret
	    );
	       retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_rtcp_xr_attributePop(ctx);

    return retval;
}
/* $ANTLR end rtcp_xr_attribute */

/**
 * $ANTLR start rtcp_xr_attribute_value
 * belle_sdp.g:254:1: rtcp_xr_attribute_value : ( ( pkt_loss_rle )=> pkt_loss_rle | ( pkt_dup_rle )=> pkt_dup_rle | ( pkt_rcpt_times )=> pkt_rcpt_times | ( rcvr_rtt )=> rcvr_rtt | ( stat_summary )=> stat_summary | ( voip_metrics )=> voip_metrics );
 */
static belle_sdpParser_rtcp_xr_attribute_value_return
rtcp_xr_attribute_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_attribute_value_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_pkt_loss_rle_return pkt_loss_rle124;
    #undef	RETURN_TYPE_pkt_loss_rle124
    #define	RETURN_TYPE_pkt_loss_rle124 belle_sdpParser_pkt_loss_rle_return

    belle_sdpParser_pkt_dup_rle_return pkt_dup_rle125;
    #undef	RETURN_TYPE_pkt_dup_rle125
    #define	RETURN_TYPE_pkt_dup_rle125 belle_sdpParser_pkt_dup_rle_return

    belle_sdpParser_pkt_rcpt_times_return pkt_rcpt_times126;
    #undef	RETURN_TYPE_pkt_rcpt_times126
    #define	RETURN_TYPE_pkt_rcpt_times126 belle_sdpParser_pkt_rcpt_times_return

    belle_sdpParser_rcvr_rtt_return rcvr_rtt127;
    #undef	RETURN_TYPE_rcvr_rtt127
    #define	RETURN_TYPE_rcvr_rtt127 belle_sdpParser_rcvr_rtt_return

    belle_sdpParser_stat_summary_return stat_summary128;
    #undef	RETURN_TYPE_stat_summary128
    #define	RETURN_TYPE_stat_summary128 belle_sdpParser_stat_summary_return

    belle_sdpParser_voip_metrics_return voip_metrics129;
    #undef	RETURN_TYPE_voip_metrics129
    #define	RETURN_TYPE_voip_metrics129 belle_sdpParser_voip_metrics_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    pkt_loss_rle124.tree = NULL;

    pkt_dup_rle125.tree = NULL;

    pkt_rcpt_times126.tree = NULL;

    rcvr_rtt127.tree = NULL;

    stat_summary128.tree = NULL;

    voip_metrics129.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:254:25: ( ( pkt_loss_rle )=> pkt_loss_rle | ( pkt_dup_rle )=> pkt_dup_rle | ( pkt_rcpt_times )=> pkt_rcpt_times | ( rcvr_rtt )=> rcvr_rtt | ( stat_summary )=> stat_summary | ( voip_metrics )=> voip_metrics )

            ANTLR3_UINT32 alt22;

            alt22=6;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA22_1 = LA(2);
            		    if ( (synpred4_belle_sdp(ctx)) && (LA22_1 == EQUAL))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (synpred4_belle_sdp(ctx)) && (LA22_1 == COMMON_CHAR || LA22_1 == HEX_CHAR))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (synpred4_belle_sdp(ctx)) && (LA22_1 == DASH))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (( (( (synpred1_belle_sdp(ctx)) && (synpred1_belle_sdp(ctx)) )) && ((IS_TOKEN(pkt-loss-rle))) )))
            		    {
            		        alt22=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(pkt-dup-rle))) && ((IS_TOKEN(pkt-dup-rle))) )) && (synpred2_belle_sdp(ctx)) )))
            		    {
            		        alt22=2;
            		    }
            		    else if ( (( (( (synpred3_belle_sdp(ctx)) && (synpred3_belle_sdp(ctx)) )) && ((IS_TOKEN(pkt-rcpt-times))) )))
            		    {
            		        alt22=3;
            		    }
            		    else if ( (( (( ((IS_TOKEN(stat-summary))) && ((IS_TOKEN(stat-summary))) )) && (synpred5_belle_sdp(ctx)) )))
            		    {
            		        alt22=5;
            		    }
            		    else if ( (( (( ((IS_TOKEN(voip-metrics))) && ((IS_TOKEN(voip-metrics))) )) && (synpred6_belle_sdp(ctx)) )))
            		    {
            		        alt22=6;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 22;
            		        EXCEPTION->state        = 1;


            		        goto rulertcp_xr_attribute_valueEx;

            		    }
            		}
            	}
                break;
            case DASH:
            	{
            		{
            		    int LA22_2 = LA(2);
            		    if ( (synpred4_belle_sdp(ctx)) && (LA22_2 == EQUAL))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (synpred4_belle_sdp(ctx)) && (LA22_2 == COMMON_CHAR || LA22_2 == HEX_CHAR))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (synpred4_belle_sdp(ctx)) && (LA22_2 == DASH))
            		    {
            		        alt22=4;
            		    }
            		    else if ( (( (( (synpred1_belle_sdp(ctx)) && (synpred1_belle_sdp(ctx)) )) && ((IS_TOKEN(pkt-loss-rle))) )))
            		    {
            		        alt22=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(pkt-dup-rle))) && ((IS_TOKEN(pkt-dup-rle))) )) && (synpred2_belle_sdp(ctx)) )))
            		    {
            		        alt22=2;
            		    }
            		    else if ( (( (( (synpred3_belle_sdp(ctx)) && (synpred3_belle_sdp(ctx)) )) && ((IS_TOKEN(pkt-rcpt-times))) )))
            		    {
            		        alt22=3;
            		    }
            		    else if ( (( (( ((IS_TOKEN(stat-summary))) && ((IS_TOKEN(stat-summary))) )) && (synpred5_belle_sdp(ctx)) )))
            		    {
            		        alt22=5;
            		    }
            		    else if ( (( (( ((IS_TOKEN(voip-metrics))) && ((IS_TOKEN(voip-metrics))) )) && (synpred6_belle_sdp(ctx)) )))
            		    {
            		        alt22=6;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 22;
            		        EXCEPTION->state        = 2;


            		        goto rulertcp_xr_attribute_valueEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 22;
                EXCEPTION->state        = 0;


                goto rulertcp_xr_attribute_valueEx;

            }

            switch (alt22)
            {
        	case 1:
        	    // belle_sdp.g:255:2: ( pkt_loss_rle )=> pkt_loss_rle
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_pkt_loss_rle_in_rtcp_xr_attribute_value1689);
        	        pkt_loss_rle124=pkt_loss_rle(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, pkt_loss_rle124.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:256:3: ( pkt_dup_rle )=> pkt_dup_rle
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_pkt_dup_rle_in_rtcp_xr_attribute_value1698);
        	        pkt_dup_rle125=pkt_dup_rle(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, pkt_dup_rle125.tree);

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:257:3: ( pkt_rcpt_times )=> pkt_rcpt_times
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_pkt_rcpt_times_in_rtcp_xr_attribute_value1707);
        	        pkt_rcpt_times126=pkt_rcpt_times(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, pkt_rcpt_times126.tree);

        	    }
        	    break;
        	case 4:
        	    // belle_sdp.g:258:3: ( rcvr_rtt )=> rcvr_rtt
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rcvr_rtt_in_rtcp_xr_attribute_value1716);
        	        rcvr_rtt127=rcvr_rtt(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rcvr_rtt127.tree);

        	    }
        	    break;
        	case 5:
        	    // belle_sdp.g:259:3: ( stat_summary )=> stat_summary
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_stat_summary_in_rtcp_xr_attribute_value1725);
        	        stat_summary128=stat_summary(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, stat_summary128.tree);

        	    }
        	    break;
        	case 6:
        	    // belle_sdp.g:260:3: ( voip_metrics )=> voip_metrics
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_voip_metrics_in_rtcp_xr_attribute_value1734);
        	        voip_metrics129=voip_metrics(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_xr_attribute_valueEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, voip_metrics129.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_attribute_valueEx; /* Prevent compiler warnings */
    rulertcp_xr_attribute_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_attribute_value */

/**
 * $ANTLR start pkt_loss_rle
 * belle_sdp.g:262:1: pkt_loss_rle :{...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? ;
 */
static belle_sdpParser_pkt_loss_rle_return
pkt_loss_rle(pbelle_sdpParser ctx)
{
    belle_sdpParser_pkt_loss_rle_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL131;
    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name130;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name130
    #define	RETURN_TYPE_rtcp_xr_attribute_name130 belle_sdpParser_rtcp_xr_attribute_name_return

    belle_sdpParser_rtcp_xr_max_size_return rtcp_xr_max_size132;
    #undef	RETURN_TYPE_rtcp_xr_max_size132
    #define	RETURN_TYPE_rtcp_xr_max_size132 belle_sdpParser_rtcp_xr_max_size_return

    pANTLR3_BASE_TREE EQUAL131_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL131       = NULL;
    rtcp_xr_attribute_name130.tree = NULL;

    rtcp_xr_max_size132.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL131_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:262:14: ({...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? )
        // belle_sdp.g:263:2: {...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(pkt-loss-rle))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(pkt-loss-rle)";
                    EXCEPTION->ruleName	 = (void *)"pkt_loss_rle";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_pkt_loss_rle1745);
            rtcp_xr_attribute_name130=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepkt_loss_rleEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name130.tree);

            // belle_sdp.g:263:70: ( EQUAL rtcp_xr_max_size )?
            {
                int alt23=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt23=1;
                    	}
                        break;
                }

                switch (alt23)
                {
            	case 1:
            	    // belle_sdp.g:263:71: EQUAL rtcp_xr_max_size
            	    {
            	        EQUAL131 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_pkt_loss_rle1750);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_loss_rleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        EQUAL131_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL131));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EQUAL131_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_max_size_in_pkt_loss_rle1752);
            	        rtcp_xr_max_size132=rtcp_xr_max_size(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_loss_rleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_max_size132.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepkt_loss_rleEx; /* Prevent compiler warnings */
    rulepkt_loss_rleEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end pkt_loss_rle */

/**
 * $ANTLR start pkt_dup_rle
 * belle_sdp.g:265:1: pkt_dup_rle :{...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? ;
 */
static belle_sdpParser_pkt_dup_rle_return
pkt_dup_rle(pbelle_sdpParser ctx)
{
    belle_sdpParser_pkt_dup_rle_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL134;
    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name133;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name133
    #define	RETURN_TYPE_rtcp_xr_attribute_name133 belle_sdpParser_rtcp_xr_attribute_name_return

    belle_sdpParser_rtcp_xr_max_size_return rtcp_xr_max_size135;
    #undef	RETURN_TYPE_rtcp_xr_max_size135
    #define	RETURN_TYPE_rtcp_xr_max_size135 belle_sdpParser_rtcp_xr_max_size_return

    pANTLR3_BASE_TREE EQUAL134_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL134       = NULL;
    rtcp_xr_attribute_name133.tree = NULL;

    rtcp_xr_max_size135.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL134_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:265:13: ({...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? )
        // belle_sdp.g:266:2: {...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(pkt-dup-rle))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(pkt-dup-rle)";
                    EXCEPTION->ruleName	 = (void *)"pkt_dup_rle";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_pkt_dup_rle1766);
            rtcp_xr_attribute_name133=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepkt_dup_rleEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name133.tree);

            // belle_sdp.g:266:68: ( EQUAL rtcp_xr_max_size )?
            {
                int alt24=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt24=1;
                    	}
                        break;
                }

                switch (alt24)
                {
            	case 1:
            	    // belle_sdp.g:266:69: EQUAL rtcp_xr_max_size
            	    {
            	        EQUAL134 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_pkt_dup_rle1771);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_dup_rleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        EQUAL134_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL134));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EQUAL134_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_max_size_in_pkt_dup_rle1773);
            	        rtcp_xr_max_size135=rtcp_xr_max_size(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_dup_rleEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_max_size135.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepkt_dup_rleEx; /* Prevent compiler warnings */
    rulepkt_dup_rleEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end pkt_dup_rle */

/**
 * $ANTLR start pkt_rcpt_times
 * belle_sdp.g:268:1: pkt_rcpt_times :{...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? ;
 */
static belle_sdpParser_pkt_rcpt_times_return
pkt_rcpt_times(pbelle_sdpParser ctx)
{
    belle_sdpParser_pkt_rcpt_times_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL137;
    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name136;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name136
    #define	RETURN_TYPE_rtcp_xr_attribute_name136 belle_sdpParser_rtcp_xr_attribute_name_return

    belle_sdpParser_rtcp_xr_max_size_return rtcp_xr_max_size138;
    #undef	RETURN_TYPE_rtcp_xr_max_size138
    #define	RETURN_TYPE_rtcp_xr_max_size138 belle_sdpParser_rtcp_xr_max_size_return

    pANTLR3_BASE_TREE EQUAL137_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL137       = NULL;
    rtcp_xr_attribute_name136.tree = NULL;

    rtcp_xr_max_size138.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL137_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:268:16: ({...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )? )
        // belle_sdp.g:269:2: {...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_max_size )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(pkt-rcpt-times))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(pkt-rcpt-times)";
                    EXCEPTION->ruleName	 = (void *)"pkt_rcpt_times";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_pkt_rcpt_times1787);
            rtcp_xr_attribute_name136=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulepkt_rcpt_timesEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name136.tree);

            // belle_sdp.g:269:74: ( EQUAL rtcp_xr_max_size )?
            {
                int alt25=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt25=1;
                    	}
                        break;
                }

                switch (alt25)
                {
            	case 1:
            	    // belle_sdp.g:269:75: EQUAL rtcp_xr_max_size
            	    {
            	        EQUAL137 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_pkt_rcpt_times1792);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_rcpt_timesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        EQUAL137_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL137));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EQUAL137_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_max_size_in_pkt_rcpt_times1794);
            	        rtcp_xr_max_size138=rtcp_xr_max_size(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulepkt_rcpt_timesEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_max_size138.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulepkt_rcpt_timesEx; /* Prevent compiler warnings */
    rulepkt_rcpt_timesEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end pkt_rcpt_times */

/**
 * $ANTLR start rcvr_rtt
 * belle_sdp.g:271:1: rcvr_rtt :{...}? rtcp_xr_attribute_name EQUAL {...}? rtcp_xr_rcvr_rtt_mode ( COLON val= rtcp_xr_max_size )? ;
 */
static belle_sdpParser_rcvr_rtt_return
rcvr_rtt(pbelle_sdpParser ctx)
{
    belle_sdpParser_rcvr_rtt_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL140;
    pANTLR3_COMMON_TOKEN    COLON142;
    belle_sdpParser_rtcp_xr_max_size_return val;
    #undef	RETURN_TYPE_val
    #define	RETURN_TYPE_val belle_sdpParser_rtcp_xr_max_size_return

    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name139;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name139
    #define	RETURN_TYPE_rtcp_xr_attribute_name139 belle_sdpParser_rtcp_xr_attribute_name_return

    belle_sdpParser_rtcp_xr_rcvr_rtt_mode_return rtcp_xr_rcvr_rtt_mode141;
    #undef	RETURN_TYPE_rtcp_xr_rcvr_rtt_mode141
    #define	RETURN_TYPE_rtcp_xr_rcvr_rtt_mode141 belle_sdpParser_rtcp_xr_rcvr_rtt_mode_return

    pANTLR3_BASE_TREE EQUAL140_tree;
    pANTLR3_BASE_TREE COLON142_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL140       = NULL;
    COLON142       = NULL;
    val.tree = NULL;

    rtcp_xr_attribute_name139.tree = NULL;

    rtcp_xr_rcvr_rtt_mode141.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL140_tree   = NULL;
    COLON142_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:271:10: ({...}? rtcp_xr_attribute_name EQUAL {...}? rtcp_xr_rcvr_rtt_mode ( COLON val= rtcp_xr_max_size )? )
        // belle_sdp.g:272:2: {...}? rtcp_xr_attribute_name EQUAL {...}? rtcp_xr_rcvr_rtt_mode ( COLON val= rtcp_xr_max_size )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(rcvr-rtt))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(rcvr-rtt)";
                    EXCEPTION->ruleName	 = (void *)"rcvr_rtt";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_rcvr_rtt1808);
            rtcp_xr_attribute_name139=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulercvr_rttEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name139.tree);

            EQUAL140 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_rcvr_rtt1812);
            if  (HASEXCEPTION())
            {
                goto rulercvr_rttEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL140_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL140));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL140_tree);
            }

            if ( !((IS_TOKEN(all) || IS_TOKEN(sender))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(all) || IS_TOKEN(sender)";
                    EXCEPTION->ruleName	 = (void *)"rcvr_rtt";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_rcvr_rtt_mode_in_rcvr_rtt1816);
            rtcp_xr_rcvr_rtt_mode141=rtcp_xr_rcvr_rtt_mode(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulercvr_rttEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_rcvr_rtt_mode141.tree);

            // belle_sdp.g:272:127: ( COLON val= rtcp_xr_max_size )?
            {
                int alt26=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt26=1;
                    	}
                        break;
                }

                switch (alt26)
                {
            	case 1:
            	    // belle_sdp.g:272:128: COLON val= rtcp_xr_max_size
            	    {
            	        COLON142 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_rcvr_rtt1819);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulercvr_rttEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON142_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON142));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON142_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_max_size_in_rcvr_rtt1823);
            	        val=rtcp_xr_max_size(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulercvr_rttEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, val.tree);

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_xr_attribute_set_rcvr_rtt_mode((SCOPE_TOP(rtcp_xr_attribute))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, rtcp_xr_rcvr_rtt_mode141.start, rtcp_xr_rcvr_rtt_mode141.stop))
                ->chars);
                		if (val.tree) belle_sdp_rtcp_xr_attribute_set_rcvr_rtt_max_size((SCOPE_TOP(rtcp_xr_attribute))->current,atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, val.start, val.stop))
                ->chars));
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulercvr_rttEx; /* Prevent compiler warnings */
    rulercvr_rttEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rcvr_rtt */

/**
 * $ANTLR start stat_summary
 * belle_sdp.g:277:1: stat_summary :{...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_stat_summary_flag ( COMMA rtcp_xr_stat_summary_flag )* )? ;
 */
static belle_sdpParser_stat_summary_return
stat_summary(pbelle_sdpParser ctx)
{
    belle_sdpParser_stat_summary_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL144;
    pANTLR3_COMMON_TOKEN    COMMA146;
    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name143;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name143
    #define	RETURN_TYPE_rtcp_xr_attribute_name143 belle_sdpParser_rtcp_xr_attribute_name_return

    belle_sdpParser_rtcp_xr_stat_summary_flag_return rtcp_xr_stat_summary_flag145;
    #undef	RETURN_TYPE_rtcp_xr_stat_summary_flag145
    #define	RETURN_TYPE_rtcp_xr_stat_summary_flag145 belle_sdpParser_rtcp_xr_stat_summary_flag_return

    belle_sdpParser_rtcp_xr_stat_summary_flag_return rtcp_xr_stat_summary_flag147;
    #undef	RETURN_TYPE_rtcp_xr_stat_summary_flag147
    #define	RETURN_TYPE_rtcp_xr_stat_summary_flag147 belle_sdpParser_rtcp_xr_stat_summary_flag_return

    pANTLR3_BASE_TREE EQUAL144_tree;
    pANTLR3_BASE_TREE COMMA146_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    EQUAL144       = NULL;
    COMMA146       = NULL;
    rtcp_xr_attribute_name143.tree = NULL;

    rtcp_xr_stat_summary_flag145.tree = NULL;

    rtcp_xr_stat_summary_flag147.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL144_tree   = NULL;
    COMMA146_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:277:14: ({...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_stat_summary_flag ( COMMA rtcp_xr_stat_summary_flag )* )? )
        // belle_sdp.g:278:2: {...}? rtcp_xr_attribute_name ( EQUAL rtcp_xr_stat_summary_flag ( COMMA rtcp_xr_stat_summary_flag )* )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(stat-summary))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(stat-summary)";
                    EXCEPTION->ruleName	 = (void *)"stat_summary";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_stat_summary1838);
            rtcp_xr_attribute_name143=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulestat_summaryEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name143.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_xr_attribute_set_stat_summary((SCOPE_TOP(rtcp_xr_attribute))->current,1);
                	
            }


            // belle_sdp.g:280:4: ( EQUAL rtcp_xr_stat_summary_flag ( COMMA rtcp_xr_stat_summary_flag )* )?
            {
                int alt28=2;
                switch ( LA(1) )
                {
                    case EQUAL:
                    	{
                    		alt28=1;
                    	}
                        break;
                }

                switch (alt28)
                {
            	case 1:
            	    // belle_sdp.g:280:5: EQUAL rtcp_xr_stat_summary_flag ( COMMA rtcp_xr_stat_summary_flag )*
            	    {
            	        EQUAL144 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_stat_summary1845);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestat_summaryEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        EQUAL144_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL144));
            	        ADAPTOR->addChild(ADAPTOR, root_0, EQUAL144_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1847);
            	        rtcp_xr_stat_summary_flag145=rtcp_xr_stat_summary_flag(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulestat_summaryEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_stat_summary_flag145.tree);

            	        // belle_sdp.g:280:37: ( COMMA rtcp_xr_stat_summary_flag )*

            	        for (;;)
            	        {
            	            int alt27=2;
            	            switch ( LA(1) )
            	            {
            	            case COMMA:
            	            	{
            	            		alt27=1;
            	            	}
            	                break;

            	            }

            	            switch (alt27)
            	            {
            	        	case 1:
            	        	    // belle_sdp.g:280:38: COMMA rtcp_xr_stat_summary_flag
            	        	    {
            	        	        COMMA146 = (pANTLR3_COMMON_TOKEN) MATCHT(COMMA, &FOLLOW_COMMA_in_stat_summary1850);
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestat_summaryEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) {
            	        	        COMMA146_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COMMA146));
            	        	        ADAPTOR->addChild(ADAPTOR, root_0, COMMA146_tree);
            	        	        }

            	        	        FOLLOWPUSH(FOLLOW_rtcp_xr_stat_summary_flag_in_stat_summary1852);
            	        	        rtcp_xr_stat_summary_flag147=rtcp_xr_stat_summary_flag(ctx);

            	        	        FOLLOWPOP();
            	        	        if  (HASEXCEPTION())
            	        	        {
            	        	            goto rulestat_summaryEx;
            	        	        }
            	        	        if (HASFAILED())
            	        	        {
            	        	            return retval;
            	        	        }

            	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_stat_summary_flag147.tree);

            	        	    }
            	        	    break;

            	        	default:
            	        	    goto loop27;	/* break out of the loop */
            	        	    break;
            	            }
            	        }
            	        loop27: ; /* Jump out to here if this rule does not match */


            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestat_summaryEx; /* Prevent compiler warnings */
    rulestat_summaryEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end stat_summary */

/**
 * $ANTLR start voip_metrics
 * belle_sdp.g:282:1: voip_metrics :{...}? rtcp_xr_attribute_name ;
 */
static belle_sdpParser_voip_metrics_return
voip_metrics(pbelle_sdpParser ctx)
{
    belle_sdpParser_voip_metrics_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_xr_attribute_name_return rtcp_xr_attribute_name148;
    #undef	RETURN_TYPE_rtcp_xr_attribute_name148
    #define	RETURN_TYPE_rtcp_xr_attribute_name148 belle_sdpParser_rtcp_xr_attribute_name_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_xr_attribute_name148.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:282:14: ({...}? rtcp_xr_attribute_name )
        // belle_sdp.g:283:2: {...}? rtcp_xr_attribute_name
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(voip-metrics))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(voip-metrics)";
                    EXCEPTION->ruleName	 = (void *)"voip_metrics";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_attribute_name_in_voip_metrics1867);
            rtcp_xr_attribute_name148=rtcp_xr_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulevoip_metricsEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_attribute_name148.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_xr_attribute_set_voip_metrics((SCOPE_TOP(rtcp_xr_attribute))->current,1);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulevoip_metricsEx; /* Prevent compiler warnings */
    rulevoip_metricsEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end voip_metrics */

/**
 * $ANTLR start rtcp_xr_stat_summary_flag
 * belle_sdp.g:287:1: rtcp_xr_stat_summary_flag :{...}? rtcp_xr_stat_summary_flag_value ;
 */
static belle_sdpParser_rtcp_xr_stat_summary_flag_return
rtcp_xr_stat_summary_flag(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_stat_summary_flag_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_xr_stat_summary_flag_value_return rtcp_xr_stat_summary_flag_value149;
    #undef	RETURN_TYPE_rtcp_xr_stat_summary_flag_value149
    #define	RETURN_TYPE_rtcp_xr_stat_summary_flag_value149 belle_sdpParser_rtcp_xr_stat_summary_flag_value_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_xr_stat_summary_flag_value149.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:287:27: ({...}? rtcp_xr_stat_summary_flag_value )
        // belle_sdp.g:288:2: {...}? rtcp_xr_stat_summary_flag_value
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(loss) || IS_TOKEN(dup) || IS_TOKEN(jitt) || IS_TOKEN(TTL) || IS_TOKEN(HL))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(loss) || IS_TOKEN(dup) || IS_TOKEN(jitt) || IS_TOKEN(TTL) || IS_TOKEN(HL)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_xr_stat_summary_flag";


            }

            FOLLOWPUSH(FOLLOW_rtcp_xr_stat_summary_flag_value_in_rtcp_xr_stat_summary_flag1881);
            rtcp_xr_stat_summary_flag_value149=rtcp_xr_stat_summary_flag_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_stat_summary_flagEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_xr_stat_summary_flag_value149.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_xr_attribute_add_stat_summary_flag((SCOPE_TOP(rtcp_xr_attribute))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, rtcp_xr_stat_summary_flag_value149.start, rtcp_xr_stat_summary_flag_value149.stop))
                ->chars);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_stat_summary_flagEx; /* Prevent compiler warnings */
    rulertcp_xr_stat_summary_flagEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_stat_summary_flag */

/**
 * $ANTLR start rtcp_xr_max_size
 * belle_sdp.g:292:1: rtcp_xr_max_size : ( DIGIT )+ ;
 */
static belle_sdpParser_rtcp_xr_max_size_return
rtcp_xr_max_size(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_max_size_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT150;

    pANTLR3_BASE_TREE DIGIT150_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT150       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT150_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:292:18: ( ( DIGIT )+ )
        // belle_sdp.g:292:20: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:292:20: ( DIGIT )+
            {
                int cnt29=0;

                for (;;)
                {
                    int alt29=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt29=1;
            		}
            	    break;

            	}

            	switch (alt29)
            	{
            	    case 1:
            	        // belle_sdp.g:292:20: DIGIT
            	        {
            	            DIGIT150 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_rtcp_xr_max_size1891);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulertcp_xr_max_sizeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT150_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT150));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT150_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt29 >= 1 )
            		{
            		    goto loop29;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulertcp_xr_max_sizeEx;
            	}
            	cnt29++;
                }
                loop29: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_max_sizeEx; /* Prevent compiler warnings */
    rulertcp_xr_max_sizeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_max_size */

/**
 * $ANTLR start rtcp_fb_attribute
 * belle_sdp.g:294:1: rtcp_fb_attribute returns [belle_sdp_rtcp_fb_attribute_t* ret] :{...}? alpha_num EQUAL {...}? attribute_name COLON rtcp_fb_pt SPACE rtcp_fb_val ;
 */
static belle_sdpParser_rtcp_fb_attribute_return
rtcp_fb_attribute(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_attribute_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL152;
    pANTLR3_COMMON_TOKEN    COLON154;
    pANTLR3_COMMON_TOKEN    SPACE156;
    belle_sdpParser_alpha_num_return alpha_num151;
    #undef	RETURN_TYPE_alpha_num151
    #define	RETURN_TYPE_alpha_num151 belle_sdpParser_alpha_num_return

    belle_sdpParser_attribute_name_return attribute_name153;
    #undef	RETURN_TYPE_attribute_name153
    #define	RETURN_TYPE_attribute_name153 belle_sdpParser_attribute_name_return

    belle_sdpParser_rtcp_fb_pt_return rtcp_fb_pt155;
    #undef	RETURN_TYPE_rtcp_fb_pt155
    #define	RETURN_TYPE_rtcp_fb_pt155 belle_sdpParser_rtcp_fb_pt_return

    belle_sdpParser_rtcp_fb_val_return rtcp_fb_val157;
    #undef	RETURN_TYPE_rtcp_fb_val157
    #define	RETURN_TYPE_rtcp_fb_val157 belle_sdpParser_rtcp_fb_val_return

    pANTLR3_BASE_TREE EQUAL152_tree;
    pANTLR3_BASE_TREE COLON154_tree;
    pANTLR3_BASE_TREE SPACE156_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_rtcp_fb_attributeTop = pbelle_sdpParser_rtcp_fb_attributePush(ctx);
    root_0 = NULL;

     (SCOPE_TOP(rtcp_fb_attribute))->current= belle_sdp_rtcp_fb_attribute_new();
    retval.ret= (SCOPE_TOP(rtcp_fb_attribute))->current;

    EQUAL152       = NULL;
    COLON154       = NULL;
    SPACE156       = NULL;
    alpha_num151.tree = NULL;

    attribute_name153.tree = NULL;

    rtcp_fb_pt155.tree = NULL;

    rtcp_fb_val157.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL152_tree   = NULL;
    COLON154_tree   = NULL;
    SPACE156_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:297:3: ({...}? alpha_num EQUAL {...}? attribute_name COLON rtcp_fb_pt SPACE rtcp_fb_val )
        // belle_sdp.g:297:3: {...}? alpha_num EQUAL {...}? attribute_name COLON rtcp_fb_pt SPACE rtcp_fb_val
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(a))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(a)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_attribute";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_rtcp_fb_attribute1914);
            alpha_num151=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num151.tree);

            EQUAL152 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_rtcp_fb_attribute1916);
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL152_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL152));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL152_tree);
            }

            if ( !((IS_TOKEN(rtcp-fb))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(rtcp-fb)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_attribute";


            }

            FOLLOWPUSH(FOLLOW_attribute_name_in_rtcp_fb_attribute1920);
            attribute_name153=attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute_name153.tree);

            COLON154 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_rtcp_fb_attribute1924);
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            COLON154_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON154));
            ADAPTOR->addChild(ADAPTOR, root_0, COLON154_tree);
            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_pt_in_rtcp_fb_attribute1926);
            rtcp_fb_pt155=rtcp_fb_pt(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_pt155.tree);

            SPACE156 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_attribute1928);
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE156_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE156));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE156_tree);
            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_val_in_rtcp_fb_attribute1930);
            rtcp_fb_val157=rtcp_fb_val(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attributeEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_rtcp_fb_attributePop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_val157.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_attributeEx; /* Prevent compiler warnings */
    rulertcp_fb_attributeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	    	belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	    	belle_sip_object_unref(retval.ret
	    );
	    	retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_rtcp_fb_attributePop(ctx);

    return retval;
}
/* $ANTLR end rtcp_fb_attribute */

/**
 * $ANTLR start rtcp_fb_pt
 * belle_sdp.g:305:1: rtcp_fb_pt : ( STAR | integer );
 */
static belle_sdpParser_rtcp_fb_pt_return
rtcp_fb_pt(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_pt_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    STAR158;
    belle_sdpParser_integer_return integer159;
    #undef	RETURN_TYPE_integer159
    #define	RETURN_TYPE_integer159 belle_sdpParser_integer_return

    pANTLR3_BASE_TREE STAR158_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    STAR158       = NULL;
    integer159.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    STAR158_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:305:11: ( STAR | integer )

            ANTLR3_UINT32 alt30;

            alt30=2;

            switch ( LA(1) )
            {
            case STAR:
            	{
            		alt30=1;
            	}
                break;
            case DIGIT:
            	{
            		alt30=2;
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 30;
                EXCEPTION->state        = 0;


                goto rulertcp_fb_ptEx;

            }

            switch (alt30)
            {
        	case 1:
        	    // belle_sdp.g:305:13: STAR
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        STAR158 = (pANTLR3_COMMON_TOKEN) MATCHT(STAR, &FOLLOW_STAR_in_rtcp_fb_pt1943);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ptEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        STAR158_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STAR158));
        	        ADAPTOR->addChild(ADAPTOR, root_0, STAR158_tree);
        	        }

        	        if ( BACKTRACKING==0 )
        	        {

        	            	belle_sdp_rtcp_fb_attribute_set_id((SCOPE_TOP(rtcp_fb_attribute))->current,-1);

        	        }


        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:307:5: integer
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_integer_in_rtcp_fb_pt1949);
        	        integer159=integer(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ptEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integer159.tree);

        	        if ( BACKTRACKING==0 )
        	        {

        	            	belle_sdp_rtcp_fb_attribute_set_id((SCOPE_TOP(rtcp_fb_attribute))->current,atoi((const char*)
        	            (STRSTREAM->toStringTT(STRSTREAM, integer159.start, integer159.stop))
        	            ->chars));

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_ptEx; /* Prevent compiler warnings */
    rulertcp_fb_ptEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_pt */

/**
 * $ANTLR start rtcp_fb_val
 * belle_sdp.g:311:1: rtcp_fb_val : ( ( rtcp_fb_ack_val )=> rtcp_fb_ack_val | ( rtcp_fb_nack_val )=> rtcp_fb_nack_val | ( rtcp_fb_trr_int_val )=> rtcp_fb_trr_int_val | ( rtcp_fb_ccm_val )=> rtcp_fb_ccm_val | ( rtcp_fb_id_val )=> rtcp_fb_id_val );
 */
static belle_sdpParser_rtcp_fb_val_return
rtcp_fb_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_val_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_ack_val_return rtcp_fb_ack_val160;
    #undef	RETURN_TYPE_rtcp_fb_ack_val160
    #define	RETURN_TYPE_rtcp_fb_ack_val160 belle_sdpParser_rtcp_fb_ack_val_return

    belle_sdpParser_rtcp_fb_nack_val_return rtcp_fb_nack_val161;
    #undef	RETURN_TYPE_rtcp_fb_nack_val161
    #define	RETURN_TYPE_rtcp_fb_nack_val161 belle_sdpParser_rtcp_fb_nack_val_return

    belle_sdpParser_rtcp_fb_trr_int_val_return rtcp_fb_trr_int_val162;
    #undef	RETURN_TYPE_rtcp_fb_trr_int_val162
    #define	RETURN_TYPE_rtcp_fb_trr_int_val162 belle_sdpParser_rtcp_fb_trr_int_val_return

    belle_sdpParser_rtcp_fb_ccm_val_return rtcp_fb_ccm_val163;
    #undef	RETURN_TYPE_rtcp_fb_ccm_val163
    #define	RETURN_TYPE_rtcp_fb_ccm_val163 belle_sdpParser_rtcp_fb_ccm_val_return

    belle_sdpParser_rtcp_fb_id_val_return rtcp_fb_id_val164;
    #undef	RETURN_TYPE_rtcp_fb_id_val164
    #define	RETURN_TYPE_rtcp_fb_id_val164 belle_sdpParser_rtcp_fb_id_val_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_ack_val160.tree = NULL;

    rtcp_fb_nack_val161.tree = NULL;

    rtcp_fb_trr_int_val162.tree = NULL;

    rtcp_fb_ccm_val163.tree = NULL;

    rtcp_fb_id_val164.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:311:13: ( ( rtcp_fb_ack_val )=> rtcp_fb_ack_val | ( rtcp_fb_nack_val )=> rtcp_fb_nack_val | ( rtcp_fb_trr_int_val )=> rtcp_fb_trr_int_val | ( rtcp_fb_ccm_val )=> rtcp_fb_ccm_val | ( rtcp_fb_id_val )=> rtcp_fb_id_val )

            ANTLR3_UINT32 alt31;

            alt31=5;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA31_1 = LA(2);
            		    if ( (synpred9_belle_sdp(ctx)) && (LA31_1 == SPACE))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (synpred9_belle_sdp(ctx)) && (LA31_1 == COMMON_CHAR || LA31_1 == HEX_CHAR))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (synpred9_belle_sdp(ctx)) && (LA31_1 == DASH))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (( (( (synpred7_belle_sdp(ctx)) && (synpred7_belle_sdp(ctx)) )) && ((IS_TOKEN(ack))) )))
            		    {
            		        alt31=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(nack))) && ((IS_TOKEN(nack))) )) && (synpred8_belle_sdp(ctx)) )))
            		    {
            		        alt31=2;
            		    }
            		    else if ( (( (( (synpred10_belle_sdp(ctx)) && (synpred10_belle_sdp(ctx)) )) && ((IS_TOKEN(ccm))) )))
            		    {
            		        alt31=4;
            		    }
            		    else if ( (synpred11_belle_sdp(ctx)))
            		    {
            		        alt31=5;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 31;
            		        EXCEPTION->state        = 1;


            		        goto rulertcp_fb_valEx;

            		    }
            		}
            	}
                break;
            case DASH:
            	{
            		{
            		    int LA31_2 = LA(2);
            		    if ( (synpred9_belle_sdp(ctx)) && (LA31_2 == SPACE))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (synpred9_belle_sdp(ctx)) && (LA31_2 == COMMON_CHAR || LA31_2 == HEX_CHAR))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (synpred9_belle_sdp(ctx)) && (LA31_2 == DASH))
            		    {
            		        alt31=3;
            		    }
            		    else if ( (( (( (synpred7_belle_sdp(ctx)) && (synpred7_belle_sdp(ctx)) )) && ((IS_TOKEN(ack))) )))
            		    {
            		        alt31=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(nack))) && ((IS_TOKEN(nack))) )) && (synpred8_belle_sdp(ctx)) )))
            		    {
            		        alt31=2;
            		    }
            		    else if ( (( (( (synpred10_belle_sdp(ctx)) && (synpred10_belle_sdp(ctx)) )) && ((IS_TOKEN(ccm))) )))
            		    {
            		        alt31=4;
            		    }
            		    else if ( (synpred11_belle_sdp(ctx)))
            		    {
            		        alt31=5;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 31;
            		        EXCEPTION->state        = 2;


            		        goto rulertcp_fb_valEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 31;
                EXCEPTION->state        = 0;


                goto rulertcp_fb_valEx;

            }

            switch (alt31)
            {
        	case 1:
        	    // belle_sdp.g:312:2: ( rtcp_fb_ack_val )=> rtcp_fb_ack_val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_ack_val_in_rtcp_fb_val1964);
        	        rtcp_fb_ack_val160=rtcp_fb_ack_val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_valEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_ack_val160.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:313:3: ( rtcp_fb_nack_val )=> rtcp_fb_nack_val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_nack_val_in_rtcp_fb_val1972);
        	        rtcp_fb_nack_val161=rtcp_fb_nack_val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_valEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_nack_val161.tree);

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:314:3: ( rtcp_fb_trr_int_val )=> rtcp_fb_trr_int_val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_trr_int_val_in_rtcp_fb_val1980);
        	        rtcp_fb_trr_int_val162=rtcp_fb_trr_int_val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_valEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_trr_int_val162.tree);

        	    }
        	    break;
        	case 4:
        	    // belle_sdp.g:315:3: ( rtcp_fb_ccm_val )=> rtcp_fb_ccm_val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_ccm_val_in_rtcp_fb_val1988);
        	        rtcp_fb_ccm_val163=rtcp_fb_ccm_val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_valEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_ccm_val163.tree);

        	    }
        	    break;
        	case 5:
        	    // belle_sdp.g:316:3: ( rtcp_fb_id_val )=> rtcp_fb_id_val
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_id_val_in_rtcp_fb_val1996);
        	        rtcp_fb_id_val164=rtcp_fb_id_val(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_valEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_id_val164.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_valEx; /* Prevent compiler warnings */
    rulertcp_fb_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_val */

/**
 * $ANTLR start rtcp_fb_ack_val
 * belle_sdp.g:318:1: rtcp_fb_ack_val :{...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ack_param )? ;
 */
static belle_sdpParser_rtcp_fb_ack_val_return
rtcp_fb_ack_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_ack_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE166;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name165;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name165
    #define	RETURN_TYPE_rtcp_fb_attribute_name165 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_rtcp_fb_ack_param_return rtcp_fb_ack_param167;
    #undef	RETURN_TYPE_rtcp_fb_ack_param167
    #define	RETURN_TYPE_rtcp_fb_ack_param167 belle_sdpParser_rtcp_fb_ack_param_return

    pANTLR3_BASE_TREE SPACE166_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE166       = NULL;
    rtcp_fb_attribute_name165.tree = NULL;

    rtcp_fb_ack_param167.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE166_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:318:16: ({...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ack_param )? )
        // belle_sdp.g:319:2: {...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ack_param )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(ack))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(ack)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_ack_val";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ack_val2006);
            rtcp_fb_attribute_name165=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_ack_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name165.tree);

            // belle_sdp.g:319:52: ( SPACE rtcp_fb_ack_param )?
            {
                int alt32=2;
                switch ( LA(1) )
                {
                    case SPACE:
                    	{
                    		alt32=1;
                    	}
                        break;
                }

                switch (alt32)
                {
            	case 1:
            	    // belle_sdp.g:319:53: SPACE rtcp_fb_ack_param
            	    {
            	        SPACE166 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_ack_val2011);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_ack_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE166_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE166));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE166_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_fb_ack_param_in_rtcp_fb_ack_val2013);
            	        rtcp_fb_ack_param167=rtcp_fb_ack_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_ack_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_ack_param167.tree);

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_type((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_ACK);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_ack_valEx; /* Prevent compiler warnings */
    rulertcp_fb_ack_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_ack_val */

/**
 * $ANTLR start rtcp_fb_nack_val
 * belle_sdp.g:323:1: rtcp_fb_nack_val :{...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_nack_param )? ;
 */
static belle_sdpParser_rtcp_fb_nack_val_return
rtcp_fb_nack_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_nack_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE169;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name168;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name168
    #define	RETURN_TYPE_rtcp_fb_attribute_name168 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_rtcp_fb_nack_param_return rtcp_fb_nack_param170;
    #undef	RETURN_TYPE_rtcp_fb_nack_param170
    #define	RETURN_TYPE_rtcp_fb_nack_param170 belle_sdpParser_rtcp_fb_nack_param_return

    pANTLR3_BASE_TREE SPACE169_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE169       = NULL;
    rtcp_fb_attribute_name168.tree = NULL;

    rtcp_fb_nack_param170.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE169_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:323:17: ({...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_nack_param )? )
        // belle_sdp.g:324:2: {...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_nack_param )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(nack))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(nack)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_nack_val";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_nack_val2027);
            rtcp_fb_attribute_name168=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_nack_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name168.tree);

            // belle_sdp.g:324:54: ( SPACE rtcp_fb_nack_param )?
            {
                int alt33=2;
                switch ( LA(1) )
                {
                    case SPACE:
                    	{
                    		alt33=1;
                    	}
                        break;
                }

                switch (alt33)
                {
            	case 1:
            	    // belle_sdp.g:324:55: SPACE rtcp_fb_nack_param
            	    {
            	        SPACE169 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_nack_val2032);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_nack_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE169_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE169));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE169_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_fb_nack_param_in_rtcp_fb_nack_val2034);
            	        rtcp_fb_nack_param170=rtcp_fb_nack_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_nack_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_nack_param170.tree);

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_type((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_NACK);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_nack_valEx; /* Prevent compiler warnings */
    rulertcp_fb_nack_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_nack_val */

/**
 * $ANTLR start rtcp_fb_trr_int_val
 * belle_sdp.g:328:1: rtcp_fb_trr_int_val :{...}? rtcp_fb_attribute_name SPACE integer ;
 */
static belle_sdpParser_rtcp_fb_trr_int_val_return
rtcp_fb_trr_int_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_trr_int_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE172;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name171;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name171
    #define	RETURN_TYPE_rtcp_fb_attribute_name171 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_integer_return integer173;
    #undef	RETURN_TYPE_integer173
    #define	RETURN_TYPE_integer173 belle_sdpParser_integer_return

    pANTLR3_BASE_TREE SPACE172_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE172       = NULL;
    rtcp_fb_attribute_name171.tree = NULL;

    integer173.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE172_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:328:20: ({...}? rtcp_fb_attribute_name SPACE integer )
        // belle_sdp.g:329:2: {...}? rtcp_fb_attribute_name SPACE integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(trr-int))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(trr-int)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_trr_int_val";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_trr_int_val2048);
            rtcp_fb_attribute_name171=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_trr_int_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name171.tree);

            SPACE172 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_trr_int_val2052);
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_trr_int_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE172_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE172));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE172_tree);
            }

            FOLLOWPUSH(FOLLOW_integer_in_rtcp_fb_trr_int_val2054);
            integer173=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_trr_int_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integer173.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_type((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_TRR_INT);
                		belle_sdp_rtcp_fb_attribute_set_trr_int((SCOPE_TOP(rtcp_fb_attribute))->current,(uint16_t)atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, integer173.start, integer173.stop))
                ->chars));
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_trr_int_valEx; /* Prevent compiler warnings */
    rulertcp_fb_trr_int_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_trr_int_val */

/**
 * $ANTLR start rtcp_fb_ccm_val
 * belle_sdp.g:334:1: rtcp_fb_ccm_val :{...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ccm_param )? ;
 */
static belle_sdpParser_rtcp_fb_ccm_val_return
rtcp_fb_ccm_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_ccm_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE175;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name174;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name174
    #define	RETURN_TYPE_rtcp_fb_attribute_name174 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_rtcp_fb_ccm_param_return rtcp_fb_ccm_param176;
    #undef	RETURN_TYPE_rtcp_fb_ccm_param176
    #define	RETURN_TYPE_rtcp_fb_ccm_param176 belle_sdpParser_rtcp_fb_ccm_param_return

    pANTLR3_BASE_TREE SPACE175_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE175       = NULL;
    rtcp_fb_attribute_name174.tree = NULL;

    rtcp_fb_ccm_param176.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE175_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:334:16: ({...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ccm_param )? )
        // belle_sdp.g:335:2: {...}? rtcp_fb_attribute_name ( SPACE rtcp_fb_ccm_param )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(ccm))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(ccm)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_ccm_val";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_ccm_val2066);
            rtcp_fb_attribute_name174=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_ccm_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name174.tree);

            // belle_sdp.g:335:52: ( SPACE rtcp_fb_ccm_param )?
            {
                int alt34=2;
                switch ( LA(1) )
                {
                    case SPACE:
                    	{
                    		alt34=1;
                    	}
                        break;
                }

                switch (alt34)
                {
            	case 1:
            	    // belle_sdp.g:335:53: SPACE rtcp_fb_ccm_param
            	    {
            	        SPACE175 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_ccm_val2071);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_ccm_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE175_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE175));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE175_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_fb_ccm_param_in_rtcp_fb_ccm_val2073);
            	        rtcp_fb_ccm_param176=rtcp_fb_ccm_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_ccm_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_ccm_param176.tree);

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                 /* TODO: rtcp_fb_ccm_param should be mandatory */
                		belle_sdp_rtcp_fb_attribute_set_type((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_CCM);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_ccm_valEx; /* Prevent compiler warnings */
    rulertcp_fb_ccm_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_ccm_val */

/**
 * $ANTLR start rtcp_fb_id_val
 * belle_sdp.g:339:1: rtcp_fb_id_val : rtcp_fb_attribute_name ( SPACE rtcp_fb_param )? ;
 */
static belle_sdpParser_rtcp_fb_id_val_return
rtcp_fb_id_val(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_id_val_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE178;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name177;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name177
    #define	RETURN_TYPE_rtcp_fb_attribute_name177 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_rtcp_fb_param_return rtcp_fb_param179;
    #undef	RETURN_TYPE_rtcp_fb_param179
    #define	RETURN_TYPE_rtcp_fb_param179 belle_sdpParser_rtcp_fb_param_return

    pANTLR3_BASE_TREE SPACE178_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE178       = NULL;
    rtcp_fb_attribute_name177.tree = NULL;

    rtcp_fb_param179.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE178_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:339:15: ( rtcp_fb_attribute_name ( SPACE rtcp_fb_param )? )
        // belle_sdp.g:340:2: rtcp_fb_attribute_name ( SPACE rtcp_fb_param )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_id_val2085);
            rtcp_fb_attribute_name177=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_id_valEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name177.tree);

            // belle_sdp.g:340:25: ( SPACE rtcp_fb_param )?
            {
                int alt35=2;
                switch ( LA(1) )
                {
                    case SPACE:
                    	{
                    		alt35=1;
                    	}
                        break;
                }

                switch (alt35)
                {
            	case 1:
            	    // belle_sdp.g:340:26: SPACE rtcp_fb_param
            	    {
            	        SPACE178 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_id_val2088);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_id_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE178_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE178));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE178_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_rtcp_fb_param_in_rtcp_fb_id_val2090);
            	        rtcp_fb_param179=rtcp_fb_param(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_id_valEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_param179.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_id_valEx; /* Prevent compiler warnings */
    rulertcp_fb_id_valEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_id_val */

/**
 * $ANTLR start rtcp_fb_param
 * belle_sdp.g:342:1: rtcp_fb_param : ( ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );
 */
static belle_sdpParser_rtcp_fb_param_return
rtcp_fb_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_app_param_return rtcp_fb_app_param180;
    #undef	RETURN_TYPE_rtcp_fb_app_param180
    #define	RETURN_TYPE_rtcp_fb_app_param180 belle_sdpParser_rtcp_fb_app_param_return

    belle_sdpParser_rtcp_fb_token_param_return rtcp_fb_token_param181;
    #undef	RETURN_TYPE_rtcp_fb_token_param181
    #define	RETURN_TYPE_rtcp_fb_token_param181 belle_sdpParser_rtcp_fb_token_param_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_app_param180.tree = NULL;

    rtcp_fb_token_param181.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:342:14: ( ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param )

            ANTLR3_UINT32 alt36;

            alt36=2;

            alt36 = cdfa36.predict(ctx, RECOGNIZER, ISTREAM, &cdfa36);
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            switch (alt36)
            {
        	case 1:
        	    // belle_sdp.g:343:2: ( rtcp_fb_app_param )=> rtcp_fb_app_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_rtcp_fb_param2104);
        	        rtcp_fb_app_param180=rtcp_fb_app_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_app_param180.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:344:3: ( rtcp_fb_token_param )=> rtcp_fb_token_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_rtcp_fb_param2112);
        	        rtcp_fb_token_param181=rtcp_fb_token_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_token_param181.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_param */

/**
 * $ANTLR start rtcp_fb_ack_param
 * belle_sdp.g:346:1: rtcp_fb_ack_param : ( ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param | ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );
 */
static belle_sdpParser_rtcp_fb_ack_param_return
rtcp_fb_ack_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_ack_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_rpsi_param_return rtcp_fb_rpsi_param182;
    #undef	RETURN_TYPE_rtcp_fb_rpsi_param182
    #define	RETURN_TYPE_rtcp_fb_rpsi_param182 belle_sdpParser_rtcp_fb_rpsi_param_return

    belle_sdpParser_rtcp_fb_app_param_return rtcp_fb_app_param183;
    #undef	RETURN_TYPE_rtcp_fb_app_param183
    #define	RETURN_TYPE_rtcp_fb_app_param183 belle_sdpParser_rtcp_fb_app_param_return

    belle_sdpParser_rtcp_fb_token_param_return rtcp_fb_token_param184;
    #undef	RETURN_TYPE_rtcp_fb_token_param184
    #define	RETURN_TYPE_rtcp_fb_token_param184 belle_sdpParser_rtcp_fb_token_param_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_rpsi_param182.tree = NULL;

    rtcp_fb_app_param183.tree = NULL;

    rtcp_fb_token_param184.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:346:18: ( ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param | ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param )

            ANTLR3_UINT32 alt37;

            alt37=3;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA37_1 = LA(2);
            		    if ( (synpred15_belle_sdp(ctx)) && (LA37_1 == COMMON_CHAR || LA37_1 == HEX_CHAR))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (synpred15_belle_sdp(ctx)) && (LA37_1 == DASH))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (synpred15_belle_sdp(ctx)) && (LA37_1 == SPACE))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (( (( ((IS_TOKEN(rpsi))) && ((IS_TOKEN(rpsi))) )) && (synpred14_belle_sdp(ctx)) )))
            		    {
            		        alt37=1;
            		    }
            		    else if ( (synpred16_belle_sdp(ctx)))
            		    {
            		        alt37=3;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 1;


            		        goto rulertcp_fb_ack_paramEx;

            		    }
            		}
            	}
                break;
            case DASH:
            	{
            		{
            		    int LA37_2 = LA(2);
            		    if ( (synpred15_belle_sdp(ctx)) && (LA37_2 == COMMON_CHAR || LA37_2 == HEX_CHAR))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (synpred15_belle_sdp(ctx)) && (LA37_2 == DASH))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (synpred15_belle_sdp(ctx)) && (LA37_2 == SPACE))
            		    {
            		        alt37=2;
            		    }
            		    else if ( (( (( ((IS_TOKEN(rpsi))) && ((IS_TOKEN(rpsi))) )) && (synpred14_belle_sdp(ctx)) )))
            		    {
            		        alt37=1;
            		    }
            		    else if ( (synpred16_belle_sdp(ctx)))
            		    {
            		        alt37=3;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 37;
            		        EXCEPTION->state        = 2;


            		        goto rulertcp_fb_ack_paramEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 37;
                EXCEPTION->state        = 0;


                goto rulertcp_fb_ack_paramEx;

            }

            switch (alt37)
            {
        	case 1:
        	    // belle_sdp.g:347:2: ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_ack_param2124);
        	        rtcp_fb_rpsi_param182=rtcp_fb_rpsi_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_rpsi_param182.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:348:3: ( rtcp_fb_app_param )=> rtcp_fb_app_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_rtcp_fb_ack_param2132);
        	        rtcp_fb_app_param183=rtcp_fb_app_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_app_param183.tree);

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:349:3: ( rtcp_fb_token_param )=> rtcp_fb_token_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ack_param2140);
        	        rtcp_fb_token_param184=rtcp_fb_token_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_token_param184.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_ack_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_ack_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_ack_param */

/**
 * $ANTLR start rtcp_fb_nack_param
 * belle_sdp.g:351:1: rtcp_fb_nack_param : ( ( rtcp_fb_pli_param )=> rtcp_fb_pli_param | ( rtcp_fb_sli_param )=> rtcp_fb_sli_param | ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param | ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );
 */
static belle_sdpParser_rtcp_fb_nack_param_return
rtcp_fb_nack_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_nack_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_pli_param_return rtcp_fb_pli_param185;
    #undef	RETURN_TYPE_rtcp_fb_pli_param185
    #define	RETURN_TYPE_rtcp_fb_pli_param185 belle_sdpParser_rtcp_fb_pli_param_return

    belle_sdpParser_rtcp_fb_sli_param_return rtcp_fb_sli_param186;
    #undef	RETURN_TYPE_rtcp_fb_sli_param186
    #define	RETURN_TYPE_rtcp_fb_sli_param186 belle_sdpParser_rtcp_fb_sli_param_return

    belle_sdpParser_rtcp_fb_rpsi_param_return rtcp_fb_rpsi_param187;
    #undef	RETURN_TYPE_rtcp_fb_rpsi_param187
    #define	RETURN_TYPE_rtcp_fb_rpsi_param187 belle_sdpParser_rtcp_fb_rpsi_param_return

    belle_sdpParser_rtcp_fb_app_param_return rtcp_fb_app_param188;
    #undef	RETURN_TYPE_rtcp_fb_app_param188
    #define	RETURN_TYPE_rtcp_fb_app_param188 belle_sdpParser_rtcp_fb_app_param_return

    belle_sdpParser_rtcp_fb_token_param_return rtcp_fb_token_param189;
    #undef	RETURN_TYPE_rtcp_fb_token_param189
    #define	RETURN_TYPE_rtcp_fb_token_param189 belle_sdpParser_rtcp_fb_token_param_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_pli_param185.tree = NULL;

    rtcp_fb_sli_param186.tree = NULL;

    rtcp_fb_rpsi_param187.tree = NULL;

    rtcp_fb_app_param188.tree = NULL;

    rtcp_fb_token_param189.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:351:19: ( ( rtcp_fb_pli_param )=> rtcp_fb_pli_param | ( rtcp_fb_sli_param )=> rtcp_fb_sli_param | ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param | ( rtcp_fb_app_param )=> rtcp_fb_app_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param )

            ANTLR3_UINT32 alt38;

            alt38=5;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA38_1 = LA(2);
            		    if ( (synpred20_belle_sdp(ctx)) && (LA38_1 == COMMON_CHAR || LA38_1 == HEX_CHAR))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (synpred20_belle_sdp(ctx)) && (LA38_1 == DASH))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (synpred20_belle_sdp(ctx)) && (LA38_1 == SPACE))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (( (( (synpred17_belle_sdp(ctx)) && (synpred17_belle_sdp(ctx)) )) && ((IS_TOKEN(pli))) )))
            		    {
            		        alt38=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(sli))) && ((IS_TOKEN(sli))) )) && (synpred18_belle_sdp(ctx)) )))
            		    {
            		        alt38=2;
            		    }
            		    else if ( (( (( ((IS_TOKEN(rpsi))) && ((IS_TOKEN(rpsi))) )) && (synpred19_belle_sdp(ctx)) )))
            		    {
            		        alt38=3;
            		    }
            		    else if ( (synpred21_belle_sdp(ctx)))
            		    {
            		        alt38=5;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 38;
            		        EXCEPTION->state        = 1;


            		        goto rulertcp_fb_nack_paramEx;

            		    }
            		}
            	}
                break;
            case DASH:
            	{
            		{
            		    int LA38_2 = LA(2);
            		    if ( (synpred20_belle_sdp(ctx)) && (LA38_2 == COMMON_CHAR || LA38_2 == HEX_CHAR))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (synpred20_belle_sdp(ctx)) && (LA38_2 == DASH))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (synpred20_belle_sdp(ctx)) && (LA38_2 == SPACE))
            		    {
            		        alt38=4;
            		    }
            		    else if ( (( (( (synpred17_belle_sdp(ctx)) && (synpred17_belle_sdp(ctx)) )) && ((IS_TOKEN(pli))) )))
            		    {
            		        alt38=1;
            		    }
            		    else if ( (( (( ((IS_TOKEN(sli))) && ((IS_TOKEN(sli))) )) && (synpred18_belle_sdp(ctx)) )))
            		    {
            		        alt38=2;
            		    }
            		    else if ( (( (( ((IS_TOKEN(rpsi))) && ((IS_TOKEN(rpsi))) )) && (synpred19_belle_sdp(ctx)) )))
            		    {
            		        alt38=3;
            		    }
            		    else if ( (synpred21_belle_sdp(ctx)))
            		    {
            		        alt38=5;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 38;
            		        EXCEPTION->state        = 2;


            		        goto rulertcp_fb_nack_paramEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 38;
                EXCEPTION->state        = 0;


                goto rulertcp_fb_nack_paramEx;

            }

            switch (alt38)
            {
        	case 1:
        	    // belle_sdp.g:352:2: ( rtcp_fb_pli_param )=> rtcp_fb_pli_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_pli_param_in_rtcp_fb_nack_param2152);
        	        rtcp_fb_pli_param185=rtcp_fb_pli_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_nack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_pli_param185.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:353:3: ( rtcp_fb_sli_param )=> rtcp_fb_sli_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_sli_param_in_rtcp_fb_nack_param2160);
        	        rtcp_fb_sli_param186=rtcp_fb_sli_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_nack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_sli_param186.tree);

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:354:3: ( rtcp_fb_rpsi_param )=> rtcp_fb_rpsi_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_rpsi_param_in_rtcp_fb_nack_param2168);
        	        rtcp_fb_rpsi_param187=rtcp_fb_rpsi_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_nack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_rpsi_param187.tree);

        	    }
        	    break;
        	case 4:
        	    // belle_sdp.g:355:3: ( rtcp_fb_app_param )=> rtcp_fb_app_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_rtcp_fb_nack_param2176);
        	        rtcp_fb_app_param188=rtcp_fb_app_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_nack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_app_param188.tree);

        	    }
        	    break;
        	case 5:
        	    // belle_sdp.g:356:3: ( rtcp_fb_token_param )=> rtcp_fb_token_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_rtcp_fb_nack_param2184);
        	        rtcp_fb_token_param189=rtcp_fb_token_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_nack_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_token_param189.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_nack_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_nack_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_nack_param */

/**
 * $ANTLR start rtcp_fb_pli_param
 * belle_sdp.g:358:1: rtcp_fb_pli_param :{...}? rtcp_fb_attribute_name ;
 */
static belle_sdpParser_rtcp_fb_pli_param_return
rtcp_fb_pli_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_pli_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name190;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name190
    #define	RETURN_TYPE_rtcp_fb_attribute_name190 belle_sdpParser_rtcp_fb_attribute_name_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_attribute_name190.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:358:18: ({...}? rtcp_fb_attribute_name )
        // belle_sdp.g:359:2: {...}? rtcp_fb_attribute_name
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(pli))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(pli)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_pli_param";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_pli_param2194);
            rtcp_fb_attribute_name190=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_pli_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name190.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_param((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_PLI);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_pli_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_pli_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_pli_param */

/**
 * $ANTLR start rtcp_fb_sli_param
 * belle_sdp.g:363:1: rtcp_fb_sli_param :{...}? rtcp_fb_attribute_name ;
 */
static belle_sdpParser_rtcp_fb_sli_param_return
rtcp_fb_sli_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_sli_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name191;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name191
    #define	RETURN_TYPE_rtcp_fb_attribute_name191 belle_sdpParser_rtcp_fb_attribute_name_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_attribute_name191.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:363:18: ({...}? rtcp_fb_attribute_name )
        // belle_sdp.g:364:2: {...}? rtcp_fb_attribute_name
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(sli))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(sli)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_sli_param";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_sli_param2208);
            rtcp_fb_attribute_name191=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_sli_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name191.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_param((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_SLI);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_sli_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_sli_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_sli_param */

/**
 * $ANTLR start rtcp_fb_rpsi_param
 * belle_sdp.g:368:1: rtcp_fb_rpsi_param :{...}? rtcp_fb_attribute_name ;
 */
static belle_sdpParser_rtcp_fb_rpsi_param_return
rtcp_fb_rpsi_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_rpsi_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name192;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name192
    #define	RETURN_TYPE_rtcp_fb_attribute_name192 belle_sdpParser_rtcp_fb_attribute_name_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_attribute_name192.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:368:19: ({...}? rtcp_fb_attribute_name )
        // belle_sdp.g:369:2: {...}? rtcp_fb_attribute_name
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(rpsi))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(rpsi)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_rpsi_param";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_rpsi_param2222);
            rtcp_fb_attribute_name192=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_rpsi_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name192.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_param((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_RPSI);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_rpsi_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_rpsi_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_rpsi_param */

/**
 * $ANTLR start rtcp_fb_app_param
 * belle_sdp.g:373:1: rtcp_fb_app_param :{...}? rtcp_fb_attribute_name ( SPACE byte_string ) ;
 */
static belle_sdpParser_rtcp_fb_app_param_return
rtcp_fb_app_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_app_param_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE194;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name193;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name193
    #define	RETURN_TYPE_rtcp_fb_attribute_name193 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_byte_string_return byte_string195;
    #undef	RETURN_TYPE_byte_string195
    #define	RETURN_TYPE_byte_string195 belle_sdpParser_byte_string_return

    pANTLR3_BASE_TREE SPACE194_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE194       = NULL;
    rtcp_fb_attribute_name193.tree = NULL;

    byte_string195.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE194_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:373:18: ({...}? rtcp_fb_attribute_name ( SPACE byte_string ) )
        // belle_sdp.g:374:2: {...}? rtcp_fb_attribute_name ( SPACE byte_string )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(app))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(app)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_app_param";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_app_param2236);
            rtcp_fb_attribute_name193=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_app_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name193.tree);

            // belle_sdp.g:374:52: ( SPACE byte_string )
            // belle_sdp.g:374:53: SPACE byte_string
            {
                SPACE194 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_app_param2241);
                if  (HASEXCEPTION())
                {
                    goto rulertcp_fb_app_paramEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                if ( BACKTRACKING==0 ) {
                SPACE194_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE194));
                ADAPTOR->addChild(ADAPTOR, root_0, SPACE194_tree);
                }

                FOLLOWPUSH(FOLLOW_byte_string_in_rtcp_fb_app_param2243);
                byte_string195=byte_string(ctx);

                FOLLOWPOP();
                if  (HASEXCEPTION())
                {
                    goto rulertcp_fb_app_paramEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, byte_string195.tree);

            }


            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_param((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_APP);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_app_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_app_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_app_param */

/**
 * $ANTLR start rtcp_fb_ccm_param
 * belle_sdp.g:378:1: rtcp_fb_ccm_param : ( ( rtcp_fb_fir_param )=> rtcp_fb_fir_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param );
 */
static belle_sdpParser_rtcp_fb_ccm_param_return
rtcp_fb_ccm_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_ccm_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_fir_param_return rtcp_fb_fir_param196;
    #undef	RETURN_TYPE_rtcp_fb_fir_param196
    #define	RETURN_TYPE_rtcp_fb_fir_param196 belle_sdpParser_rtcp_fb_fir_param_return

    belle_sdpParser_rtcp_fb_token_param_return rtcp_fb_token_param197;
    #undef	RETURN_TYPE_rtcp_fb_token_param197
    #define	RETURN_TYPE_rtcp_fb_token_param197 belle_sdpParser_rtcp_fb_token_param_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_fir_param196.tree = NULL;

    rtcp_fb_token_param197.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:378:18: ( ( rtcp_fb_fir_param )=> rtcp_fb_fir_param | ( rtcp_fb_token_param )=> rtcp_fb_token_param )

            ANTLR3_UINT32 alt39;

            alt39=2;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA39_1 = LA(2);
            		    if ( (( (( (synpred22_belle_sdp(ctx)) && (synpred22_belle_sdp(ctx)) )) && ((IS_TOKEN(fir))) )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (synpred23_belle_sdp(ctx)))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 1;


            		        goto rulertcp_fb_ccm_paramEx;

            		    }
            		}
            	}
                break;
            case DASH:
            	{
            		{
            		    int LA39_2 = LA(2);
            		    if ( (( (( (synpred22_belle_sdp(ctx)) && (synpred22_belle_sdp(ctx)) )) && ((IS_TOKEN(fir))) )))
            		    {
            		        alt39=1;
            		    }
            		    else if ( (synpred23_belle_sdp(ctx)))
            		    {
            		        alt39=2;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 39;
            		        EXCEPTION->state        = 2;


            		        goto rulertcp_fb_ccm_paramEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 39;
                EXCEPTION->state        = 0;


                goto rulertcp_fb_ccm_paramEx;

            }

            switch (alt39)
            {
        	case 1:
        	    // belle_sdp.g:379:2: ( rtcp_fb_fir_param )=> rtcp_fb_fir_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_fir_param_in_rtcp_fb_ccm_param2258);
        	        rtcp_fb_fir_param196=rtcp_fb_fir_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ccm_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_fir_param196.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:380:3: ( rtcp_fb_token_param )=> rtcp_fb_token_param
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_rtcp_fb_ccm_param2266);
        	        rtcp_fb_token_param197=rtcp_fb_token_param(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulertcp_fb_ccm_paramEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_token_param197.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_ccm_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_ccm_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_ccm_param */

/**
 * $ANTLR start rtcp_fb_fir_param
 * belle_sdp.g:382:1: rtcp_fb_fir_param :{...}? rtcp_fb_attribute_name ;
 */
static belle_sdpParser_rtcp_fb_fir_param_return
rtcp_fb_fir_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_fir_param_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name198;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name198
    #define	RETURN_TYPE_rtcp_fb_attribute_name198 belle_sdpParser_rtcp_fb_attribute_name_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    rtcp_fb_attribute_name198.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:382:18: ({...}? rtcp_fb_attribute_name )
        // belle_sdp.g:383:2: {...}? rtcp_fb_attribute_name
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(fir))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(fir)";
                    EXCEPTION->ruleName	 = (void *)"rtcp_fb_fir_param";


            }

            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_fir_param2276);
            rtcp_fb_attribute_name198=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_fir_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name198.tree);

            if ( BACKTRACKING==0 )
            {

                		belle_sdp_rtcp_fb_attribute_set_param((SCOPE_TOP(rtcp_fb_attribute))->current,BELLE_SDP_RTCP_FB_FIR);
                	
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_fir_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_fir_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_fir_param */

/**
 * $ANTLR start rtcp_fb_token_param
 * belle_sdp.g:387:1: rtcp_fb_token_param : rtcp_fb_attribute_name ( SPACE byte_string )? ;
 */
static belle_sdpParser_rtcp_fb_token_param_return
rtcp_fb_token_param(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_token_param_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SPACE200;
    belle_sdpParser_rtcp_fb_attribute_name_return rtcp_fb_attribute_name199;
    #undef	RETURN_TYPE_rtcp_fb_attribute_name199
    #define	RETURN_TYPE_rtcp_fb_attribute_name199 belle_sdpParser_rtcp_fb_attribute_name_return

    belle_sdpParser_byte_string_return byte_string201;
    #undef	RETURN_TYPE_byte_string201
    #define	RETURN_TYPE_byte_string201 belle_sdpParser_byte_string_return

    pANTLR3_BASE_TREE SPACE200_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    SPACE200       = NULL;
    rtcp_fb_attribute_name199.tree = NULL;

    byte_string201.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    SPACE200_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:387:20: ( rtcp_fb_attribute_name ( SPACE byte_string )? )
        // belle_sdp.g:388:2: rtcp_fb_attribute_name ( SPACE byte_string )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_rtcp_fb_attribute_name_in_rtcp_fb_token_param2288);
            rtcp_fb_attribute_name199=rtcp_fb_attribute_name(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_token_paramEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, rtcp_fb_attribute_name199.tree);

            // belle_sdp.g:388:25: ( SPACE byte_string )?
            {
                int alt40=2;
                switch ( LA(1) )
                {
                    case SPACE:
                    	{
                    		alt40=1;
                    	}
                        break;
                }

                switch (alt40)
                {
            	case 1:
            	    // belle_sdp.g:388:26: SPACE byte_string
            	    {
            	        SPACE200 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_rtcp_fb_token_param2291);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_token_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SPACE200_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE200));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SPACE200_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_byte_string_in_rtcp_fb_token_param2293);
            	        byte_string201=byte_string(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulertcp_fb_token_paramEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, byte_string201.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_token_paramEx; /* Prevent compiler warnings */
    rulertcp_fb_token_paramEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_token_param */

/**
 * $ANTLR start media_description
 * belle_sdp.g:390:1: media_description returns [belle_sdp_media_description_t* ret] : media CR LF ( info CR LF )? ( connection CR LF )? ( bandwidth CR LF )* ( key_field CR LF )? ( attribute CR LF )* ;
 */
static belle_sdpParser_media_description_return
media_description(pbelle_sdpParser ctx)
{
    belle_sdpParser_media_description_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    CR203;
    pANTLR3_COMMON_TOKEN    LF204;
    pANTLR3_COMMON_TOKEN    CR206;
    pANTLR3_COMMON_TOKEN    LF207;
    pANTLR3_COMMON_TOKEN    CR209;
    pANTLR3_COMMON_TOKEN    LF210;
    pANTLR3_COMMON_TOKEN    CR212;
    pANTLR3_COMMON_TOKEN    LF213;
    pANTLR3_COMMON_TOKEN    CR215;
    pANTLR3_COMMON_TOKEN    LF216;
    pANTLR3_COMMON_TOKEN    CR218;
    pANTLR3_COMMON_TOKEN    LF219;
    belle_sdpParser_media_return media202;
    #undef	RETURN_TYPE_media202
    #define	RETURN_TYPE_media202 belle_sdpParser_media_return

    belle_sdpParser_info_return info205;
    #undef	RETURN_TYPE_info205
    #define	RETURN_TYPE_info205 belle_sdpParser_info_return

    belle_sdpParser_connection_return connection208;
    #undef	RETURN_TYPE_connection208
    #define	RETURN_TYPE_connection208 belle_sdpParser_connection_return

    belle_sdpParser_bandwidth_return bandwidth211;
    #undef	RETURN_TYPE_bandwidth211
    #define	RETURN_TYPE_bandwidth211 belle_sdpParser_bandwidth_return

    belle_sdpParser_key_field_return key_field214;
    #undef	RETURN_TYPE_key_field214
    #define	RETURN_TYPE_key_field214 belle_sdpParser_key_field_return

    belle_sdpParser_attribute_return attribute217;
    #undef	RETURN_TYPE_attribute217
    #define	RETURN_TYPE_attribute217 belle_sdpParser_attribute_return

    pANTLR3_BASE_TREE CR203_tree;
    pANTLR3_BASE_TREE LF204_tree;
    pANTLR3_BASE_TREE CR206_tree;
    pANTLR3_BASE_TREE LF207_tree;
    pANTLR3_BASE_TREE CR209_tree;
    pANTLR3_BASE_TREE LF210_tree;
    pANTLR3_BASE_TREE CR212_tree;
    pANTLR3_BASE_TREE LF213_tree;
    pANTLR3_BASE_TREE CR215_tree;
    pANTLR3_BASE_TREE LF216_tree;
    pANTLR3_BASE_TREE CR218_tree;
    pANTLR3_BASE_TREE LF219_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_media_descriptionTop = pbelle_sdpParser_media_descriptionPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(media_description))->current= belle_sdp_media_description_new(); 
    retval.ret=(SCOPE_TOP(media_description))->current;
     
    CR203       = NULL;
    LF204       = NULL;
    CR206       = NULL;
    LF207       = NULL;
    CR209       = NULL;
    LF210       = NULL;
    CR212       = NULL;
    LF213       = NULL;
    CR215       = NULL;
    LF216       = NULL;
    CR218       = NULL;
    LF219       = NULL;
    media202.tree = NULL;

    info205.tree = NULL;

    connection208.tree = NULL;

    bandwidth211.tree = NULL;

    key_field214.tree = NULL;

    attribute217.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    CR203_tree   = NULL;
    LF204_tree   = NULL;
    CR206_tree   = NULL;
    LF207_tree   = NULL;
    CR209_tree   = NULL;
    LF210_tree   = NULL;
    CR212_tree   = NULL;
    LF213_tree   = NULL;
    CR215_tree   = NULL;
    LF216_tree   = NULL;
    CR218_tree   = NULL;
    LF219_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:393:22: ( media CR LF ( info CR LF )? ( connection CR LF )? ( bandwidth CR LF )* ( key_field CR LF )? ( attribute CR LF )* )
        // belle_sdp.g:393:22: media CR LF ( info CR LF )? ( connection CR LF )? ( bandwidth CR LF )* ( key_field CR LF )? ( attribute CR LF )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_media_in_media_description2336);
            media202=media(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemedia_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_media_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, media202.tree);

            CR203 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2338);
            if  (HASEXCEPTION())
            {
                goto rulemedia_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_media_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            CR203_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR203));
            ADAPTOR->addChild(ADAPTOR, root_0, CR203_tree);
            }

            LF204 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2340);
            if  (HASEXCEPTION())
            {
                goto rulemedia_descriptionEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_media_descriptionPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            LF204_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF204));
            ADAPTOR->addChild(ADAPTOR, root_0, LF204_tree);
            }

            if ( BACKTRACKING==0 )
            {
                belle_sdp_media_description_set_media((SCOPE_TOP(media_description))->current,
                media202.ret
                );
            }


            // belle_sdp.g:394:21: ( info CR LF )?
            {
                int alt41=2;
                alt41 = cdfa41.predict(ctx, RECOGNIZER, ISTREAM, &cdfa41);
                if  (HASEXCEPTION())
                {
                    goto rulemedia_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_media_descriptionPop(ctx);

                    return retval;
                }

                switch (alt41)
                {
            	case 1:
            	    // belle_sdp.g:394:22: info CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_info_in_media_description2366);
            	        info205=info(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, info205.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_media_description_set_info((SCOPE_TOP(media_description))->current,
            	            info205.ret
            	            );
            	        }


            	        CR206 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2370);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR206_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR206));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR206_tree);
            	        }

            	        LF207 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2372);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF207_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF207));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF207_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:395:22: ( connection CR LF )?
            {
                int alt42=2;
                alt42 = cdfa42.predict(ctx, RECOGNIZER, ISTREAM, &cdfa42);
                if  (HASEXCEPTION())
                {
                    goto rulemedia_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_media_descriptionPop(ctx);

                    return retval;
                }

                switch (alt42)
                {
            	case 1:
            	    // belle_sdp.g:395:23: connection CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_connection_in_media_description2398);
            	        connection208=connection(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, connection208.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	             belle_sdp_media_description_set_connection((SCOPE_TOP(media_description))->current,
            	            connection208.ret
            	            );
            	        }


            	        CR209 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2402);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR209_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR209));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR209_tree);
            	        }

            	        LF210 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2404);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF210_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF210));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF210_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:396:22: ( bandwidth CR LF )*

            for (;;)
            {
                int alt43=2;
                alt43 = cdfa43.predict(ctx, RECOGNIZER, ISTREAM, &cdfa43);
                if  (HASEXCEPTION())
                {
                    goto rulemedia_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_media_descriptionPop(ctx);

                    return retval;
                }

                switch (alt43)
                {
            	case 1:
            	    // belle_sdp.g:396:23: bandwidth CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_bandwidth_in_media_description2430);
            	        bandwidth211=bandwidth(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, bandwidth211.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_media_description_add_bandwidth((SCOPE_TOP(media_description))->current,
            	            bandwidth211.ret
            	            );
            	        }


            	        CR212 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2434);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR212_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR212));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR212_tree);
            	        }

            	        LF213 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2436);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF213_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF213));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF213_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop43;	/* break out of the loop */
            	    break;
                }
            }
            loop43: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:397:22: ( key_field CR LF )?
            {
                int alt44=2;
                alt44 = cdfa44.predict(ctx, RECOGNIZER, ISTREAM, &cdfa44);
                if  (HASEXCEPTION())
                {
                    goto rulemedia_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_media_descriptionPop(ctx);

                    return retval;
                }

                switch (alt44)
                {
            	case 1:
            	    // belle_sdp.g:397:23: key_field CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_key_field_in_media_description2462);
            	        key_field214=key_field(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, key_field214.tree);

            	        CR215 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2464);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR215_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR215));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR215_tree);
            	        }

            	        LF216 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2466);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF216_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF216));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF216_tree);
            	        }

            	    }
            	    break;

                }
            }

            // belle_sdp.g:398:22: ( attribute CR LF )*

            for (;;)
            {
                int alt45=2;
                alt45 = cdfa45.predict(ctx, RECOGNIZER, ISTREAM, &cdfa45);
                if  (HASEXCEPTION())
                {
                    goto rulemedia_descriptionEx;
                }
                if (HASFAILED())
                {
                    pbelle_sdpParser_media_descriptionPop(ctx);

                    return retval;
                }

                switch (alt45)
                {
            	case 1:
            	    // belle_sdp.g:398:23: attribute CR LF
            	    {
            	        FOLLOWPUSH(FOLLOW_attribute_in_media_description2492);
            	        attribute217=attribute(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, attribute217.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            if (attribute217.ret
            	            )belle_sdp_media_description_add_attribute((SCOPE_TOP(media_description))->current,
            	            attribute217.ret
            	            );
            	        }


            	        CR218 = (pANTLR3_COMMON_TOKEN) MATCHT(CR, &FOLLOW_CR_in_media_description2496);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        CR218_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, CR218));
            	        ADAPTOR->addChild(ADAPTOR, root_0, CR218_tree);
            	        }

            	        LF219 = (pANTLR3_COMMON_TOKEN) MATCHT(LF, &FOLLOW_LF_in_media_description2498);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemedia_descriptionEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_media_descriptionPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        LF219_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LF219));
            	        ADAPTOR->addChild(ADAPTOR, root_0, LF219_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop45;	/* break out of the loop */
            	    break;
                }
            }
            loop45: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulemedia_descriptionEx; /* Prevent compiler warnings */
    rulemedia_descriptionEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(retval.ret
	    );
	      retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_media_descriptionPop(ctx);

    return retval;
}
/* $ANTLR end media_description */

/**
 * $ANTLR start media
 * belle_sdp.g:406:1: media returns [belle_sdp_media_t* ret] :{...}? alpha_num EQUAL media_value SPACE port ( SLASH integer )? SPACE proto ( SPACE fmt )+ ;
 */
static belle_sdpParser_media_return
media(pbelle_sdpParser ctx)
{
    belle_sdpParser_media_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    EQUAL221;
    pANTLR3_COMMON_TOKEN    SPACE223;
    pANTLR3_COMMON_TOKEN    SLASH225;
    pANTLR3_COMMON_TOKEN    SPACE227;
    pANTLR3_COMMON_TOKEN    SPACE229;
    belle_sdpParser_alpha_num_return alpha_num220;
    #undef	RETURN_TYPE_alpha_num220
    #define	RETURN_TYPE_alpha_num220 belle_sdpParser_alpha_num_return

    belle_sdpParser_media_value_return media_value222;
    #undef	RETURN_TYPE_media_value222
    #define	RETURN_TYPE_media_value222 belle_sdpParser_media_value_return

    belle_sdpParser_port_return port224;
    #undef	RETURN_TYPE_port224
    #define	RETURN_TYPE_port224 belle_sdpParser_port_return

    belle_sdpParser_integer_return integer226;
    #undef	RETURN_TYPE_integer226
    #define	RETURN_TYPE_integer226 belle_sdpParser_integer_return

    belle_sdpParser_proto_return proto228;
    #undef	RETURN_TYPE_proto228
    #define	RETURN_TYPE_proto228 belle_sdpParser_proto_return

    belle_sdpParser_fmt_return fmt230;
    #undef	RETURN_TYPE_fmt230
    #define	RETURN_TYPE_fmt230 belle_sdpParser_fmt_return

    pANTLR3_BASE_TREE EQUAL221_tree;
    pANTLR3_BASE_TREE SPACE223_tree;
    pANTLR3_BASE_TREE SLASH225_tree;
    pANTLR3_BASE_TREE SPACE227_tree;
    pANTLR3_BASE_TREE SPACE229_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_mediaTop = pbelle_sdpParser_mediaPush(ctx);
    root_0 = NULL;

    (SCOPE_TOP(media))->current= belle_sdp_media_new(); 
    retval.ret=(SCOPE_TOP(media))->current;
     
    EQUAL221       = NULL;
    SPACE223       = NULL;
    SLASH225       = NULL;
    SPACE227       = NULL;
    SPACE229       = NULL;
    alpha_num220.tree = NULL;

    media_value222.tree = NULL;

    port224.tree = NULL;

    integer226.tree = NULL;

    proto228.tree = NULL;

    fmt230.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    EQUAL221_tree   = NULL;
    SPACE223_tree   = NULL;
    SLASH225_tree   = NULL;
    SPACE227_tree   = NULL;
    SPACE229_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:409:11: ({...}? alpha_num EQUAL media_value SPACE port ( SLASH integer )? SPACE proto ( SPACE fmt )+ )
        // belle_sdp.g:409:11: {...}? alpha_num EQUAL media_value SPACE port ( SLASH integer )? SPACE proto ( SPACE fmt )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            if ( !((IS_TOKEN(m))) )
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    pbelle_sdpParser_mediaPop(ctx);

                    return retval;
                }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
                    EXCEPTION->message      = (void *)"IS_TOKEN(m)";
                    EXCEPTION->ruleName	 = (void *)"media";


            }

            FOLLOWPUSH(FOLLOW_alpha_num_in_media2541);
            alpha_num220=alpha_num(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num220.tree);

            EQUAL221 = (pANTLR3_COMMON_TOKEN) MATCHT(EQUAL, &FOLLOW_EQUAL_in_media2543);
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            EQUAL221_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EQUAL221));
            ADAPTOR->addChild(ADAPTOR, root_0, EQUAL221_tree);
            }

            FOLLOWPUSH(FOLLOW_media_value_in_media2556);
            media_value222=media_value(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, media_value222.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_media_set_media_type((SCOPE_TOP(media))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, media_value222.start, media_value222.stop))
                ->chars);
            }


            SPACE223 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_media2571);
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE223_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE223));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE223_tree);
            }

            FOLLOWPUSH(FOLLOW_port_in_media2573);
            port224=port(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, port224.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_media_set_media_port((SCOPE_TOP(media))->current,atoi((const char*)
                (STRSTREAM->toStringTT(STRSTREAM, port224.start, port224.stop))
                ->chars));
            }


            // belle_sdp.g:412:11: ( SLASH integer )?
            {
                int alt46=2;
                switch ( LA(1) )
                {
                    case SLASH:
                    	{
                    		alt46=1;
                    	}
                        break;
                }

                switch (alt46)
                {
            	case 1:
            	    // belle_sdp.g:412:12: SLASH integer
            	    {
            	        SLASH225 = (pANTLR3_COMMON_TOKEN) MATCHT(SLASH, &FOLLOW_SLASH_in_media2589);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemediaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_mediaPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        SLASH225_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SLASH225));
            	        ADAPTOR->addChild(ADAPTOR, root_0, SLASH225_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_integer_in_media2591);
            	        integer226=integer(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulemediaEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_mediaPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integer226.tree);

            	        if ( BACKTRACKING==0 )
            	        {
            	            belle_sdp_media_set_port_count((SCOPE_TOP(media))->current,atoi((const char*)
            	            (STRSTREAM->toStringTT(STRSTREAM, integer226.start, integer226.stop))
            	            ->chars));
            	        }


            	    }
            	    break;

                }
            }

            SPACE227 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_media2607);
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) {
            SPACE227_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE227));
            ADAPTOR->addChild(ADAPTOR, root_0, SPACE227_tree);
            }

            FOLLOWPUSH(FOLLOW_proto_in_media2609);
            proto228=proto(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemediaEx;
            }
            if (HASFAILED())
            {
                pbelle_sdpParser_mediaPop(ctx);

                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, proto228.tree);

            if ( BACKTRACKING==0 )
            {
                belle_sdp_media_set_protocol((SCOPE_TOP(media))->current,(const char*)
                (STRSTREAM->toStringTT(STRSTREAM, proto228.start, proto228.stop))
                ->chars);
            }


            // belle_sdp.g:414:11: ( SPACE fmt )+
            {
                int cnt47=0;

                for (;;)
                {
                    int alt47=2;
            	switch ( LA(1) )
            	{
            	case SPACE:
            		{
            			alt47=1;
            		}
            	    break;

            	}

            	switch (alt47)
            	{
            	    case 1:
            	        // belle_sdp.g:414:12: SPACE fmt
            	        {
            	            SPACE229 = (pANTLR3_COMMON_TOKEN) MATCHT(SPACE, &FOLLOW_SPACE_in_media2624);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemediaEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sdpParser_mediaPop(ctx);

            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            SPACE229_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SPACE229));
            	            ADAPTOR->addChild(ADAPTOR, root_0, SPACE229_tree);
            	            }

            	            FOLLOWPUSH(FOLLOW_fmt_in_media2626);
            	            fmt230=fmt(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemediaEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                pbelle_sdpParser_mediaPop(ctx);

            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fmt230.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt47 >= 1 )
            		{
            		    goto loop47;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    pbelle_sdpParser_mediaPop(ctx);

            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemediaEx;
            	}
            	cnt47++;
                }
                loop47: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemediaEx; /* Prevent compiler warnings */
    rulemediaEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }


    if	(HASEXCEPTION())
    {
	/* catch(decl,action)
	 */
	{

	      belle_sip_message("[%s]  reason [%s]",(const char*)EXCEPTION->name,(const char*)EXCEPTION->message);
	      belle_sip_object_unref(retval.ret
	    );
	      retval.ret=NULL;


	}


    }
    else
    {
    }
    pbelle_sdpParser_mediaPop(ctx);

    return retval;
}
/* $ANTLR end media */

/**
 * $ANTLR start media_value
 * belle_sdp.g:421:1: media_value : ( alpha_num )+ ;
 */
static belle_sdpParser_media_value_return
media_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_media_value_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_alpha_num_return alpha_num231;
    #undef	RETURN_TYPE_alpha_num231
    #define	RETURN_TYPE_alpha_num231 belle_sdpParser_alpha_num_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    alpha_num231.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:421:12: ( ( alpha_num )+ )
        // belle_sdp.g:421:28: ( alpha_num )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:421:28: ( alpha_num )+
            {
                int cnt48=0;

                for (;;)
                {
                    int alt48=2;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt48=1;
            		}
            	    break;

            	}

            	switch (alt48)
            	{
            	    case 1:
            	        // belle_sdp.g:421:28: alpha_num
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_num_in_media_value2655);
            	            alpha_num231=alpha_num(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulemedia_valueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num231.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt48 >= 1 )
            		{
            		    goto loop48;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulemedia_valueEx;
            	}
            	cnt48++;
                }
                loop48: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemedia_valueEx; /* Prevent compiler warnings */
    rulemedia_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end media_value */

/**
 * $ANTLR start fmt
 * belle_sdp.g:425:1: fmt : ( ( ( DIGIT )+ )=> ( ( DIGIT )+ ) | token ) ;
 */
static belle_sdpParser_fmt_return
fmt(pbelle_sdpParser ctx)
{
    belle_sdpParser_fmt_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT232;
    belle_sdpParser_token_return token233;
    #undef	RETURN_TYPE_token233
    #define	RETURN_TYPE_token233 belle_sdpParser_token_return

    pANTLR3_BASE_TREE DIGIT232_tree;

    /* Initialize rule variables
     */
    ctx->pbelle_sdpParser_fmtTop = pbelle_sdpParser_fmtPush(ctx);
    root_0 = NULL;

     (SCOPE_TOP(fmt))->is_number=0;
    DIGIT232       = NULL;
    token233.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT232_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:427:28: ( ( ( ( DIGIT )+ )=> ( ( DIGIT )+ ) | token ) )
        // belle_sdp.g:427:46: ( ( ( DIGIT )+ )=> ( ( DIGIT )+ ) | token )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:427:46: ( ( ( DIGIT )+ )=> ( ( DIGIT )+ ) | token )
            {
                int alt50=2;
                switch ( LA(1) )
                {
                case DIGIT:
                	{
                		{
                		    int LA50_1 = LA(2);
                		    if ( (synpred24_belle_sdp(ctx)))
                		    {
                		        alt50=1;
                		    }
                		    else if ( (ANTLR3_TRUE))
                		    {
                		        alt50=2;
                		    }
                		    else
                		    {
                		        if (BACKTRACKING>0)
                		        {
                		            FAILEDFLAG = ANTLR3_TRUE;
                		            pbelle_sdpParser_fmtPop(ctx);

                		            return retval;
                		        }


                		        CONSTRUCTEX();
                		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                		        EXCEPTION->message      = (void *)"";
                		        EXCEPTION->decisionNum  = 50;
                		        EXCEPTION->state        = 1;


                		        goto rulefmtEx;

                		    }
                		}
                	}
                    break;
                case COMMON_CHAR:
                case DASH:
                case DOT:
                case HEX_CHAR:
                case STAR:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt50=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        pbelle_sdpParser_fmtPop(ctx);

                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 50;
                    EXCEPTION->state        = 0;


                    goto rulefmtEx;

                }

                switch (alt50)
                {
            	case 1:
            	    // belle_sdp.g:427:47: ( ( DIGIT )+ )=> ( ( DIGIT )+ )
            	    {
            	        // belle_sdp.g:427:57: ( ( DIGIT )+ )
            	        // belle_sdp.g:427:58: ( DIGIT )+
            	        {
            	            // belle_sdp.g:427:58: ( DIGIT )+
            	            {
            	                int cnt49=0;

            	                for (;;)
            	                {
            	                    int alt49=2;
            	            	switch ( LA(1) )
            	            	{
            	            	case DIGIT:
            	            		{
            	            			alt49=1;
            	            		}
            	            	    break;

            	            	}

            	            	switch (alt49)
            	            	{
            	            	    case 1:
            	            	        // belle_sdp.g:427:58: DIGIT
            	            	        {
            	            	            DIGIT232 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_fmt2739);
            	            	            if  (HASEXCEPTION())
            	            	            {
            	            	                goto rulefmtEx;
            	            	            }
            	            	            if (HASFAILED())
            	            	            {
            	            	                pbelle_sdpParser_fmtPop(ctx);

            	            	                return retval;
            	            	            }

            	            	            if ( BACKTRACKING==0 ) {
            	            	            DIGIT232_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT232));
            	            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT232_tree);
            	            	            }

            	            	        }
            	            	        break;

            	            	    default:

            	            		if ( cnt49 >= 1 )
            	            		{
            	            		    goto loop49;
            	            		}
            	            		if (BACKTRACKING>0)
            	            		{
            	            		    FAILEDFLAG = ANTLR3_TRUE;
            	            		    pbelle_sdpParser_fmtPop(ctx);

            	            		    return retval;
            	            		}

            	            		/* mismatchedSetEx()
            	            		 */
            	            		CONSTRUCTEX();
            	            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            	            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            	            		goto rulefmtEx;
            	            	}
            	            	cnt49++;
            	                }
            	                loop49: ;	/* Jump to here if this rule does not match */
            	            }

            	        }


            	        if ( BACKTRACKING==0 )
            	        {
            	            (SCOPE_TOP(fmt))->is_number=1;
            	        }


            	    }
            	    break;
            	case 2:
            	    // belle_sdp.g:427:88: token
            	    {
            	        FOLLOWPUSH(FOLLOW_token_in_fmt2746);
            	        token233=token(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefmtEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            pbelle_sdpParser_fmtPop(ctx);

            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, token233.tree);

            	    }
            	    break;

                }
            }

            if ( BACKTRACKING==0 )
            {
                belle_sdp_media_set_media_formats((SCOPE_TOP(media))->current
                                                                                          ,belle_sip_list_append(belle_sdp_media_get_media_formats((SCOPE_TOP(media))->current)
                                                                                          ,(void*)((SCOPE_TOP(fmt))->is_number?(void*)(long)atoi((const char*)
                STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))
                ->chars):STRSTREAM->toStringTT(STRSTREAM, retval.start, LT(-1))
                ->chars)));
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulefmtEx; /* Prevent compiler warnings */
    rulefmtEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    pbelle_sdpParser_fmtPop(ctx);

    return retval;
}
/* $ANTLR end fmt */

/**
 * $ANTLR start proto
 * belle_sdp.g:433:1: proto options {greedy=false; } : (~ ( SPACE | CR | LF ) )* ;
 */
static belle_sdpParser_proto_return
proto(pbelle_sdpParser ctx)
{
    belle_sdpParser_proto_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set234;

    pANTLR3_BASE_TREE set234_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set234       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set234_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:433:47: ( (~ ( SPACE | CR | LF ) )* )
        // belle_sdp.g:433:56: (~ ( SPACE | CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:433:56: (~ ( SPACE | CR | LF ) )*

            for (;;)
            {
                int alt51=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt51=1;
                	}
                    break;

                }

                switch (alt51)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set234=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= SLASH)) || ((LA(1) >= STAR) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set234))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleprotoEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop51;	/* break out of the loop */
            	    break;
                }
            }
            loop51: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleprotoEx; /* Prevent compiler warnings */
    ruleprotoEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end proto */

/**
 * $ANTLR start port
 * belle_sdp.g:436:1: port : ( DIGIT )+ ;
 */
static belle_sdpParser_port_return
port(pbelle_sdpParser ctx)
{
    belle_sdpParser_port_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT235;

    pANTLR3_BASE_TREE DIGIT235_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT235       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT235_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:436:5: ( ( DIGIT )+ )
        // belle_sdp.g:436:22: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:436:22: ( DIGIT )+
            {
                int cnt52=0;

                for (;;)
                {
                    int alt52=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt52=1;
            		}
            	    break;

            	}

            	switch (alt52)
            	{
            	    case 1:
            	        // belle_sdp.g:436:22: DIGIT
            	        {
            	            DIGIT235 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_port2958);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleportEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT235_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT235));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT235_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt52 >= 1 )
            		{
            		    goto loop52;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleportEx;
            	}
            	cnt52++;
                }
                loop52: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleportEx; /* Prevent compiler warnings */
    ruleportEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end port */

/**
 * $ANTLR start attribute_name
 * belle_sdp.g:440:1: attribute_name : token ;
 */
static belle_sdpParser_attribute_name_return
attribute_name(pbelle_sdpParser ctx)
{
    belle_sdpParser_attribute_name_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_token_return token236;
    #undef	RETURN_TYPE_token236
    #define	RETURN_TYPE_token236 belle_sdpParser_token_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    token236.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:440:15: ( token )
        // belle_sdp.g:440:17: token
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_token_in_attribute_name3010);
            token236=token(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleattribute_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, token236.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattribute_nameEx; /* Prevent compiler warnings */
    ruleattribute_nameEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end attribute_name */

/**
 * $ANTLR start attribute_value
 * belle_sdp.g:442:1: attribute_value options {greedy=false; } : (~ ( CR | LF ) )* ;
 */
static belle_sdpParser_attribute_value_return
attribute_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_attribute_value_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set237;

    pANTLR3_BASE_TREE set237_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set237       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set237_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:442:44: ( (~ ( CR | LF ) )* )
        // belle_sdp.g:442:46: (~ ( CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:442:46: (~ ( CR | LF ) )*

            for (;;)
            {
                int alt53=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case SPACE:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt53=1;
                	}
                    break;

                }

                switch (alt53)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set237=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set237))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleattribute_valueEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop53;	/* break out of the loop */
            	    break;
                }
            }
            loop53: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleattribute_valueEx; /* Prevent compiler warnings */
    ruleattribute_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end attribute_value */

/**
 * $ANTLR start rtcp_xr_attribute_name
 * belle_sdp.g:444:1: rtcp_xr_attribute_name : word ;
 */
static belle_sdpParser_rtcp_xr_attribute_name_return
rtcp_xr_attribute_name(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_attribute_name_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_word_return word238;
    #undef	RETURN_TYPE_word238
    #define	RETURN_TYPE_word238 belle_sdpParser_word_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    word238.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:444:23: ( word )
        // belle_sdp.g:444:25: word
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_word_in_rtcp_xr_attribute_name3041);
            word238=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_attribute_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, word238.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_attribute_nameEx; /* Prevent compiler warnings */
    rulertcp_xr_attribute_nameEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_attribute_name */

/**
 * $ANTLR start rtcp_xr_rcvr_rtt_mode
 * belle_sdp.g:446:1: rtcp_xr_rcvr_rtt_mode : word ;
 */
static belle_sdpParser_rtcp_xr_rcvr_rtt_mode_return
rtcp_xr_rcvr_rtt_mode(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_rcvr_rtt_mode_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_word_return word239;
    #undef	RETURN_TYPE_word239
    #define	RETURN_TYPE_word239 belle_sdpParser_word_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    word239.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:446:22: ( word )
        // belle_sdp.g:446:24: word
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_word_in_rtcp_xr_rcvr_rtt_mode3048);
            word239=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_rcvr_rtt_modeEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, word239.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_rcvr_rtt_modeEx; /* Prevent compiler warnings */
    rulertcp_xr_rcvr_rtt_modeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_rcvr_rtt_mode */

/**
 * $ANTLR start rtcp_xr_stat_summary_flag_value
 * belle_sdp.g:448:1: rtcp_xr_stat_summary_flag_value : word ;
 */
static belle_sdpParser_rtcp_xr_stat_summary_flag_value_return
rtcp_xr_stat_summary_flag_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_xr_stat_summary_flag_value_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_word_return word240;
    #undef	RETURN_TYPE_word240
    #define	RETURN_TYPE_word240 belle_sdpParser_word_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    word240.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:448:32: ( word )
        // belle_sdp.g:448:34: word
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_word_in_rtcp_xr_stat_summary_flag_value3055);
            word240=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_xr_stat_summary_flag_valueEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, word240.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_xr_stat_summary_flag_valueEx; /* Prevent compiler warnings */
    rulertcp_xr_stat_summary_flag_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_xr_stat_summary_flag_value */

/**
 * $ANTLR start rtcp_fb_attribute_name
 * belle_sdp.g:450:1: rtcp_fb_attribute_name : word ;
 */
static belle_sdpParser_rtcp_fb_attribute_name_return
rtcp_fb_attribute_name(pbelle_sdpParser ctx)
{
    belle_sdpParser_rtcp_fb_attribute_name_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_word_return word241;
    #undef	RETURN_TYPE_word241
    #define	RETURN_TYPE_word241 belle_sdpParser_word_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    word241.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:450:23: ( word )
        // belle_sdp.g:450:25: word
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_word_in_rtcp_fb_attribute_name3062);
            word241=word(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulertcp_fb_attribute_nameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, word241.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulertcp_fb_attribute_nameEx; /* Prevent compiler warnings */
    rulertcp_fb_attribute_nameEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end rtcp_fb_attribute_name */

/**
 * $ANTLR start sess_id
 * belle_sdp.g:452:1: sess_id : ( DIGIT )+ ;
 */
static belle_sdpParser_sess_id_return
sess_id(pbelle_sdpParser ctx)
{
    belle_sdpParser_sess_id_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT242;

    pANTLR3_BASE_TREE DIGIT242_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT242       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT242_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:452:8: ( ( DIGIT )+ )
        // belle_sdp.g:452:22: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:452:22: ( DIGIT )+
            {
                int cnt54=0;

                for (;;)
                {
                    int alt54=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt54=1;
            		}
            	    break;

            	}

            	switch (alt54)
            	{
            	    case 1:
            	        // belle_sdp.g:452:22: DIGIT
            	        {
            	            DIGIT242 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_sess_id3081);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesess_idEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT242_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT242));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT242_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt54 >= 1 )
            		{
            		    goto loop54;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesess_idEx;
            	}
            	cnt54++;
                }
                loop54: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesess_idEx; /* Prevent compiler warnings */
    rulesess_idEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end sess_id */

/**
 * $ANTLR start sess_version
 * belle_sdp.g:455:1: sess_version : ( DIGIT )+ ;
 */
static belle_sdpParser_sess_version_return
sess_version(pbelle_sdpParser ctx)
{
    belle_sdpParser_sess_version_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT243;

    pANTLR3_BASE_TREE DIGIT243_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT243       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT243_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:455:13: ( ( DIGIT )+ )
        // belle_sdp.g:455:22: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:455:22: ( DIGIT )+
            {
                int cnt55=0;

                for (;;)
                {
                    int alt55=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt55=1;
            		}
            	    break;

            	}

            	switch (alt55)
            	{
            	    case 1:
            	        // belle_sdp.g:455:22: DIGIT
            	        {
            	            DIGIT243 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_sess_version3121);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesess_versionEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT243_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT243));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT243_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt55 >= 1 )
            		{
            		    goto loop55;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesess_versionEx;
            	}
            	cnt55++;
                }
                loop55: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesess_versionEx; /* Prevent compiler warnings */
    rulesess_versionEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end sess_version */

/**
 * $ANTLR start connection_address
 * belle_sdp.g:458:1: connection_address : addr ;
 */
static belle_sdpParser_connection_address_return
connection_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_connection_address_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_addr_return addr244;
    #undef	RETURN_TYPE_addr244
    #define	RETURN_TYPE_addr244 belle_sdpParser_addr_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    addr244.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:458:19: ( addr )
        // belle_sdp.g:461:22: addr
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_addr_in_connection_address3177);
            addr244=addr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleconnection_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, addr244.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleconnection_addressEx; /* Prevent compiler warnings */
    ruleconnection_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end connection_address */

/**
 * $ANTLR start multicast_address
 * belle_sdp.g:463:1: multicast_address : unicast_address '/' ttl ;
 */
static belle_sdpParser_multicast_address_return
multicast_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_multicast_address_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal246;
    belle_sdpParser_unicast_address_return unicast_address245;
    #undef	RETURN_TYPE_unicast_address245
    #define	RETURN_TYPE_unicast_address245 belle_sdpParser_unicast_address_return

    belle_sdpParser_ttl_return ttl247;
    #undef	RETURN_TYPE_ttl247
    #define	RETURN_TYPE_ttl247 belle_sdpParser_ttl_return

    pANTLR3_BASE_TREE char_literal246_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal246       = NULL;
    unicast_address245.tree = NULL;

    ttl247.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal246_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:463:18: ( unicast_address '/' ttl )
        // belle_sdp.g:463:22: unicast_address '/' ttl
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_unicast_address_in_multicast_address3186);
            unicast_address245=unicast_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemulticast_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unicast_address245.tree);

            char_literal246 = (pANTLR3_COMMON_TOKEN) MATCHT(SLASH, &FOLLOW_SLASH_in_multicast_address3188);
            if  (HASEXCEPTION())
            {
                goto rulemulticast_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            char_literal246_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal246));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal246_tree);
            }

            FOLLOWPUSH(FOLLOW_ttl_in_multicast_address3190);
            ttl247=ttl(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulemulticast_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, ttl247.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulemulticast_addressEx; /* Prevent compiler warnings */
    rulemulticast_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end multicast_address */

/**
 * $ANTLR start ttl
 * belle_sdp.g:468:1: ttl : decimal_uchar ;
 */
static belle_sdpParser_ttl_return
ttl(pbelle_sdpParser ctx)
{
    belle_sdpParser_ttl_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_decimal_uchar_return decimal_uchar248;
    #undef	RETURN_TYPE_decimal_uchar248
    #define	RETURN_TYPE_decimal_uchar248 belle_sdpParser_decimal_uchar_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    decimal_uchar248.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:468:4: ( decimal_uchar )
        // belle_sdp.g:468:22: decimal_uchar
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_decimal_uchar_in_ttl3292);
            decimal_uchar248=decimal_uchar(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulettlEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, decimal_uchar248.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulettlEx; /* Prevent compiler warnings */
    rulettlEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end ttl */

/**
 * $ANTLR start start_time
 * belle_sdp.g:470:1: start_time : ( DIGIT )+ ;
 */
static belle_sdpParser_start_time_return
start_time(pbelle_sdpParser ctx)
{
    belle_sdpParser_start_time_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT249;

    pANTLR3_BASE_TREE DIGIT249_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT249       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT249_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:470:11: ( ( DIGIT )+ )
        // belle_sdp.g:470:23: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:470:23: ( DIGIT )+
            {
                int cnt56=0;

                for (;;)
                {
                    int alt56=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt56=1;
            		}
            	    break;

            	}

            	switch (alt56)
            	{
            	    case 1:
            	        // belle_sdp.g:470:23: DIGIT
            	        {
            	            DIGIT249 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_start_time3309);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestart_timeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT249_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT249));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT249_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt56 >= 1 )
            		{
            		    goto loop56;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulestart_timeEx;
            	}
            	cnt56++;
                }
                loop56: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestart_timeEx; /* Prevent compiler warnings */
    rulestart_timeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end start_time */

/**
 * $ANTLR start stop_time
 * belle_sdp.g:472:1: stop_time : ( DIGIT )+ ;
 */
static belle_sdpParser_stop_time_return
stop_time(pbelle_sdpParser ctx)
{
    belle_sdpParser_stop_time_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT250;

    pANTLR3_BASE_TREE DIGIT250_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT250       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT250_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:472:10: ( ( DIGIT )+ )
        // belle_sdp.g:472:22: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:472:22: ( DIGIT )+
            {
                int cnt57=0;

                for (;;)
                {
                    int alt57=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt57=1;
            		}
            	    break;

            	}

            	switch (alt57)
            	{
            	    case 1:
            	        // belle_sdp.g:472:22: DIGIT
            	        {
            	            DIGIT250 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_stop_time3329);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulestop_timeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT250_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT250));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT250_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt57 >= 1 )
            		{
            		    goto loop57;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulestop_timeEx;
            	}
            	cnt57++;
                }
                loop57: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulestop_timeEx; /* Prevent compiler warnings */
    rulestop_timeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end stop_time */

/**
 * $ANTLR start sdp_time
 * belle_sdp.g:474:1: sdp_time : ( DIGIT )+ ;
 */
static belle_sdpParser_sdp_time_return
sdp_time(pbelle_sdpParser ctx)
{
    belle_sdpParser_sdp_time_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT251;

    pANTLR3_BASE_TREE DIGIT251_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT251       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT251_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:474:9: ( ( DIGIT )+ )
        // belle_sdp.g:474:27: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:474:27: ( DIGIT )+
            {
                int cnt58=0;

                for (;;)
                {
                    int alt58=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt58=1;
            		}
            	    break;

            	}

            	switch (alt58)
            	{
            	    case 1:
            	        // belle_sdp.g:474:27: DIGIT
            	        {
            	            DIGIT251 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_sdp_time3355);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulesdp_timeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT251_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT251));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT251_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt58 >= 1 )
            		{
            		    goto loop58;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulesdp_timeEx;
            	}
            	cnt58++;
                }
                loop58: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulesdp_timeEx; /* Prevent compiler warnings */
    rulesdp_timeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end sdp_time */

/**
 * $ANTLR start repeat_interval
 * belle_sdp.g:477:1: repeat_interval : typed_time ;
 */
static belle_sdpParser_repeat_interval_return
repeat_interval(pbelle_sdpParser ctx)
{
    belle_sdpParser_repeat_interval_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_typed_time_return typed_time252;
    #undef	RETURN_TYPE_typed_time252
    #define	RETURN_TYPE_typed_time252 belle_sdpParser_typed_time_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    typed_time252.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:477:16: ( typed_time )
        // belle_sdp.g:477:22: typed_time
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_typed_time_in_repeat_interval3389);
            typed_time252=typed_time(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulerepeat_intervalEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, typed_time252.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulerepeat_intervalEx; /* Prevent compiler warnings */
    rulerepeat_intervalEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end repeat_interval */

/**
 * $ANTLR start typed_time
 * belle_sdp.g:479:1: typed_time : ( DIGIT )* ( fixed_len_time_unit )? ;
 */
static belle_sdpParser_typed_time_return
typed_time(pbelle_sdpParser ctx)
{
    belle_sdpParser_typed_time_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT253;
    belle_sdpParser_fixed_len_time_unit_return fixed_len_time_unit254;
    #undef	RETURN_TYPE_fixed_len_time_unit254
    #define	RETURN_TYPE_fixed_len_time_unit254 belle_sdpParser_fixed_len_time_unit_return

    pANTLR3_BASE_TREE DIGIT253_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT253       = NULL;
    fixed_len_time_unit254.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT253_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:479:11: ( ( DIGIT )* ( fixed_len_time_unit )? )
        // belle_sdp.g:479:22: ( DIGIT )* ( fixed_len_time_unit )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:479:22: ( DIGIT )*

            for (;;)
            {
                int alt59=2;
                switch ( LA(1) )
                {
                case DIGIT:
                	{
                		{
                		   /* dfaLoopbackState(k,edges,eotPredictsAlt,description,stateNumber,semPredState)
                		    */
                		    int LA59_2 = LA(2);
                		    if ( (!( ((((IS_TOKEN(h)))||((IS_TOKEN(d)))||((IS_TOKEN(s)))||((IS_TOKEN(m))))) )))
                		    {
                		        alt59=1;
                		    }

                		}
                	}
                    break;

                }

                switch (alt59)
                {
            	case 1:
            	    // belle_sdp.g:479:22: DIGIT
            	    {
            	        DIGIT253 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_typed_time3405);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletyped_timeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DIGIT253_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT253));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DIGIT253_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop59;	/* break out of the loop */
            	    break;
                }
            }
            loop59: ; /* Jump out to here if this rule does not match */


            // belle_sdp.g:479:29: ( fixed_len_time_unit )?
            {
                int alt60=2;
                switch ( LA(1) )
                {
                    case COMMON_CHAR:
                    case DIGIT:
                    case HEX_CHAR:
                    	{
                    		alt60=1;
                    	}
                        break;
                }

                switch (alt60)
                {
            	case 1:
            	    // belle_sdp.g:479:29: fixed_len_time_unit
            	    {
            	        FOLLOWPUSH(FOLLOW_fixed_len_time_unit_in_typed_time3408);
            	        fixed_len_time_unit254=fixed_len_time_unit(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruletyped_timeEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, fixed_len_time_unit254.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletyped_timeEx; /* Prevent compiler warnings */
    ruletyped_timeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end typed_time */

/**
 * $ANTLR start fixed_len_time_unit
 * belle_sdp.g:481:1: fixed_len_time_unit : ({...}? alpha_num |{...}? alpha_num |{...}? alpha_num |{...}? alpha_num );
 */
static belle_sdpParser_fixed_len_time_unit_return
fixed_len_time_unit(pbelle_sdpParser ctx)
{
    belle_sdpParser_fixed_len_time_unit_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_alpha_num_return alpha_num255;
    #undef	RETURN_TYPE_alpha_num255
    #define	RETURN_TYPE_alpha_num255 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num256;
    #undef	RETURN_TYPE_alpha_num256
    #define	RETURN_TYPE_alpha_num256 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num257;
    #undef	RETURN_TYPE_alpha_num257
    #define	RETURN_TYPE_alpha_num257 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num258;
    #undef	RETURN_TYPE_alpha_num258
    #define	RETURN_TYPE_alpha_num258 belle_sdpParser_alpha_num_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    alpha_num255.tree = NULL;

    alpha_num256.tree = NULL;

    alpha_num257.tree = NULL;

    alpha_num258.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:481:20: ({...}? alpha_num |{...}? alpha_num |{...}? alpha_num |{...}? alpha_num )

            ANTLR3_UINT32 alt61;

            alt61=4;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		{
            		    int LA61_1 = LA(2);
            		    if ( ((IS_TOKEN(d))))
            		    {
            		        alt61=1;
            		    }
            		    else if ( ((IS_TOKEN(h))))
            		    {
            		        alt61=2;
            		    }
            		    else if ( ((IS_TOKEN(m))))
            		    {
            		        alt61=3;
            		    }
            		    else if ( ((IS_TOKEN(s))))
            		    {
            		        alt61=4;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 61;
            		        EXCEPTION->state        = 1;


            		        goto rulefixed_len_time_unitEx;

            		    }
            		}
            	}
                break;
            case DIGIT:
            	{
            		{
            		    int LA61_2 = LA(2);
            		    if ( ((IS_TOKEN(d))))
            		    {
            		        alt61=1;
            		    }
            		    else if ( ((IS_TOKEN(h))))
            		    {
            		        alt61=2;
            		    }
            		    else if ( ((IS_TOKEN(m))))
            		    {
            		        alt61=3;
            		    }
            		    else if ( ((IS_TOKEN(s))))
            		    {
            		        alt61=4;
            		    }
            		    else
            		    {
            		        if (BACKTRACKING>0)
            		        {
            		            FAILEDFLAG = ANTLR3_TRUE;
            		            return retval;
            		        }


            		        CONSTRUCTEX();
            		        EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		        EXCEPTION->message      = (void *)"";
            		        EXCEPTION->decisionNum  = 61;
            		        EXCEPTION->state        = 2;


            		        goto rulefixed_len_time_unitEx;

            		    }
            		}
            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 61;
                EXCEPTION->state        = 0;


                goto rulefixed_len_time_unitEx;

            }

            switch (alt61)
            {
        	case 1:
        	    // belle_sdp.g:481:22: {...}? alpha_num
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        if ( !((IS_TOKEN(d))) )
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                EXCEPTION->message      = (void *)"IS_TOKEN(d)";
        	                EXCEPTION->ruleName	 = (void *)"fixed_len_time_unit";


        	        }

        	        FOLLOWPUSH(FOLLOW_alpha_num_in_fixed_len_time_unit3418);
        	        alpha_num255=alpha_num(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefixed_len_time_unitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num255.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:482:25: {...}? alpha_num
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        if ( !((IS_TOKEN(h))) )
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                EXCEPTION->message      = (void *)"IS_TOKEN(h)";
        	                EXCEPTION->ruleName	 = (void *)"fixed_len_time_unit";


        	        }

        	        FOLLOWPUSH(FOLLOW_alpha_num_in_fixed_len_time_unit3446);
        	        alpha_num256=alpha_num(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefixed_len_time_unitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num256.tree);

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:483:25: {...}? alpha_num
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        if ( !((IS_TOKEN(m))) )
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                EXCEPTION->message      = (void *)"IS_TOKEN(m)";
        	                EXCEPTION->ruleName	 = (void *)"fixed_len_time_unit";


        	        }

        	        FOLLOWPUSH(FOLLOW_alpha_num_in_fixed_len_time_unit3474);
        	        alpha_num257=alpha_num(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefixed_len_time_unitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num257.tree);

        	    }
        	    break;
        	case 4:
        	    // belle_sdp.g:484:25: {...}? alpha_num
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        if ( !((IS_TOKEN(s))) )
        	        {
        	            if (BACKTRACKING>0)
        	            {
        	                FAILEDFLAG = ANTLR3_TRUE;
        	                return retval;
        	            }

        	                CONSTRUCTEX();
        	                EXCEPTION->type         = ANTLR3_FAILED_PREDICATE_EXCEPTION;
        	                EXCEPTION->message      = (void *)"IS_TOKEN(s)";
        	                EXCEPTION->ruleName	 = (void *)"fixed_len_time_unit";


        	        }

        	        FOLLOWPUSH(FOLLOW_alpha_num_in_fixed_len_time_unit3502);
        	        alpha_num258=alpha_num(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulefixed_len_time_unitEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num258.tree);

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulefixed_len_time_unitEx; /* Prevent compiler warnings */
    rulefixed_len_time_unitEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end fixed_len_time_unit */

/**
 * $ANTLR start bwtype
 * belle_sdp.g:486:1: bwtype : ( alpha_num )+ ;
 */
static belle_sdpParser_bwtype_return
bwtype(pbelle_sdpParser ctx)
{
    belle_sdpParser_bwtype_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_alpha_num_return alpha_num259;
    #undef	RETURN_TYPE_alpha_num259
    #define	RETURN_TYPE_alpha_num259 belle_sdpParser_alpha_num_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    alpha_num259.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:486:7: ( ( alpha_num )+ )
        // belle_sdp.g:486:22: ( alpha_num )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:486:22: ( alpha_num )+
            {
                int cnt62=0;

                for (;;)
                {
                    int alt62=2;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt62=1;
            		}
            	    break;

            	}

            	switch (alt62)
            	{
            	    case 1:
            	        // belle_sdp.g:486:22: alpha_num
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_num_in_bwtype3522);
            	            alpha_num259=alpha_num(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulebwtypeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num259.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt62 >= 1 )
            		{
            		    goto loop62;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulebwtypeEx;
            	}
            	cnt62++;
                }
                loop62: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebwtypeEx; /* Prevent compiler warnings */
    rulebwtypeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end bwtype */

/**
 * $ANTLR start bandwidth_value
 * belle_sdp.g:488:1: bandwidth_value : ( DIGIT )+ ;
 */
static belle_sdpParser_bandwidth_value_return
bandwidth_value(pbelle_sdpParser ctx)
{
    belle_sdpParser_bandwidth_value_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT260;

    pANTLR3_BASE_TREE DIGIT260_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT260       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT260_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:488:16: ( ( DIGIT )+ )
        // belle_sdp.g:488:28: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:488:28: ( DIGIT )+
            {
                int cnt63=0;

                for (;;)
                {
                    int alt63=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt63=1;
            		}
            	    break;

            	}

            	switch (alt63)
            	{
            	    case 1:
            	        // belle_sdp.g:488:28: DIGIT
            	        {
            	            DIGIT260 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_bandwidth_value3540);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulebandwidth_valueEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT260_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT260));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT260_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt63 >= 1 )
            		{
            		    goto loop63;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulebandwidth_valueEx;
            	}
            	cnt63++;
                }
                loop63: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulebandwidth_valueEx; /* Prevent compiler warnings */
    rulebandwidth_valueEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end bandwidth_value */

/**
 * $ANTLR start username
 * belle_sdp.g:490:1: username : email_safe ;
 */
static belle_sdpParser_username_return
username(pbelle_sdpParser ctx)
{
    belle_sdpParser_username_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_email_safe_return email_safe261;
    #undef	RETURN_TYPE_email_safe261
    #define	RETURN_TYPE_email_safe261 belle_sdpParser_email_safe_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    email_safe261.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:490:9: ( email_safe )
        // belle_sdp.g:490:22: email_safe
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_email_safe_in_username3559);
            email_safe261=email_safe(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleusernameEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, email_safe261.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleusernameEx; /* Prevent compiler warnings */
    ruleusernameEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end username */

/**
 * $ANTLR start email_address
 * belle_sdp.g:493:1: email_address options {greedy=false; } : (~ ( CR | LF ) )* ;
 */
static belle_sdpParser_email_address_return
email_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_email_address_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set262;

    pANTLR3_BASE_TREE set262_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set262       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set262_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:493:48: ( (~ ( CR | LF ) )* )
        // belle_sdp.g:493:57: (~ ( CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:493:57: (~ ( CR | LF ) )*

            for (;;)
            {
                int alt64=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case SPACE:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt64=1;
                	}
                    break;

                }

                switch (alt64)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set262=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set262))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleemail_addressEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop64;	/* break out of the loop */
            	    break;
                }
            }
            loop64: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleemail_addressEx; /* Prevent compiler warnings */
    ruleemail_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end email_address */

/**
 * $ANTLR start uri
 * belle_sdp.g:497:1: uri : text ;
 */
static belle_sdpParser_uri_return
uri(pbelle_sdpParser ctx)
{
    belle_sdpParser_uri_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_text_return text263;
    #undef	RETURN_TYPE_text263
    #define	RETURN_TYPE_text263 belle_sdpParser_text_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    text263.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:497:4: ( text )
        // belle_sdp.g:497:15: text
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_text_in_uri3668);
            text263=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleuriEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, text263.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleuriEx; /* Prevent compiler warnings */
    ruleuriEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end uri */

/**
 * $ANTLR start phone_number
 * belle_sdp.g:499:1: phone_number : phone ;
 */
static belle_sdpParser_phone_number_return
phone_number(pbelle_sdpParser ctx)
{
    belle_sdpParser_phone_number_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_phone_return phone264;
    #undef	RETURN_TYPE_phone264
    #define	RETURN_TYPE_phone264 belle_sdpParser_phone_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    phone264.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:499:13: ( phone )
        // belle_sdp.g:499:23: phone
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_phone_in_phone_number3691);
            phone264=phone(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulephone_numberEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, phone264.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulephone_numberEx; /* Prevent compiler warnings */
    rulephone_numberEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end phone_number */

/**
 * $ANTLR start phone
 * belle_sdp.g:503:1: phone : text ;
 */
static belle_sdpParser_phone_return
phone(pbelle_sdpParser ctx)
{
    belle_sdpParser_phone_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_text_return text265;
    #undef	RETURN_TYPE_text265
    #define	RETURN_TYPE_text265 belle_sdpParser_text_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    text265.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:503:6: ( text )
        // belle_sdp.g:503:22: text
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_text_in_phone3713);
            text265=text(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulephoneEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, text265.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto rulephoneEx; /* Prevent compiler warnings */
    rulephoneEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end phone */

/**
 * $ANTLR start nettype
 * belle_sdp.g:507:1: nettype : ( alpha_num )+ ;
 */
static belle_sdpParser_nettype_return
nettype(pbelle_sdpParser ctx)
{
    belle_sdpParser_nettype_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_alpha_num_return alpha_num266;
    #undef	RETURN_TYPE_alpha_num266
    #define	RETURN_TYPE_alpha_num266 belle_sdpParser_alpha_num_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    alpha_num266.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:507:8: ( ( alpha_num )+ )
        // belle_sdp.g:507:22: ( alpha_num )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:507:22: ( alpha_num )+
            {
                int cnt65=0;

                for (;;)
                {
                    int alt65=2;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt65=1;
            		}
            	    break;

            	}

            	switch (alt65)
            	{
            	    case 1:
            	        // belle_sdp.g:507:22: alpha_num
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_num_in_nettype3784);
            	            alpha_num266=alpha_num(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulenettypeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num266.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt65 >= 1 )
            		{
            		    goto loop65;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulenettypeEx;
            	}
            	cnt65++;
                }
                loop65: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulenettypeEx; /* Prevent compiler warnings */
    rulenettypeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end nettype */

/**
 * $ANTLR start addrtype
 * belle_sdp.g:510:1: addrtype : ( alpha_num )+ ;
 */
static belle_sdpParser_addrtype_return
addrtype(pbelle_sdpParser ctx)
{
    belle_sdpParser_addrtype_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_alpha_num_return alpha_num267;
    #undef	RETURN_TYPE_alpha_num267
    #define	RETURN_TYPE_alpha_num267 belle_sdpParser_alpha_num_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    alpha_num267.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:510:9: ( ( alpha_num )+ )
        // belle_sdp.g:510:22: ( alpha_num )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:510:22: ( alpha_num )+
            {
                int cnt66=0;

                for (;;)
                {
                    int alt66=2;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt66=1;
            		}
            	    break;

            	}

            	switch (alt66)
            	{
            	    case 1:
            	        // belle_sdp.g:510:22: alpha_num
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_num_in_addrtype3828);
            	            alpha_num267=alpha_num(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleaddrtypeEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num267.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt66 >= 1 )
            		{
            		    goto loop66;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleaddrtypeEx;
            	}
            	cnt66++;
                }
                loop66: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddrtypeEx; /* Prevent compiler warnings */
    ruleaddrtypeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end addrtype */

/**
 * $ANTLR start addr
 * belle_sdp.g:513:1: addr : unicast_address ;
 */
static belle_sdpParser_addr_return
addr(pbelle_sdpParser ctx)
{
    belle_sdpParser_addr_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_unicast_address_return unicast_address268;
    #undef	RETURN_TYPE_unicast_address268
    #define	RETURN_TYPE_unicast_address268 belle_sdpParser_unicast_address_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    unicast_address268.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:513:5: ( unicast_address )
        // belle_sdp.g:513:23: unicast_address
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_unicast_address_in_addr3880);
            unicast_address268=unicast_address(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaddrEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, unicast_address268.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleaddrEx; /* Prevent compiler warnings */
    ruleaddrEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end addr */

/**
 * $ANTLR start fqdn
 * belle_sdp.g:516:1: fqdn : ( domainlabel DOT )* toplabel ( DOT )? ;
 */
static belle_sdpParser_fqdn_return
fqdn(pbelle_sdpParser ctx)
{
    belle_sdpParser_fqdn_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT270;
    pANTLR3_COMMON_TOKEN    DOT272;
    belle_sdpParser_domainlabel_return domainlabel269;
    #undef	RETURN_TYPE_domainlabel269
    #define	RETURN_TYPE_domainlabel269 belle_sdpParser_domainlabel_return

    belle_sdpParser_toplabel_return toplabel271;
    #undef	RETURN_TYPE_toplabel271
    #define	RETURN_TYPE_toplabel271 belle_sdpParser_toplabel_return

    pANTLR3_BASE_TREE DOT270_tree;
    pANTLR3_BASE_TREE DOT272_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DOT270       = NULL;
    DOT272       = NULL;
    domainlabel269.tree = NULL;

    toplabel271.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DOT270_tree   = NULL;
    DOT272_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:516:13: ( ( domainlabel DOT )* toplabel ( DOT )? )
        // belle_sdp.g:516:17: ( domainlabel DOT )* toplabel ( DOT )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:516:17: ( domainlabel DOT )*

            for (;;)
            {
                int alt67=2;
                alt67 = cdfa67.predict(ctx, RECOGNIZER, ISTREAM, &cdfa67);
                if  (HASEXCEPTION())
                {
                    goto rulefqdnEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                switch (alt67)
                {
            	case 1:
            	    // belle_sdp.g:516:19: domainlabel DOT
            	    {
            	        FOLLOWPUSH(FOLLOW_domainlabel_in_fqdn3903);
            	        domainlabel269=domainlabel(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefqdnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, domainlabel269.tree);

            	        DOT270 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_fqdn3905);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefqdnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DOT270_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT270));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT270_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop67;	/* break out of the loop */
            	    break;
                }
            }
            loop67: ; /* Jump out to here if this rule does not match */


            FOLLOWPUSH(FOLLOW_toplabel_in_fqdn3910);
            toplabel271=toplabel(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulefqdnEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, toplabel271.tree);

            // belle_sdp.g:516:47: ( DOT )?
            {
                int alt68=2;
                switch ( LA(1) )
                {
                    case DOT:
                    	{
                    		alt68=1;
                    	}
                        break;
                }

                switch (alt68)
                {
            	case 1:
            	    // belle_sdp.g:516:47: DOT
            	    {
            	        DOT272 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_fqdn3912);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulefqdnEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DOT272_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT272));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT272_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulefqdnEx; /* Prevent compiler warnings */
    rulefqdnEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end fqdn */

/**
 * $ANTLR start domainlabel
 * belle_sdp.g:518:1: domainlabel : ( alpha_num | ( alpha_num ( alpha_num | DASH )* alpha_num ) );
 */
static belle_sdpParser_domainlabel_return
domainlabel(pbelle_sdpParser ctx)
{
    belle_sdpParser_domainlabel_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DASH276;
    belle_sdpParser_alpha_num_return alpha_num273;
    #undef	RETURN_TYPE_alpha_num273
    #define	RETURN_TYPE_alpha_num273 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num274;
    #undef	RETURN_TYPE_alpha_num274
    #define	RETURN_TYPE_alpha_num274 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num275;
    #undef	RETURN_TYPE_alpha_num275
    #define	RETURN_TYPE_alpha_num275 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num277;
    #undef	RETURN_TYPE_alpha_num277
    #define	RETURN_TYPE_alpha_num277 belle_sdpParser_alpha_num_return

    pANTLR3_BASE_TREE DASH276_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DASH276       = NULL;
    alpha_num273.tree = NULL;

    alpha_num274.tree = NULL;

    alpha_num275.tree = NULL;

    alpha_num277.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DASH276_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:518:17: ( alpha_num | ( alpha_num ( alpha_num | DASH )* alpha_num ) )

            ANTLR3_UINT32 alt70;

            alt70=2;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		switch ( LA(2) )
            		{
            		case DOT:
            			{
            				alt70=1;
            			}
            		    break;
            		case COMMON_CHAR:
            		case DASH:
            		case DIGIT:
            		case HEX_CHAR:
            			{
            				alt70=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 70;
            		    EXCEPTION->state        = 1;


            		    goto ruledomainlabelEx;

            		}

            	}
                break;
            case DIGIT:
            	{
            		switch ( LA(2) )
            		{
            		case DOT:
            			{
            				alt70=1;
            			}
            		    break;
            		case COMMON_CHAR:
            		case DASH:
            		case DIGIT:
            		case HEX_CHAR:
            			{
            				alt70=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 70;
            		    EXCEPTION->state        = 2;


            		    goto ruledomainlabelEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 70;
                EXCEPTION->state        = 0;


                goto ruledomainlabelEx;

            }

            switch (alt70)
            {
        	case 1:
        	    // belle_sdp.g:518:21: alpha_num
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_alpha_num_in_domainlabel3930);
        	        alpha_num273=alpha_num(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledomainlabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num273.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:518:33: ( alpha_num ( alpha_num | DASH )* alpha_num )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // belle_sdp.g:518:33: ( alpha_num ( alpha_num | DASH )* alpha_num )
        	        // belle_sdp.g:518:34: alpha_num ( alpha_num | DASH )* alpha_num
        	        {
        	            FOLLOWPUSH(FOLLOW_alpha_num_in_domainlabel3935);
        	            alpha_num274=alpha_num(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num274.tree);

        	            // belle_sdp.g:518:44: ( alpha_num | DASH )*

        	            for (;;)
        	            {
        	                int alt69=3;
        	                switch ( LA(1) )
        	                {
        	                case COMMON_CHAR:
        	                case HEX_CHAR:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		case COMMON_CHAR:
        	                		case DASH:
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                			{
        	                				alt69=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DIGIT:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		case COMMON_CHAR:
        	                		case DASH:
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                			{
        	                				alt69=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DASH:
        	                	{
        	                		alt69=2;
        	                	}
        	                    break;

        	                }

        	                switch (alt69)
        	                {
        	            	case 1:
        	            	    // belle_sdp.g:518:46: alpha_num
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_alpha_num_in_domainlabel3939);
        	            	        alpha_num275=alpha_num(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }

        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num275.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // belle_sdp.g:518:58: DASH
        	            	    {
        	            	        DASH276 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_domainlabel3943);
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruledomainlabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }

        	            	        if ( BACKTRACKING==0 ) {
        	            	        DASH276_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DASH276));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, DASH276_tree);
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop69;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop69: ; /* Jump out to here if this rule does not match */


        	            FOLLOWPUSH(FOLLOW_alpha_num_in_domainlabel3948);
        	            alpha_num277=alpha_num(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruledomainlabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num277.tree);

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruledomainlabelEx; /* Prevent compiler warnings */
    ruledomainlabelEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end domainlabel */

/**
 * $ANTLR start toplabel
 * belle_sdp.g:519:1: toplabel : ( alpha | ( alpha ( alpha_num | DASH )* alpha_num ) );
 */
static belle_sdpParser_toplabel_return
toplabel(pbelle_sdpParser ctx)
{
    belle_sdpParser_toplabel_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DASH281;
    belle_sdpParser_alpha_return alpha278;
    #undef	RETURN_TYPE_alpha278
    #define	RETURN_TYPE_alpha278 belle_sdpParser_alpha_return

    belle_sdpParser_alpha_return alpha279;
    #undef	RETURN_TYPE_alpha279
    #define	RETURN_TYPE_alpha279 belle_sdpParser_alpha_return

    belle_sdpParser_alpha_num_return alpha_num280;
    #undef	RETURN_TYPE_alpha_num280
    #define	RETURN_TYPE_alpha_num280 belle_sdpParser_alpha_num_return

    belle_sdpParser_alpha_num_return alpha_num282;
    #undef	RETURN_TYPE_alpha_num282
    #define	RETURN_TYPE_alpha_num282 belle_sdpParser_alpha_num_return

    pANTLR3_BASE_TREE DASH281_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DASH281       = NULL;
    alpha278.tree = NULL;

    alpha279.tree = NULL;

    alpha_num280.tree = NULL;

    alpha_num282.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DASH281_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:519:17: ( alpha | ( alpha ( alpha_num | DASH )* alpha_num ) )

            ANTLR3_UINT32 alt72;

            alt72=2;

            switch ( LA(1) )
            {
            case COMMON_CHAR:
            case HEX_CHAR:
            	{
            		switch ( LA(2) )
            		{
            		case EOF:
            		case DOT:
            			{
            				alt72=1;
            			}
            		    break;
            		case COMMON_CHAR:
            		case DASH:
            		case DIGIT:
            		case HEX_CHAR:
            			{
            				alt72=2;
            			}
            		    break;

            		default:
            		    if (BACKTRACKING>0)
            		    {
            		        FAILEDFLAG = ANTLR3_TRUE;
            		        return retval;
            		    }

            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 72;
            		    EXCEPTION->state        = 1;


            		    goto ruletoplabelEx;

            		}

            	}
                break;

            default:
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 72;
                EXCEPTION->state        = 0;


                goto ruletoplabelEx;

            }

            switch (alt72)
            {
        	case 1:
        	    // belle_sdp.g:519:21: alpha
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_alpha_in_toplabel3966);
        	        alpha278=alpha(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruletoplabelEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha278.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:519:29: ( alpha ( alpha_num | DASH )* alpha_num )
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // belle_sdp.g:519:29: ( alpha ( alpha_num | DASH )* alpha_num )
        	        // belle_sdp.g:519:30: alpha ( alpha_num | DASH )* alpha_num
        	        {
        	            FOLLOWPUSH(FOLLOW_alpha_in_toplabel3971);
        	            alpha279=alpha(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletoplabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha279.tree);

        	            // belle_sdp.g:519:36: ( alpha_num | DASH )*

        	            for (;;)
        	            {
        	                int alt71=3;
        	                switch ( LA(1) )
        	                {
        	                case COMMON_CHAR:
        	                case HEX_CHAR:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		case COMMON_CHAR:
        	                		case DASH:
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                			{
        	                				alt71=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DIGIT:
        	                	{
        	                		switch ( LA(2) )
        	                		{
        	                		case COMMON_CHAR:
        	                		case DASH:
        	                		case DIGIT:
        	                		case HEX_CHAR:
        	                			{
        	                				alt71=1;
        	                			}
        	                		    break;

        	                		}

        	                	}
        	                    break;
        	                case DASH:
        	                	{
        	                		alt71=2;
        	                	}
        	                    break;

        	                }

        	                switch (alt71)
        	                {
        	            	case 1:
        	            	    // belle_sdp.g:519:38: alpha_num
        	            	    {
        	            	        FOLLOWPUSH(FOLLOW_alpha_num_in_toplabel3975);
        	            	        alpha_num280=alpha_num(ctx);

        	            	        FOLLOWPOP();
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletoplabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }

        	            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num280.tree);

        	            	    }
        	            	    break;
        	            	case 2:
        	            	    // belle_sdp.g:519:50: DASH
        	            	    {
        	            	        DASH281 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_toplabel3979);
        	            	        if  (HASEXCEPTION())
        	            	        {
        	            	            goto ruletoplabelEx;
        	            	        }
        	            	        if (HASFAILED())
        	            	        {
        	            	            return retval;
        	            	        }

        	            	        if ( BACKTRACKING==0 ) {
        	            	        DASH281_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DASH281));
        	            	        ADAPTOR->addChild(ADAPTOR, root_0, DASH281_tree);
        	            	        }

        	            	    }
        	            	    break;

        	            	default:
        	            	    goto loop71;	/* break out of the loop */
        	            	    break;
        	                }
        	            }
        	            loop71: ; /* Jump out to here if this rule does not match */


        	            FOLLOWPUSH(FOLLOW_alpha_num_in_toplabel3984);
        	            alpha_num282=alpha_num(ctx);

        	            FOLLOWPOP();
        	            if  (HASEXCEPTION())
        	            {
        	                goto ruletoplabelEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return retval;
        	            }

        	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num282.tree);

        	        }


        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto ruletoplabelEx; /* Prevent compiler warnings */
    ruletoplabelEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end toplabel */

/**
 * $ANTLR start unicast_address
 * belle_sdp.g:521:1: unicast_address : ( alpha_num | DOT | COLON | DASH )* ;
 */
static belle_sdpParser_unicast_address_return
unicast_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_unicast_address_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT284;
    pANTLR3_COMMON_TOKEN    COLON285;
    pANTLR3_COMMON_TOKEN    DASH286;
    belle_sdpParser_alpha_num_return alpha_num283;
    #undef	RETURN_TYPE_alpha_num283
    #define	RETURN_TYPE_alpha_num283 belle_sdpParser_alpha_num_return

    pANTLR3_BASE_TREE DOT284_tree;
    pANTLR3_BASE_TREE COLON285_tree;
    pANTLR3_BASE_TREE DASH286_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DOT284       = NULL;
    COLON285       = NULL;
    DASH286       = NULL;
    alpha_num283.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DOT284_tree   = NULL;
    COLON285_tree   = NULL;
    DASH286_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:521:17: ( ( alpha_num | DOT | COLON | DASH )* )
        // belle_sdp.g:521:21: ( alpha_num | DOT | COLON | DASH )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:521:21: ( alpha_num | DOT | COLON | DASH )*

            for (;;)
            {
                int alt73=5;
                switch ( LA(1) )
                {
                case COMMON_CHAR:
                case DIGIT:
                case HEX_CHAR:
                	{
                		alt73=1;
                	}
                    break;
                case DOT:
                	{
                		alt73=2;
                	}
                    break;
                case COLON:
                	{
                		alt73=3;
                	}
                    break;
                case DASH:
                	{
                		alt73=4;
                	}
                    break;

                }

                switch (alt73)
                {
            	case 1:
            	    // belle_sdp.g:521:22: alpha_num
            	    {
            	        FOLLOWPUSH(FOLLOW_alpha_num_in_unicast_address3997);
            	        alpha_num283=alpha_num(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunicast_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num283.tree);

            	    }
            	    break;
            	case 2:
            	    // belle_sdp.g:521:34: DOT
            	    {
            	        DOT284 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_unicast_address4001);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunicast_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DOT284_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT284));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DOT284_tree);
            	        }

            	    }
            	    break;
            	case 3:
            	    // belle_sdp.g:521:40: COLON
            	    {
            	        COLON285 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_unicast_address4005);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunicast_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON285_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON285));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON285_tree);
            	        }

            	    }
            	    break;
            	case 4:
            	    // belle_sdp.g:521:47: DASH
            	    {
            	        DASH286 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_unicast_address4008);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleunicast_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DASH286_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DASH286));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DASH286_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop73;	/* break out of the loop */
            	    break;
                }
            }
            loop73: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleunicast_addressEx; /* Prevent compiler warnings */
    ruleunicast_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end unicast_address */

/**
 * $ANTLR start ipv4_address
 * belle_sdp.g:526:1: ipv4_address : decimal_uchar DOT decimal_uchar DOT decimal_uchar DOT decimal_uchar ;
 */
static belle_sdpParser_ipv4_address_return
ipv4_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_ipv4_address_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DOT288;
    pANTLR3_COMMON_TOKEN    DOT290;
    pANTLR3_COMMON_TOKEN    DOT292;
    belle_sdpParser_decimal_uchar_return decimal_uchar287;
    #undef	RETURN_TYPE_decimal_uchar287
    #define	RETURN_TYPE_decimal_uchar287 belle_sdpParser_decimal_uchar_return

    belle_sdpParser_decimal_uchar_return decimal_uchar289;
    #undef	RETURN_TYPE_decimal_uchar289
    #define	RETURN_TYPE_decimal_uchar289 belle_sdpParser_decimal_uchar_return

    belle_sdpParser_decimal_uchar_return decimal_uchar291;
    #undef	RETURN_TYPE_decimal_uchar291
    #define	RETURN_TYPE_decimal_uchar291 belle_sdpParser_decimal_uchar_return

    belle_sdpParser_decimal_uchar_return decimal_uchar293;
    #undef	RETURN_TYPE_decimal_uchar293
    #define	RETURN_TYPE_decimal_uchar293 belle_sdpParser_decimal_uchar_return

    pANTLR3_BASE_TREE DOT288_tree;
    pANTLR3_BASE_TREE DOT290_tree;
    pANTLR3_BASE_TREE DOT292_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DOT288       = NULL;
    DOT290       = NULL;
    DOT292       = NULL;
    decimal_uchar287.tree = NULL;

    decimal_uchar289.tree = NULL;

    decimal_uchar291.tree = NULL;

    decimal_uchar293.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DOT288_tree   = NULL;
    DOT290_tree   = NULL;
    DOT292_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:526:14: ( decimal_uchar DOT decimal_uchar DOT decimal_uchar DOT decimal_uchar )
        // belle_sdp.g:526:24: decimal_uchar DOT decimal_uchar DOT decimal_uchar DOT decimal_uchar
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_decimal_uchar_in_ipv4_address4052);
            decimal_uchar287=decimal_uchar(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, decimal_uchar287.tree);

            DOT288 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_ipv4_address4054);
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            DOT288_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT288));
            ADAPTOR->addChild(ADAPTOR, root_0, DOT288_tree);
            }

            FOLLOWPUSH(FOLLOW_decimal_uchar_in_ipv4_address4056);
            decimal_uchar289=decimal_uchar(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, decimal_uchar289.tree);

            DOT290 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_ipv4_address4058);
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            DOT290_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT290));
            ADAPTOR->addChild(ADAPTOR, root_0, DOT290_tree);
            }

            FOLLOWPUSH(FOLLOW_decimal_uchar_in_ipv4_address4060);
            decimal_uchar291=decimal_uchar(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, decimal_uchar291.tree);

            DOT292 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_ipv4_address4062);
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) {
            DOT292_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT292));
            ADAPTOR->addChild(ADAPTOR, root_0, DOT292_tree);
            }

            FOLLOWPUSH(FOLLOW_decimal_uchar_in_ipv4_address4064);
            decimal_uchar293=decimal_uchar(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv4_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, decimal_uchar293.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleipv4_addressEx; /* Prevent compiler warnings */
    ruleipv4_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end ipv4_address */

/**
 * $ANTLR start ipv6_address
 * belle_sdp.g:530:1: ipv6_address : ( hexpart )=> hexpart ( COLON ipv4_address )? ;
 */
static belle_sdpParser_ipv6_address_return
ipv6_address(pbelle_sdpParser ctx)
{
    belle_sdpParser_ipv6_address_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON295;
    belle_sdpParser_hexpart_return hexpart294;
    #undef	RETURN_TYPE_hexpart294
    #define	RETURN_TYPE_hexpart294 belle_sdpParser_hexpart_return

    belle_sdpParser_ipv4_address_return ipv4_address296;
    #undef	RETURN_TYPE_ipv4_address296
    #define	RETURN_TYPE_ipv4_address296 belle_sdpParser_ipv4_address_return

    pANTLR3_BASE_TREE COLON295_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    COLON295       = NULL;
    hexpart294.tree = NULL;

    ipv4_address296.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COLON295_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:530:17: ( ( hexpart )=> hexpart ( COLON ipv4_address )? )
        // belle_sdp.g:530:20: ( hexpart )=> hexpart ( COLON ipv4_address )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_hexpart_in_ipv6_address4083);
            hexpart294=hexpart(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleipv6_addressEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexpart294.tree);

            // belle_sdp.g:530:39: ( COLON ipv4_address )?
            {
                int alt74=2;
                switch ( LA(1) )
                {
                    case COLON:
                    	{
                    		alt74=1;
                    	}
                        break;
                }

                switch (alt74)
                {
            	case 1:
            	    // belle_sdp.g:530:41: COLON ipv4_address
            	    {
            	        COLON295 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_ipv6_address4087);
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON295_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON295));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON295_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_ipv4_address_in_ipv6_address4089);
            	        ipv4_address296=ipv4_address(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleipv6_addressEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, ipv4_address296.tree);

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleipv6_addressEx; /* Prevent compiler warnings */
    ruleipv6_addressEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end ipv6_address */

/**
 * $ANTLR start hexpart
 * belle_sdp.g:531:1: hexpart : ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? );
 */
static belle_sdpParser_hexpart_return
hexpart(pbelle_sdpParser ctx)
{
    belle_sdpParser_hexpart_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON299;
    pANTLR3_COMMON_TOKEN    COLON300;
    pANTLR3_COMMON_TOKEN    COLON302;
    pANTLR3_COMMON_TOKEN    COLON303;
    belle_sdpParser_hexseq_return hexseq297;
    #undef	RETURN_TYPE_hexseq297
    #define	RETURN_TYPE_hexseq297 belle_sdpParser_hexseq_return

    belle_sdpParser_hexseq_return hexseq298;
    #undef	RETURN_TYPE_hexseq298
    #define	RETURN_TYPE_hexseq298 belle_sdpParser_hexseq_return

    belle_sdpParser_hexseq_return hexseq301;
    #undef	RETURN_TYPE_hexseq301
    #define	RETURN_TYPE_hexseq301 belle_sdpParser_hexseq_return

    belle_sdpParser_hexseq_return hexseq304;
    #undef	RETURN_TYPE_hexseq304
    #define	RETURN_TYPE_hexseq304 belle_sdpParser_hexseq_return

    pANTLR3_BASE_TREE COLON299_tree;
    pANTLR3_BASE_TREE COLON300_tree;
    pANTLR3_BASE_TREE COLON302_tree;
    pANTLR3_BASE_TREE COLON303_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    COLON299       = NULL;
    COLON300       = NULL;
    COLON302       = NULL;
    COLON303       = NULL;
    hexseq297.tree = NULL;

    hexseq298.tree = NULL;

    hexseq301.tree = NULL;

    hexseq304.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COLON299_tree   = NULL;
    COLON300_tree   = NULL;
    COLON302_tree   = NULL;
    COLON303_tree   = NULL;


    retval.tree  = NULL;

    {
        {
            //  belle_sdp.g:531:16: ( hexseq | hexseq COLON COLON ( hexseq )? | COLON COLON ( hexseq )? )

            ANTLR3_UINT32 alt77;

            alt77=3;

            alt77 = cdfa77.predict(ctx, RECOGNIZER, ISTREAM, &cdfa77);
            if  (HASEXCEPTION())
            {
                goto rulehexpartEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            switch (alt77)
            {
        	case 1:
        	    // belle_sdp.g:531:19: hexseq
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart4108);
        	        hexseq297=hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexseq297.tree);

        	    }
        	    break;
        	case 2:
        	    // belle_sdp.g:531:28: hexseq COLON COLON ( hexseq )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart4112);
        	        hexseq298=hexseq(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexseq298.tree);

        	        COLON299 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_hexpart4114);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        COLON299_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON299));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COLON299_tree);
        	        }

        	        COLON300 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_hexpart4116);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        COLON300_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON300));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COLON300_tree);
        	        }

        	        // belle_sdp.g:531:47: ( hexseq )?
        	        {
        	            int alt75=2;
        	            switch ( LA(1) )
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt75=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt75)
        	            {
        	        	case 1:
        	        	    // belle_sdp.g:531:47: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart4118);
        	        	        hexseq301=hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexseq301.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;
        	case 3:
        	    // belle_sdp.g:531:57: COLON COLON ( hexseq )?
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        COLON302 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_hexpart4123);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        COLON302_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON302));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COLON302_tree);
        	        }

        	        COLON303 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_hexpart4125);
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulehexpartEx;
        	        }
        	        if (HASFAILED())
        	        {
        	            return retval;
        	        }

        	        if ( BACKTRACKING==0 ) {
        	        COLON303_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON303));
        	        ADAPTOR->addChild(ADAPTOR, root_0, COLON303_tree);
        	        }

        	        // belle_sdp.g:531:69: ( hexseq )?
        	        {
        	            int alt76=2;
        	            switch ( LA(1) )
        	            {
        	                case DIGIT:
        	                case HEX_CHAR:
        	                	{
        	                		alt76=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt76)
        	            {
        	        	case 1:
        	        	    // belle_sdp.g:531:69: hexseq
        	        	    {
        	        	        FOLLOWPUSH(FOLLOW_hexseq_in_hexpart4127);
        	        	        hexseq304=hexseq(ctx);

        	        	        FOLLOWPOP();
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto rulehexpartEx;
        	        	        }
        	        	        if (HASFAILED())
        	        	        {
        	        	            return retval;
        	        	        }

        	        	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexseq304.tree);

        	        	    }
        	        	    break;

        	            }
        	        }

        	    }
        	    break;

            }
        }
    }

    // This is where rules clean up and exit
    //
    goto rulehexpartEx; /* Prevent compiler warnings */
    rulehexpartEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end hexpart */

/**
 * $ANTLR start hexseq
 * belle_sdp.g:532:1: hexseq : hex4 ( COLON hex4 )* ;
 */
static belle_sdpParser_hexseq_return
hexseq(pbelle_sdpParser ctx)
{
    belle_sdpParser_hexseq_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    COLON306;
    belle_sdpParser_hex4_return hex4305;
    #undef	RETURN_TYPE_hex4305
    #define	RETURN_TYPE_hex4305 belle_sdpParser_hex4_return

    belle_sdpParser_hex4_return hex4307;
    #undef	RETURN_TYPE_hex4307
    #define	RETURN_TYPE_hex4307 belle_sdpParser_hex4_return

    pANTLR3_BASE_TREE COLON306_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    COLON306       = NULL;
    hex4305.tree = NULL;

    hex4307.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    COLON306_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:532:16: ( hex4 ( COLON hex4 )* )
        // belle_sdp.g:532:19: hex4 ( COLON hex4 )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_hex4_in_hexseq4145);
            hex4305=hex4(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto rulehexseqEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hex4305.tree);

            // belle_sdp.g:532:24: ( COLON hex4 )*

            for (;;)
            {
                int alt78=2;
                alt78 = cdfa78.predict(ctx, RECOGNIZER, ISTREAM, &cdfa78);
                if  (HASEXCEPTION())
                {
                    goto rulehexseqEx;
                }
                if (HASFAILED())
                {
                    return retval;
                }

                switch (alt78)
                {
            	case 1:
            	    // belle_sdp.g:532:26: COLON hex4
            	    {
            	        COLON306 = (pANTLR3_COMMON_TOKEN) MATCHT(COLON, &FOLLOW_COLON_in_hexseq4149);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        COLON306_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, COLON306));
            	        ADAPTOR->addChild(ADAPTOR, root_0, COLON306_tree);
            	        }

            	        FOLLOWPUSH(FOLLOW_hex4_in_hexseq4151);
            	        hex4307=hex4(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulehexseqEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hex4307.tree);

            	    }
            	    break;

            	default:
            	    goto loop78;	/* break out of the loop */
            	    break;
                }
            }
            loop78: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulehexseqEx; /* Prevent compiler warnings */
    rulehexseqEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end hexseq */

/**
 * $ANTLR start hex4
 * belle_sdp.g:533:1: hex4 : ( hexdigit )+ ;
 */
static belle_sdpParser_hex4_return
hex4(pbelle_sdpParser ctx)
{
    belle_sdpParser_hex4_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_hexdigit_return hexdigit308;
    #undef	RETURN_TYPE_hexdigit308
    #define	RETURN_TYPE_hexdigit308 belle_sdpParser_hexdigit_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    hexdigit308.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:533:16: ( ( hexdigit )+ )
        // belle_sdp.g:533:19: ( hexdigit )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:533:19: ( hexdigit )+
            {
                int cnt79=0;

                for (;;)
                {
                    int alt79=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt79=1;
            		}
            	    break;

            	}

            	switch (alt79)
            	{
            	    case 1:
            	        // belle_sdp.g:533:19: hexdigit
            	        {
            	            FOLLOWPUSH(FOLLOW_hexdigit_in_hex44172);
            	            hexdigit308=hexdigit(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulehex4Ex;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, hexdigit308.tree);

            	        }
            	        break;

            	    default:

            		if ( cnt79 >= 1 )
            		{
            		    goto loop79;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulehex4Ex;
            	}
            	cnt79++;
                }
                loop79: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulehex4Ex; /* Prevent compiler warnings */
    rulehex4Ex: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end hex4 */

/**
 * $ANTLR start text
 * belle_sdp.g:535:1: text : (~ ( CR | LF ) )* ;
 */
static belle_sdpParser_text_return
text(pbelle_sdpParser ctx)
{
    belle_sdpParser_text_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set309;

    pANTLR3_BASE_TREE set309_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set309       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set309_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:535:6: ( (~ ( CR | LF ) )* )
        // belle_sdp.g:535:23: (~ ( CR | LF ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:535:23: (~ ( CR | LF ) )*

            for (;;)
            {
                int alt80=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case SPACE:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt80=1;
                	}
                    break;

                }

                switch (alt80)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set309=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= COMMON_CHAR)) || ((LA(1) >= DASH) && (LA(1) <= HEX_CHAR)) || ((LA(1) >= LQUOTE) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set309))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruletextEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop80;	/* break out of the loop */
            	    break;
                }
            }
            loop80: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruletextEx; /* Prevent compiler warnings */
    ruletextEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end text */

/**
 * $ANTLR start byte_string
 * belle_sdp.g:540:1: byte_string options {greedy=false; } : ( OCTET )* ;
 */
static belle_sdpParser_byte_string_return
byte_string(pbelle_sdpParser ctx)
{
    belle_sdpParser_byte_string_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OCTET310;

    pANTLR3_BASE_TREE OCTET310_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    OCTET310       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    OCTET310_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:540:40: ( ( OCTET )* )
        // belle_sdp.g:540:49: ( OCTET )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:540:49: ( OCTET )*

            for (;;)
            {
                int alt81=2;
                switch ( LA(1) )
                {
                case OCTET:
                	{
                		alt81=1;
                	}
                    break;

                }

                switch (alt81)
                {
            	case 1:
            	    // belle_sdp.g:540:50: OCTET
            	    {
            	        OCTET310 = (pANTLR3_COMMON_TOKEN) MATCHT(OCTET, &FOLLOW_OCTET_in_byte_string4300);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulebyte_stringEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        OCTET310_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OCTET310));
            	        ADAPTOR->addChild(ADAPTOR, root_0, OCTET310_tree);
            	        }

            	    }
            	    break;

            	default:
            	    goto loop81;	/* break out of the loop */
            	    break;
                }
            }
            loop81: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto rulebyte_stringEx; /* Prevent compiler warnings */
    rulebyte_stringEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end byte_string */

/**
 * $ANTLR start decimal_uchar
 * belle_sdp.g:543:1: decimal_uchar : integer ;
 */
static belle_sdpParser_decimal_uchar_return
decimal_uchar(pbelle_sdpParser ctx)
{
    belle_sdpParser_decimal_uchar_return retval;


    pANTLR3_BASE_TREE root_0;

    belle_sdpParser_integer_return integer311;
    #undef	RETURN_TYPE_integer311
    #define	RETURN_TYPE_integer311 belle_sdpParser_integer_return


    /* Initialize rule variables
     */

    root_0 = NULL;

    integer311.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;




    retval.tree  = NULL;

    {
        // belle_sdp.g:543:14: ( integer )
        // belle_sdp.g:543:22: integer
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            FOLLOWPUSH(FOLLOW_integer_in_decimal_uchar4343);
            integer311=integer(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruledecimal_ucharEx;
            }
            if (HASFAILED())
            {
                return retval;
            }

            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, integer311.tree);

        }

    }

    // This is where rules clean up and exit
    //
    goto ruledecimal_ucharEx; /* Prevent compiler warnings */
    ruledecimal_ucharEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end decimal_uchar */

/**
 * $ANTLR start integer
 * belle_sdp.g:545:1: integer : ( DIGIT )+ ;
 */
static belle_sdpParser_integer_return
integer(pbelle_sdpParser ctx)
{
    belle_sdpParser_integer_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT312;

    pANTLR3_BASE_TREE DIGIT312_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT312       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT312_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:545:8: ( ( DIGIT )+ )
        // belle_sdp.g:545:22: ( DIGIT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:545:22: ( DIGIT )+
            {
                int cnt82=0;

                for (;;)
                {
                    int alt82=2;
            	switch ( LA(1) )
            	{
            	case DIGIT:
            		{
            			alt82=1;
            		}
            	    break;

            	}

            	switch (alt82)
            	{
            	    case 1:
            	        // belle_sdp.g:545:22: DIGIT
            	        {
            	            DIGIT312 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_integer4362);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruleintegerEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DIGIT312_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT312));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DIGIT312_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt82 >= 1 )
            		{
            		    goto loop82;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruleintegerEx;
            	}
            	cnt82++;
                }
                loop82: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruleintegerEx; /* Prevent compiler warnings */
    ruleintegerEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end integer */

/**
 * $ANTLR start email_safe
 * belle_sdp.g:547:1: email_safe : (~ ( SPACE ) )* ;
 */
static belle_sdpParser_email_safe_return
email_safe(pbelle_sdpParser ctx)
{
    belle_sdpParser_email_safe_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set313;

    pANTLR3_BASE_TREE set313_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set313       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set313_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:547:12: ( (~ ( SPACE ) )* )
        // belle_sdp.g:547:14: (~ ( SPACE ) )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:547:14: (~ ( SPACE ) )*

            for (;;)
            {
                int alt83=2;
                switch ( LA(1) )
                {
                case COLON:
                case COMMA:
                case COMMON_CHAR:
                case CR:
                case DASH:
                case DIGIT:
                case DOT:
                case EQUAL:
                case HEX_CHAR:
                case LF:
                case LQUOTE:
                case OCTET:
                case POS_DIGIT:
                case RQUOTE:
                case SLASH:
                case STAR:
                case ZERO:
                case 22:
                case 23:
                case 24:
                case 25:
                case 26:
                case 27:
                case 28:
                	{
                		alt83=1;
                	}
                    break;

                }

                switch (alt83)
                {
            	case 1:
            	    // belle_sdp.g:
            	    {
            	        set313=(pANTLR3_COMMON_TOKEN)LT(1);

            	        if ( ((LA(1) >= COLON) && (LA(1) <= SLASH)) || ((LA(1) >= STAR) && (LA(1) <= 28)) )
            	        {
            	            CONSUME();
            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
            	            (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set313))
            	            );
            	            PERRORRECOVERY=ANTLR3_FALSE;
            	            FAILEDFLAG=ANTLR3_FALSE;

            	        }
            	        else
            	        {
            	            if (BACKTRACKING>0)
            	            {
            	                FAILEDFLAG = ANTLR3_TRUE;
            	                return retval;
            	            }

            	            CONSTRUCTEX();
            	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
            	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
            	            EXCEPTION->expectingSet = NULL;

            	            goto ruleemail_safeEx;
            	        }


            	    }
            	    break;

            	default:
            	    goto loop83;	/* break out of the loop */
            	    break;
                }
            }
            loop83: ; /* Jump out to here if this rule does not match */


        }

    }

    // This is where rules clean up and exit
    //
    goto ruleemail_safeEx; /* Prevent compiler warnings */
    ruleemail_safeEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end email_safe */

/**
 * $ANTLR start token
 * belle_sdp.g:549:1: token : ( alpha_num | '!' | '#' | '$' | '&' | '%' | '\\'' | '*' | '+' | DASH | DOT )+ ;
 */
static belle_sdpParser_token_return
token(pbelle_sdpParser ctx)
{
    belle_sdpParser_token_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    char_literal315;
    pANTLR3_COMMON_TOKEN    char_literal316;
    pANTLR3_COMMON_TOKEN    char_literal317;
    pANTLR3_COMMON_TOKEN    char_literal318;
    pANTLR3_COMMON_TOKEN    char_literal319;
    pANTLR3_COMMON_TOKEN    char_literal320;
    pANTLR3_COMMON_TOKEN    char_literal321;
    pANTLR3_COMMON_TOKEN    char_literal322;
    pANTLR3_COMMON_TOKEN    DASH323;
    pANTLR3_COMMON_TOKEN    DOT324;
    belle_sdpParser_alpha_num_return alpha_num314;
    #undef	RETURN_TYPE_alpha_num314
    #define	RETURN_TYPE_alpha_num314 belle_sdpParser_alpha_num_return

    pANTLR3_BASE_TREE char_literal315_tree;
    pANTLR3_BASE_TREE char_literal316_tree;
    pANTLR3_BASE_TREE char_literal317_tree;
    pANTLR3_BASE_TREE char_literal318_tree;
    pANTLR3_BASE_TREE char_literal319_tree;
    pANTLR3_BASE_TREE char_literal320_tree;
    pANTLR3_BASE_TREE char_literal321_tree;
    pANTLR3_BASE_TREE char_literal322_tree;
    pANTLR3_BASE_TREE DASH323_tree;
    pANTLR3_BASE_TREE DOT324_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    char_literal315       = NULL;
    char_literal316       = NULL;
    char_literal317       = NULL;
    char_literal318       = NULL;
    char_literal319       = NULL;
    char_literal320       = NULL;
    char_literal321       = NULL;
    char_literal322       = NULL;
    DASH323       = NULL;
    DOT324       = NULL;
    alpha_num314.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    char_literal315_tree   = NULL;
    char_literal316_tree   = NULL;
    char_literal317_tree   = NULL;
    char_literal318_tree   = NULL;
    char_literal319_tree   = NULL;
    char_literal320_tree   = NULL;
    char_literal321_tree   = NULL;
    char_literal322_tree   = NULL;
    DASH323_tree   = NULL;
    DOT324_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:549:7: ( ( alpha_num | '!' | '#' | '$' | '&' | '%' | '\\'' | '*' | '+' | DASH | DOT )+ )
        // belle_sdp.g:549:9: ( alpha_num | '!' | '#' | '$' | '&' | '%' | '\\'' | '*' | '+' | DASH | DOT )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:549:9: ( alpha_num | '!' | '#' | '$' | '&' | '%' | '\\'' | '*' | '+' | DASH | DOT )+
            {
                int cnt84=0;

                for (;;)
                {
                    int alt84=12;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case DIGIT:
            	case HEX_CHAR:
            		{
            			alt84=1;
            		}
            	    break;
            	case 22:
            		{
            			alt84=2;
            		}
            	    break;
            	case 23:
            		{
            			alt84=3;
            		}
            	    break;
            	case 24:
            		{
            			alt84=4;
            		}
            	    break;
            	case 26:
            		{
            			alt84=5;
            		}
            	    break;
            	case 25:
            		{
            			alt84=6;
            		}
            	    break;
            	case 28:
            		{
            			alt84=7;
            		}
            	    break;
            	case STAR:
            		{
            			alt84=8;
            		}
            	    break;
            	case 27:
            		{
            			alt84=9;
            		}
            	    break;
            	case DASH:
            		{
            			alt84=10;
            		}
            	    break;
            	case DOT:
            		{
            			alt84=11;
            		}
            	    break;

            	}

            	switch (alt84)
            	{
            	    case 1:
            	        // belle_sdp.g:549:10: alpha_num
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_num_in_token4387);
            	            alpha_num314=alpha_num(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha_num314.tree);

            	        }
            	        break;
            	    case 2:
            	        // belle_sdp.g:549:22: '!'
            	        {
            	            char_literal315 = (pANTLR3_COMMON_TOKEN) MATCHT(22, &FOLLOW_22_in_token4391);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal315_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal315));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal315_tree);
            	            }

            	        }
            	        break;
            	    case 3:
            	        // belle_sdp.g:549:28: '#'
            	        {
            	            char_literal316 = (pANTLR3_COMMON_TOKEN) MATCHT(23, &FOLLOW_23_in_token4395);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal316_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal316));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal316_tree);
            	            }

            	        }
            	        break;
            	    case 4:
            	        // belle_sdp.g:549:34: '$'
            	        {
            	            char_literal317 = (pANTLR3_COMMON_TOKEN) MATCHT(24, &FOLLOW_24_in_token4399);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal317_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal317));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal317_tree);
            	            }

            	        }
            	        break;
            	    case 5:
            	        // belle_sdp.g:549:39: '&'
            	        {
            	            char_literal318 = (pANTLR3_COMMON_TOKEN) MATCHT(26, &FOLLOW_26_in_token4402);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal318_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal318));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal318_tree);
            	            }

            	        }
            	        break;
            	    case 6:
            	        // belle_sdp.g:549:44: '%'
            	        {
            	            char_literal319 = (pANTLR3_COMMON_TOKEN) MATCHT(25, &FOLLOW_25_in_token4405);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal319_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal319));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal319_tree);
            	            }

            	        }
            	        break;
            	    case 7:
            	        // belle_sdp.g:549:49: '\\''
            	        {
            	            char_literal320 = (pANTLR3_COMMON_TOKEN) MATCHT(28, &FOLLOW_28_in_token4408);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal320_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal320));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal320_tree);
            	            }

            	        }
            	        break;
            	    case 8:
            	        // belle_sdp.g:549:56: '*'
            	        {
            	            char_literal321 = (pANTLR3_COMMON_TOKEN) MATCHT(STAR, &FOLLOW_STAR_in_token4412);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal321_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal321));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal321_tree);
            	            }

            	        }
            	        break;
            	    case 9:
            	        // belle_sdp.g:549:61: '+'
            	        {
            	            char_literal322 = (pANTLR3_COMMON_TOKEN) MATCHT(27, &FOLLOW_27_in_token4415);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            char_literal322_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal322));
            	            ADAPTOR->addChild(ADAPTOR, root_0, char_literal322_tree);
            	            }

            	        }
            	        break;
            	    case 10:
            	        // belle_sdp.g:549:67: DASH
            	        {
            	            DASH323 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_token4419);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DASH323_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DASH323));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DASH323_tree);
            	            }

            	        }
            	        break;
            	    case 11:
            	        // belle_sdp.g:549:74: DOT
            	        {
            	            DOT324 = (pANTLR3_COMMON_TOKEN) MATCHT(DOT, &FOLLOW_DOT_in_token4423);
            	            if  (HASEXCEPTION())
            	            {
            	                goto ruletokenEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DOT324_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DOT324));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DOT324_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt84 >= 1 )
            		{
            		    goto loop84;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto ruletokenEx;
            	}
            	cnt84++;
                }
                loop84: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto ruletokenEx; /* Prevent compiler warnings */
    ruletokenEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end token */

/**
 * $ANTLR start alpha_num
 * belle_sdp.g:551:1: alpha_num : ( alpha | DIGIT ) ;
 */
static belle_sdpParser_alpha_num_return
alpha_num(pbelle_sdpParser ctx)
{
    belle_sdpParser_alpha_num_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DIGIT326;
    belle_sdpParser_alpha_return alpha325;
    #undef	RETURN_TYPE_alpha325
    #define	RETURN_TYPE_alpha325 belle_sdpParser_alpha_return

    pANTLR3_BASE_TREE DIGIT326_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DIGIT326       = NULL;
    alpha325.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DIGIT326_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:551:10: ( ( alpha | DIGIT ) )
        // belle_sdp.g:551:15: ( alpha | DIGIT )
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:551:15: ( alpha | DIGIT )
            {
                int alt85=2;
                switch ( LA(1) )
                {
                case COMMON_CHAR:
                case HEX_CHAR:
                	{
                		alt85=1;
                	}
                    break;
                case DIGIT:
                	{
                		alt85=2;
                	}
                    break;

                default:
                    if (BACKTRACKING>0)
                    {
                        FAILEDFLAG = ANTLR3_TRUE;
                        return retval;
                    }

                    CONSTRUCTEX();
                    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                    EXCEPTION->message      = (void *)"";
                    EXCEPTION->decisionNum  = 85;
                    EXCEPTION->state        = 0;


                    goto rulealpha_numEx;

                }

                switch (alt85)
                {
            	case 1:
            	    // belle_sdp.g:551:16: alpha
            	    {
            	        FOLLOWPUSH(FOLLOW_alpha_in_alpha_num4436);
            	        alpha325=alpha(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealpha_numEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha325.tree);

            	    }
            	    break;
            	case 2:
            	    // belle_sdp.g:551:24: DIGIT
            	    {
            	        DIGIT326 = (pANTLR3_COMMON_TOKEN) MATCHT(DIGIT, &FOLLOW_DIGIT_in_alpha_num4440);
            	        if  (HASEXCEPTION())
            	        {
            	            goto rulealpha_numEx;
            	        }
            	        if (HASFAILED())
            	        {
            	            return retval;
            	        }

            	        if ( BACKTRACKING==0 ) {
            	        DIGIT326_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DIGIT326));
            	        ADAPTOR->addChild(ADAPTOR, root_0, DIGIT326_tree);
            	        }

            	    }
            	    break;

                }
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulealpha_numEx; /* Prevent compiler warnings */
    rulealpha_numEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end alpha_num */

/**
 * $ANTLR start hexdigit
 * belle_sdp.g:552:1: hexdigit : ( HEX_CHAR | DIGIT ) ;
 */
static belle_sdpParser_hexdigit_return
hexdigit(pbelle_sdpParser ctx)
{
    belle_sdpParser_hexdigit_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set327;

    pANTLR3_BASE_TREE set327_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set327       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set327_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:552:9: ( ( HEX_CHAR | DIGIT ) )
        // belle_sdp.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set327=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == DIGIT || LA(1) == HEX_CHAR )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set327))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulehexdigitEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulehexdigitEx; /* Prevent compiler warnings */
    rulehexdigitEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end hexdigit */

/**
 * $ANTLR start word
 * belle_sdp.g:553:1: word : ( alpha | DASH )+ ;
 */
static belle_sdpParser_word_return
word(pbelle_sdpParser ctx)
{
    belle_sdpParser_word_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DASH329;
    belle_sdpParser_alpha_return alpha328;
    #undef	RETURN_TYPE_alpha328
    #define	RETURN_TYPE_alpha328 belle_sdpParser_alpha_return

    pANTLR3_BASE_TREE DASH329_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    DASH329       = NULL;
    alpha328.tree = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    DASH329_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:553:5: ( ( alpha | DASH )+ )
        // belle_sdp.g:553:7: ( alpha | DASH )+
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            // belle_sdp.g:553:7: ( alpha | DASH )+
            {
                int cnt86=0;

                for (;;)
                {
                    int alt86=3;
            	switch ( LA(1) )
            	{
            	case COMMON_CHAR:
            	case HEX_CHAR:
            		{
            			alt86=1;
            		}
            	    break;
            	case DASH:
            		{
            			alt86=2;
            		}
            	    break;

            	}

            	switch (alt86)
            	{
            	    case 1:
            	        // belle_sdp.g:553:8: alpha
            	        {
            	            FOLLOWPUSH(FOLLOW_alpha_in_word4462);
            	            alpha328=alpha(ctx);

            	            FOLLOWPOP();
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, alpha328.tree);

            	        }
            	        break;
            	    case 2:
            	        // belle_sdp.g:553:16: DASH
            	        {
            	            DASH329 = (pANTLR3_COMMON_TOKEN) MATCHT(DASH, &FOLLOW_DASH_in_word4466);
            	            if  (HASEXCEPTION())
            	            {
            	                goto rulewordEx;
            	            }
            	            if (HASFAILED())
            	            {
            	                return retval;
            	            }

            	            if ( BACKTRACKING==0 ) {
            	            DASH329_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DASH329));
            	            ADAPTOR->addChild(ADAPTOR, root_0, DASH329_tree);
            	            }

            	        }
            	        break;

            	    default:

            		if ( cnt86 >= 1 )
            		{
            		    goto loop86;
            		}
            		if (BACKTRACKING>0)
            		{
            		    FAILEDFLAG = ANTLR3_TRUE;
            		    return retval;
            		}

            		/* mismatchedSetEx()
            		 */
            		CONSTRUCTEX();
            		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
            		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


            		goto rulewordEx;
            	}
            	cnt86++;
                }
                loop86: ;	/* Jump to here if this rule does not match */
            }

        }

    }

    // This is where rules clean up and exit
    //
    goto rulewordEx; /* Prevent compiler warnings */
    rulewordEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end word */

/**
 * $ANTLR start alpha
 * belle_sdp.g:554:1: alpha : ( COMMON_CHAR | HEX_CHAR );
 */
static belle_sdpParser_alpha_return
alpha(pbelle_sdpParser ctx)
{
    belle_sdpParser_alpha_return retval;


    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    set330;

    pANTLR3_BASE_TREE set330_tree;

    /* Initialize rule variables
     */

    root_0 = NULL;

    set330       = NULL;
    retval.start = LT(1); retval.stop = retval.start;


    set330_tree   = NULL;


    retval.tree  = NULL;

    {
        // belle_sdp.g:554:6: ( COMMON_CHAR | HEX_CHAR )
        // belle_sdp.g:
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


            set330=(pANTLR3_COMMON_TOKEN)LT(1);

            if ( LA(1) == COMMON_CHAR || LA(1) == HEX_CHAR )
            {
                CONSUME();
                if ( BACKTRACKING==0 ) ADAPTOR->addChild(ADAPTOR, root_0, 
                (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set330))
                );
                PERRORRECOVERY=ANTLR3_FALSE;
                FAILEDFLAG=ANTLR3_FALSE;

            }
            else
            {
                if (BACKTRACKING>0)
                {
                    FAILEDFLAG = ANTLR3_TRUE;
                    return retval;
                }

                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
                EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
                EXCEPTION->expectingSet = NULL;

                goto rulealphaEx;
            }


        }

    }

    // This is where rules clean up and exit
    //
    goto rulealphaEx; /* Prevent compiler warnings */
    rulealphaEx: ;
    retval.stop = LT(-1);


    if ( BACKTRACKING==0 )
    {

    	retval.stop = LT(-1);

    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
    }



                if (HASEXCEPTION())
                {

                // This is ugly.  We set the exception type to ANTLR3_RECOGNITION_EXCEPTION so we can always
                // catch them.
                //PREPORTERROR();
                EXCEPTION->type = ANTLR3_RECOGNITION_EXCEPTION;
                }

    return retval;
}
/* $ANTLR end alpha */

// $ANTLR start synpred1_belle_sdp
static void synpred1_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:255:2: ( pkt_loss_rle )
    // belle_sdp.g:255:3: pkt_loss_rle
    {
        FOLLOWPUSH(FOLLOW_pkt_loss_rle_in_synpred1_belle_sdp1685);
        pkt_loss_rle(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred1_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred1_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred1_belle_sdpEx: ;

}
// $ANTLR end synpred1_belle_sdp

// $ANTLR start synpred2_belle_sdp
static void synpred2_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:256:3: ( pkt_dup_rle )
    // belle_sdp.g:256:4: pkt_dup_rle
    {
        FOLLOWPUSH(FOLLOW_pkt_dup_rle_in_synpred2_belle_sdp1694);
        pkt_dup_rle(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred2_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred2_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred2_belle_sdpEx: ;

}
// $ANTLR end synpred2_belle_sdp

// $ANTLR start synpred3_belle_sdp
static void synpred3_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:257:3: ( pkt_rcpt_times )
    // belle_sdp.g:257:4: pkt_rcpt_times
    {
        FOLLOWPUSH(FOLLOW_pkt_rcpt_times_in_synpred3_belle_sdp1703);
        pkt_rcpt_times(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred3_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred3_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred3_belle_sdpEx: ;

}
// $ANTLR end synpred3_belle_sdp

// $ANTLR start synpred4_belle_sdp
static void synpred4_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:258:3: ( rcvr_rtt )
    // belle_sdp.g:258:4: rcvr_rtt
    {
        FOLLOWPUSH(FOLLOW_rcvr_rtt_in_synpred4_belle_sdp1712);
        rcvr_rtt(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred4_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred4_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred4_belle_sdpEx: ;

}
// $ANTLR end synpred4_belle_sdp

// $ANTLR start synpred5_belle_sdp
static void synpred5_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:259:3: ( stat_summary )
    // belle_sdp.g:259:4: stat_summary
    {
        FOLLOWPUSH(FOLLOW_stat_summary_in_synpred5_belle_sdp1721);
        stat_summary(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred5_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred5_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred5_belle_sdpEx: ;

}
// $ANTLR end synpred5_belle_sdp

// $ANTLR start synpred6_belle_sdp
static void synpred6_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:260:3: ( voip_metrics )
    // belle_sdp.g:260:4: voip_metrics
    {
        FOLLOWPUSH(FOLLOW_voip_metrics_in_synpred6_belle_sdp1730);
        voip_metrics(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred6_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred6_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred6_belle_sdpEx: ;

}
// $ANTLR end synpred6_belle_sdp

// $ANTLR start synpred7_belle_sdp
static void synpred7_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:312:2: ( rtcp_fb_ack_val )
    // belle_sdp.g:312:3: rtcp_fb_ack_val
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_ack_val_in_synpred7_belle_sdp1961);
        rtcp_fb_ack_val(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred7_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred7_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred7_belle_sdpEx: ;

}
// $ANTLR end synpred7_belle_sdp

// $ANTLR start synpred8_belle_sdp
static void synpred8_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:313:3: ( rtcp_fb_nack_val )
    // belle_sdp.g:313:4: rtcp_fb_nack_val
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_nack_val_in_synpred8_belle_sdp1969);
        rtcp_fb_nack_val(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred8_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred8_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred8_belle_sdpEx: ;

}
// $ANTLR end synpred8_belle_sdp

// $ANTLR start synpred9_belle_sdp
static void synpred9_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:314:3: ( rtcp_fb_trr_int_val )
    // belle_sdp.g:314:4: rtcp_fb_trr_int_val
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_trr_int_val_in_synpred9_belle_sdp1977);
        rtcp_fb_trr_int_val(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred9_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred9_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred9_belle_sdpEx: ;

}
// $ANTLR end synpred9_belle_sdp

// $ANTLR start synpred10_belle_sdp
static void synpred10_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:315:3: ( rtcp_fb_ccm_val )
    // belle_sdp.g:315:4: rtcp_fb_ccm_val
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_ccm_val_in_synpred10_belle_sdp1985);
        rtcp_fb_ccm_val(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred10_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred10_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred10_belle_sdpEx: ;

}
// $ANTLR end synpred10_belle_sdp

// $ANTLR start synpred11_belle_sdp
static void synpred11_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:316:3: ( rtcp_fb_id_val )
    // belle_sdp.g:316:4: rtcp_fb_id_val
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_id_val_in_synpred11_belle_sdp1993);
        rtcp_fb_id_val(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred11_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred11_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred11_belle_sdpEx: ;

}
// $ANTLR end synpred11_belle_sdp

// $ANTLR start synpred12_belle_sdp
static void synpred12_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:343:2: ( rtcp_fb_app_param )
    // belle_sdp.g:343:3: rtcp_fb_app_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_synpred12_belle_sdp2101);
        rtcp_fb_app_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred12_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred12_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred12_belle_sdpEx: ;

}
// $ANTLR end synpred12_belle_sdp

// $ANTLR start synpred13_belle_sdp
static void synpred13_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:344:3: ( rtcp_fb_token_param )
    // belle_sdp.g:344:4: rtcp_fb_token_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_synpred13_belle_sdp2109);
        rtcp_fb_token_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred13_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred13_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred13_belle_sdpEx: ;

}
// $ANTLR end synpred13_belle_sdp

// $ANTLR start synpred14_belle_sdp
static void synpred14_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:347:2: ( rtcp_fb_rpsi_param )
    // belle_sdp.g:347:3: rtcp_fb_rpsi_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_rpsi_param_in_synpred14_belle_sdp2121);
        rtcp_fb_rpsi_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred14_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred14_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred14_belle_sdpEx: ;

}
// $ANTLR end synpred14_belle_sdp

// $ANTLR start synpred15_belle_sdp
static void synpred15_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:348:3: ( rtcp_fb_app_param )
    // belle_sdp.g:348:4: rtcp_fb_app_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_synpred15_belle_sdp2129);
        rtcp_fb_app_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred15_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred15_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred15_belle_sdpEx: ;

}
// $ANTLR end synpred15_belle_sdp

// $ANTLR start synpred16_belle_sdp
static void synpred16_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:349:3: ( rtcp_fb_token_param )
    // belle_sdp.g:349:4: rtcp_fb_token_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_synpred16_belle_sdp2137);
        rtcp_fb_token_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred16_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred16_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred16_belle_sdpEx: ;

}
// $ANTLR end synpred16_belle_sdp

// $ANTLR start synpred17_belle_sdp
static void synpred17_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:352:2: ( rtcp_fb_pli_param )
    // belle_sdp.g:352:3: rtcp_fb_pli_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_pli_param_in_synpred17_belle_sdp2149);
        rtcp_fb_pli_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred17_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred17_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred17_belle_sdpEx: ;

}
// $ANTLR end synpred17_belle_sdp

// $ANTLR start synpred18_belle_sdp
static void synpred18_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:353:3: ( rtcp_fb_sli_param )
    // belle_sdp.g:353:4: rtcp_fb_sli_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_sli_param_in_synpred18_belle_sdp2157);
        rtcp_fb_sli_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred18_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred18_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred18_belle_sdpEx: ;

}
// $ANTLR end synpred18_belle_sdp

// $ANTLR start synpred19_belle_sdp
static void synpred19_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:354:3: ( rtcp_fb_rpsi_param )
    // belle_sdp.g:354:4: rtcp_fb_rpsi_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_rpsi_param_in_synpred19_belle_sdp2165);
        rtcp_fb_rpsi_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred19_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred19_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred19_belle_sdpEx: ;

}
// $ANTLR end synpred19_belle_sdp

// $ANTLR start synpred20_belle_sdp
static void synpred20_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:355:3: ( rtcp_fb_app_param )
    // belle_sdp.g:355:4: rtcp_fb_app_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_app_param_in_synpred20_belle_sdp2173);
        rtcp_fb_app_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred20_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred20_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred20_belle_sdpEx: ;

}
// $ANTLR end synpred20_belle_sdp

// $ANTLR start synpred21_belle_sdp
static void synpred21_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:356:3: ( rtcp_fb_token_param )
    // belle_sdp.g:356:4: rtcp_fb_token_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_synpred21_belle_sdp2181);
        rtcp_fb_token_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred21_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred21_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred21_belle_sdpEx: ;

}
// $ANTLR end synpred21_belle_sdp

// $ANTLR start synpred22_belle_sdp
static void synpred22_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:379:2: ( rtcp_fb_fir_param )
    // belle_sdp.g:379:3: rtcp_fb_fir_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_fir_param_in_synpred22_belle_sdp2255);
        rtcp_fb_fir_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred22_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred22_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred22_belle_sdpEx: ;

}
// $ANTLR end synpred22_belle_sdp

// $ANTLR start synpred23_belle_sdp
static void synpred23_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:380:3: ( rtcp_fb_token_param )
    // belle_sdp.g:380:4: rtcp_fb_token_param
    {
        FOLLOWPUSH(FOLLOW_rtcp_fb_token_param_in_synpred23_belle_sdp2263);
        rtcp_fb_token_param(ctx);

        FOLLOWPOP();
        if  (HASEXCEPTION())
        {
            goto rulesynpred23_belle_sdpEx;
        }
        if (HASFAILED())
        {
            return ;
        }


    }

// This is where rules clean up and exit
//
goto rulesynpred23_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred23_belle_sdpEx: ;

}
// $ANTLR end synpred23_belle_sdp

// $ANTLR start synpred24_belle_sdp
static void synpred24_belle_sdp_fragment(pbelle_sdpParser ctx )
{
    // belle_sdp.g:427:47: ( ( DIGIT )+ )
    // belle_sdp.g:427:48: ( DIGIT )+
    {
        // belle_sdp.g:427:48: ( DIGIT )+
        {
            int cnt87=0;

            for (;;)
            {
                int alt87=2;
        	switch ( LA(1) )
        	{
        	case DIGIT:
        		{
        			alt87=1;
        		}
        	    break;

        	}

        	switch (alt87)
        	{
        	    case 1:
        	        // belle_sdp.g:427:48: DIGIT
        	        {
        	             MATCHT(DIGIT, &FOLLOW_DIGIT_in_synpred24_belle_sdp2734);
        	            if  (HASEXCEPTION())
        	            {
        	                goto rulesynpred24_belle_sdpEx;
        	            }
        	            if (HASFAILED())
        	            {
        	                return ;
        	            }


        	        }
        	        break;

        	    default:

        		if ( cnt87 >= 1 )
        		{
        		    goto loop87;
        		}
        		if (BACKTRACKING>0)
        		{
        		    FAILEDFLAG = ANTLR3_TRUE;
        		    return ;
        		}

        		/* mismatchedSetEx()
        		 */
        		CONSTRUCTEX();
        		EXCEPTION->type = ANTLR3_EARLY_EXIT_EXCEPTION;
        		EXCEPTION->name = (void *)ANTLR3_EARLY_EXIT_NAME;


        		goto rulesynpred24_belle_sdpEx;
        	}
        	cnt87++;
            }
            loop87: ;	/* Jump to here if this rule does not match */
        }

    }

// This is where rules clean up and exit
//
goto rulesynpred24_belle_sdpEx; /* Prevent compiler warnings */
rulesynpred24_belle_sdpEx: ;

}
// $ANTLR end synpred24_belle_sdp
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
static ANTLR3_BOOLEAN synpred14_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred14_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred6_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred6_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred20_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred20_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred21_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred21_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred5_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred5_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred19_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred19_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred13_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred13_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred4_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred4_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred22_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred22_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred7_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred7_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred15_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred15_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred9_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred9_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred24_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred24_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred17_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred17_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred2_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred2_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred10_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred10_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred12_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred12_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred11_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred11_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred18_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred18_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred3_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred3_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred23_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred23_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred16_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred16_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred1_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred1_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}
static ANTLR3_BOOLEAN synpred8_belle_sdp(pbelle_sdpParser ctx)
{
    ANTLR3_MARKER   start;
    ANTLR3_BOOLEAN  success;

    BACKTRACKING++;
    start	= MARK();
    synpred8_belle_sdp_fragment(ctx);	    // can never throw exception
    success	= !(FAILEDFLAG);
    REWIND(start);
    BACKTRACKING--;
    FAILEDFLAG	= ANTLR3_FALSE;
    return success;
}

/* End of syntactic predicates
 * ==============================================
 */






/* End of code
 * =============================================================================
 */
